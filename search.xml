<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web安全工具]]></title>
    <url>%2F2017%2F10%2F23%2Fweb%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[根据网易web安全工程师所做笔记 记录学习之路 前文完结 本文为第三章 大坑待填 浏览器拓展初级 可以将阻止弹出式窗口关闭，便于测试 Firefox四个插件 Firebug HackBar Advanced Cookie Manager Proxy Switcher #代理的工作原理 “代理”可对经过的数据包进行记录，拦截，修改，再次发送，丢弃等操作 ##浏览器的代理设置 可以手动设置 常用HTTP代理工具：Burpsuite ， Charles ， Fiddler #敏感文件探测实践 猜测文件名，根据返回的HTTP状态码判断文件是否存在 200：文件存在 301：文件发生跳转 用”御剑”扫描敏感文件 通过判断index的文件类型确定网站脚本类型，如在网址中访问index.asp、index.php、index.aspx、index.jsp来选择字典]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>学习</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全基础]]></title>
    <url>%2F2017%2F10%2F21%2Fweb%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[根据网易web安全工程师所做笔记 记录学习之路 前文完结 本文为第二章 大坑已填 利用搜索引擎关键字 intitle:Hacked by //网站被黑关键字，不过是黑客为了炫耀罢了 intitle:keyword //标题中含有关键字的网页 intext:keyword //正文中含有关键字的网页 site:域名 //搜索某个域名或者子域名的网页 暗链 隐藏在网站当中链接 网游/医疗/博彩/色情 针对搜索引擎，提高在搜索引擎的排名（SEO） Webshell 网页 功能强大（大部分的命令操作） asp/php/jsp 后门程序 XSS什么是XSS? Cross Site Script 跨站脚本 危害：盗取用户信息，钓鱼，蠕虫 针对前端语言的注入，可以盗取CookieXSS分类？存储型 访问网站，触发XSS 从数据库中提取XSS反射型 主动访问携带XSS脚本的链接 触发XSSDOM型 主动访问携带XSS脚本的链接 触发XSS CSRF漏洞 Cross-site request forgery 跨站请求伪造 危害：执行恶意操作（转账，制造蠕虫等） 利用用户已登录的身份，在用户毫不知情的情况下，以用户名义完成操作 点击劫持漏洞 通过覆盖不可见的框架进行攻击 隐蔽性高 骗取用户操作 UI-覆盖攻击 利用iframe或者其他标签的属性 URL跳转漏洞 Header头跳转 Javascript跳转 META标签跳转 http://www.熟悉链接.com?url=www.诈骗网站.com SQL注入 常见web安全漏洞，攻击者利用这个漏洞，可以访问和修改数据，或者利用数据库漏洞攻击 必备条件 可以控制输入的数据 服务器要执行的代码拼接了控制的数据 数据和代码未分离，即数据当成代码来执行 危害 获取服务器权限 植入Webshell 读取服务器敏感文件 万能密码 命令注入 调用可执行系统命令的函数 函数或函数的参数可控 拼接注入命令 文件操作漏洞文件上传漏洞- 上传头像 - 上传附件 &gt; - 文件处理不当 - 可以上传可执行脚本 - 脚本拥有执行权限 任意文件下载- 下载APP - 下载附件 &gt; - 没有验证请求文件名 &gt; - 没有限制请求路径 文件包含漏洞- 本地文件包含 - 远程文件包含]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>学习</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web基础知识]]></title>
    <url>%2F2017%2F10%2F21%2Fweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[在不断打代码的过程中，消遣生活 丰富课余生活 毕竟有着一个红客梦 记录web安全学习之路 根据网易web安全工程师课程所作笔记 本文为第一章 大坑已填 web是什么？ World Wide Web 万维网 非常普遍的互联网应用 平时流量的网页 经历了Web1.0，Web2.0等阶段 Web1.0主要是静态页面 Web2.0类似于博客等页面 web的工作流程 通过dns请求，发送域名到dns服务器，得到解析后的ip地址，然后便可以通过解析完毕的ip地址来访问一个网址。 url的详细格式 schema://host[:port#]/path/…/[?query-string][#anchor] schema：底层协议，如:http,https,ftp host：服务器域名或者IP地址 port： 端口，默认80端口 path： 访问资源的路径 ?query-string： 发送给http服务器的数据 anchor： 锚 什么是HTTP? web使用的协议，即超文本传输协议 应用最广泛，web基础 Hyper Text Transfer Protocol什么是HTTPS? 可以简单来说，HTTPS = HTTP + SSL 相对于HTTP来说，HTTPS更为安全 HTTP标准端口是80，HTTPS标准端口则为443 HTTP无需加密，HTTPS对传输的数据进行加密 HTTP无需证书，HTTPS需要认证证书 Javascript Bom 警告弹窗 alert() 确认弹窗 confirm() 提示弹窗 prompt() Bom浏览器对象模型 以后测试可能会用到 检验是否有漏洞 建议熟记 HTML常用标签1234567891011121314151617181920&lt;h1&gt;&lt;/h1&gt; 标题标签，最多到&lt;h6&gt;&lt;/h6&gt;，标题依次从大小&lt;p&gt;&lt;/p&gt; 段落标签，浏览器会自动已排版的格式&lt;a href="https://www.baidu.com"&gt;用了href属性&lt;/a&gt; 链接标签&lt;img src="path" width=数字 height=数字 /&gt; 插入图片的标签&lt;!--注释--&gt; 注释标签&lt;hr /&gt; 插入水平线&lt;br&gt; 换行标签&lt;b&gt; 文本加粗标签&lt;strong&gt; 文本加粗标签&lt;big&gt; 文本放大标签&lt;em&gt; 文本斜体标签&lt;small&gt; 文本缩小标签&lt;sub&gt;&lt;/sub&gt; 文本下标标签&lt;sup&gt;&lt;/sup&gt; 文本上标标签&lt;del&gt;&lt;/del&gt; 文本删除线标签&lt;ins&gt;&lt;/ins&gt; 文本下划线标签&lt;pre&gt;&lt;/pre&gt; 文本格式化标签，允许控制空行和空格&lt;a href="mailto:webmaster@example.com"&gt;Mr L&lt;/a&gt; 邮箱标签&lt;!--大坑待填--&gt; 自定义本地host windows系统下，hosts文件默认在：C:\Windows\System32\drivers\etc目录下 linux系统下，hosts文件则在 /etc/hosts 可以通过输入IP + 网址来解析 ， 如下 192.168.1.138 www.testweb.com Mysql操作 SQL对大小写不敏感，分号代表语句结束12345678910111213141516171819202122CREATE DATABASE 数据库名字; #创建数据库show databases; #查看数据库USE 数据库名字; #使用数据库DROP DATABASE 数据库名字; #删除数据库SELECT database(); #打印当前数据库名称SELECT current_user(); #打印当前登录用户名SELECT load_file(path); #打开文件----------------分割线-----------------/*创建数据表*/CREATE TABLE 表名&#123;id int(4), name char(20), sex char(20)&#125;;/*查看数据表*/show tables;/*查询数据表*/SELECT * FROM 表名; #后面可选WHERE id = 1 and name = "LY";等类似句子 /*插入数据表*/INSERT INTO 表名(name,sex) VALUES("大风烈酒孤独自由","Malo"); #id可以自增长/*更新数据*/UPDATE 表名 SET name = "LY" WHERE id = 1;/*删除数据*/DELETE FROM 表名 WHERE name = "LY";#大坑待填]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>学习</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法小记]]></title>
    <url>%2F2017%2F10%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[当刷OJ日益困难的时候 我意识到我需要自学数据结构和算法了 特开一篇小文章记录所学笔记 大坑待填]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习笔记]]></title>
    <url>%2F2017%2F10%2F04%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日常学习中难免遇到一些坑 在此记录自己学习C语言时的笔记 更新缓慢，大坑待填 在早期的C89的标准中，必须在最开始的地方定义变量，不过现在的编译器没那么严格。（VC6.0碰到的坑） %o代表八进制，八进制以0开头。 %x代表十六进制，十六进制以0x开头。 %p代表指针变量。 变量最好在定义时就初始化，否则忘记赋值直接使用会出现特别大的奇怪数值。（刷OJ的时候碰到的坑）。 单精度(float)七位有效数字，双精度(double)十六位有效数字。小数有六位，逗号算一位 转义字符参见表格。 大小写ASCII码相差32。 一旦有实数参与运算，结果也为实数。否则大多数机器采取“向零取整”的策略。 scanf中，%*3d表示读取时跳过3列。 scanf中，若scanf(“%d,%d”); 出现了逗号，则输入时也要出现逗号。 scanf中，若scanf(“%d\n”); 出现了\n，则需要多输入一个任意字符。 i++是表达式，不能参与运算。 （书上例题） 代码若需要换行，可以使用\来连接（连接符）。 else总是和它上面最近的if配对（就近原则）。 do-while结尾中的分号不能少。 指针本质是变量，也拥有地址，二级指针就是用来存储指针地址，指针可以进行值传递。 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int a = 10; int *p = &amp;a; int* *p1 = &amp;p; //这里代表生成一个二级指针，指针也是有地址的 int *p2 = p; //这个代表的是地址的传递，忽略了指针的地址的事实。 system("pause"); return 0;&#125; 设p为指针，*p++可以看作*(p++)。 设p为指针，num为数组名，p指向num。则p[3]==num[3]。 指针和数组相差：指针可以参与运算，和数组名不可以。如p++成立而num++报错。 2[p]是合法的，等同于*(2+p)。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p = num; //在这里c只是普通指针，并不称为数组指针或者指针数组。 printf("%d",*p++); //在这里是先执行p++，在执行*p. //即*(p++) p[3] == num[3]; //这是成立的，指针的下标运算 , p[2] == p+2; int b = 4; int *p1 = &amp;b; p1[2] = 13; //按道理说已经越界，但编译器未报错 //数组名和指针变量 数组名不允许自加的，且不参与运算，而指针变量可以 //数组名是一个常量 , 而 2[p] 是合法的 ,等同于 *(2+p) system("pause"); return 0;&#125; 数组地址和数组第一个元素的地址相同。 数组中一旦一个元素被初始化，其他元素都会被初始化为0。但是如果没有初始化任一元素，则所有元素都是不确定的存在，使用风险很大。 int num[][3]是成立的，但是使用的同时一定要对它进行初始化，否则必将编译失败。 有的时候我们可以使用int num[2][3] = {1,2,3,4,5,6};来初始化一个数组，编译器会将其按顺序分配到内存当中。 数组在初始化的时候，不允许使用变量初始化，必须使用常量。(C99标准支持，偶然遇见,在此记录) 1234567891011121314int a = 10;int num[a]; //这是错误写法，但是有的编译器可以编译通过 //C不允许使用这种写法，但规则是人定的。 //C++至今不允许使用，但有vector代替//若是一定要动态分配的话int n;scanf("%d" , &amp;n);int* a = (int*)malloc(sizeof(int) * n);int i = 0;for (i = 0 ; i &lt; n ; i++)&#123; scanf("%d",&amp;a[i]);&#125;free(a); 数组之中不允许使用等号直接复制，数组名是常量，不允许在赋值运算符的左侧，可是使用循环赋值或memcpy赋值。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;memory.h&gt;int main(void)&#123; int a[5] = &#123;1,2,3,4,5&#125;; int b[5] = &#123;a[4]&#125;; //可以使用这种赋值方法，将a中的元素赋值给b //错误写法： b = a; //有两种常见赋值，一种是循环，一种是memcpy复制 int i = 0; //循环赋值 for (i = 0 ; i &lt; 5; i++) &#123; b[i] = a[i]; &#125; //memcpy赋值,包含在&lt;memory.h&gt;或&lt;string.h&gt;中 memcpy(要被赋值，要赋值，赋值大小); //内存拷贝，认地址不认元素 memcpy(b,a,sizeof(int)*5); memcpy(&amp;b[0],&amp;a[0],sizeof(int)*5); return 0; //由此我们可以引申出，如果要从a[3]开始对b赋值的话 memcpy(&amp;b[0],&amp;a[3],sizeof(int)*2);&#125; 数组指针和指针数组是不同的概念 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p[5] = &#123;&amp;num[0],&amp;num[1],&amp;num[2],&amp;num[3],&amp;num[4]&#125;; //指针数组，生成五个指针分别指向num中的元素。p先和[]结合。 /*-------------------------------------------------------------*/ //要生成一个指针指向数组，通过分解可以得到 //*p1 代表指针 //int[5]代表数组 //实际理解是int[5] *p1; 但是编译器不允许通过 //根据优先级int *p1[5]，会先和中括号结合，所以需要括号将p1括起来 int (*p1)[5] = &amp;num; //数组指针 //生成一个指针，指向数组，在C语言中，数组名是第一个元素的地址，但是数组本身也存在地址。 //元素个数一定要一样，否则就是不同类型 //两者可以看成是运算符优先级的不同，[]的优先级大于*，但是()的优先级是最大的。 return 0;&#125; 如果用到了自定义函数，返回值需要注意，输出为float但使用返回值为int的函数，结果会很奇怪。（OJ碰到的大坑） 如果碰到字符串切割或者拼接问题，printf输出时需要考虑\0，否则OJ报错。（OJ大坑） 除法使用向零取整，所以当使用： 1 / 10的时候，得到的答案是0。（刷Oj遇到的方法） 用到for循环的时候，需要注意到边界问题，否则有可能会超出时间限制。（刷oj遇到的超时问题） 写for循环时，一旦不小心在末尾加上分号，则初始化的值可能出现极大的偏差。（舍友遇到的大坑） 每个字符串末尾都需要加上\0,否则使用put或printf函数时，不会终止输出，出现乱码。（同学遇到的大坑，自己刷oj也碰到过）。 自增或自减运算符不能用于常量表达式，如5++，(a+b)++ 。且方向自右向。 转化时向高精度的方向转换，即int -&gt; float -&gt; double。 字符串和数字相互转换的函数: 1234567//需要包含在头文件stdlib.hatof(str) //返回doubleatoi(str) //返回intatol(str) //返回long/*-------------------*/itoa(num,str,radix) //radix是要求转换的进制数，int转strltoa(num,str,radix) //long转str i *= k+2 ，k+2为一个整体，即 i = i * (k + 2); a &gt; b &gt; c ，从左往右比较，并用0,1替换比较结果，即如果a &gt; b，会替换成： 1 &gt; c。 字符串和字符指针的区别，参考如下代码： 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char str1[] = "Hello World"; char *str2 = "Hello World"; printf("%p\n","Hello World"); printf("%p\n",str1); printf("%p\n",str2); /*这第一个和第三个结果是相同的。 *第一个代表字符串地址 *第三个代表生成一个指针指向字符串地址 *而第二个代表新生成一片空间，与原先字符串的空间两者相独立，互不干扰，所以打印出的指针地址不同。 */ return 0;&#125; 数组作为函数参数，如下代码： 12345678910111213141516/*当数组作为参数传入时，是可以直接修改数组内容的 *即数组首地址指针被传入到函数当中。 */#include &lt;stdio.h&gt;void input(double score[]) //不需要输入元素个数&#123; //函数实现;&#125;//亦或者使用如下写法void show(double* score) //两者等同，有细微差别，涉及底层机制。int main(void)&#123; double score[10]; input(score); return 0;&#125; 八进制为0~7 十进制为0~9 十六进制为0~9,A~F，其中A为10，F为15 声明一个负数，使用%u，即无符号整数打印 先将该数绝对值以二进制的方式表达出来 再将位数所有按位取反 最后将得到的二进制加1 逆推回十进制 转义字符中，存在八进制和十六进制 \ddd 三位八进制 不能超过三位，且数字为0-7 \xhh 二位十六进制 不能超过两位 十进制转二进制，一般采用除2取余法，直到商为0，得到的余数从最尾巴倒着排回去 转其他进制同样也可以采用除数取余法 其他进制转十进制，可以将数字展开，一次乘以各个数字的次方 二进制转八进制，从后往前，三位一组，不够用0补，然后以十进制方法转化，如(11001.101)2，其中001代表1，011代表3，所以这个数值就是31。 同理八进制转二进制也可以直接将每一位展开 二进制转十六进制，以四位为一段，如（11111101）2，从1111得出F，1101得出D，所以值是FD。 关于自增自减运算符的深入剖析（参考网络上的资料） 在不同编译器中，这个结果可能出现不同。 123456789101112int i = 3;int j = 4;int a = i++ + i++;int b = ++j + ++j;printf("%d, %d\n", a, b);/** *这个答案在VC6.0里面为6，12 *但是在vs2017里面测试确为7，12 *以以上的例子来说 *i++的理解应该是执行完整个表达式的其他操作后，然后才自增 *++j的理解为先自增再参与其他运算 */ 再看另一组代码 12345678910111213int i = 3;int j = 4;int a = i++ + i++ + i++;int b = ++j + ++j + ++j;printf("%d, %d\n", a, b);/** *这组结果为9，19 *vs2017中为12，19 *按上一组的理解，这一组应该为21 *但是这一组存在两个同级+运算 *根据+的左结合性，式子可看成(++j + ++j) + ++j; *即 (6 + 6) + 7; */ 最后一组代码 123456789101112int i=1;int j=1;int a = i++ + i++ + i++ + i++ + i++ + i++ + i++; // 七个int b = ++j + ++j + ++j + ++j + ++j + ++j + ++j;printf("%d, %d\n", a, b);printf("%d, %d\n", i, j); /** *a = 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7 *b = 3 + 3 + 4 + 5 + 6 + 7 + 8 = 36 *总的来说，后置++比较好看出来，前置++需要注意运算符的优先级 *如果非应试教育，应当尽量不使用这种式子，造成误解 */ 当碰到：a += a = a -= a = 3这类式子时，应从右往左一次计算，如下： 1234a *= 3;a = a - a;//......//此后不再叙述 使用extern声明全局变量的时候，可以扩大变量的作用域。如在其他文件中存在一个整形变量a，在本文件中可以使用extern int a来申明全局变量，类型名可写可不写，如使用extern a 使用static声明全局变量时，只能用于本文件，即便在其他文件中使用了extern这个关键字，也无法调用，那一行只能调用一次，不可重复调用，所以声明时最好就一同初始化，static 函数也同理 找到字符串结束符 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char *str = "hello world"; int i = 0; while (str[i] != '\0') &#123; i++; &#125; return 0;&#125; 注释不允许嵌套（练习大坑） ++允许使用在float上面，但是%必须是两个整型 原码：符号位加上真值的绝对值，即第一位是符号，其余位为值。符号位1代表符号，0代表正号 反码：整数的反码是本身。负数是在原码的基础上，符号位不变，其他位取反 补码：正数的补码是本身。负数的补码是在原码的基础上，符号位不变，其他位取反，最后+1。（即反码+1） 在使用&amp;&amp;进行判断时，如果前面为假，则代表短路，不再执行后面的语句。（习题大坑） 逻辑与运算符优先级大于逻辑或 逻辑运算问题，查看如下代码： 123456789101112#include &lt;stdio.h&gt;int main(void)&#123; int a = 1; int b = 1; int c = 1; ++a || ++b &amp;&amp; ++c; printf("a = %d , b = %d, c = %d\n", a, b, c); return 0;&#125; 运算符高是表示: ++a || (++b &amp;&amp; ++c)，但是运算顺序依旧从左往右 举四则运算的例子： 1 + (2 * 3) 而不是 ( 1 + 2 ) * 3 但他们是从左往右运算，即就从+而言，它先算1 所以回归问题，先演算++a，于是||出现短路 函数允许返回一个指针，例如 1234int * getaddress(int x)&#123; return &amp;x;&#125; 函数名即为地址，所以有函数指针这个说法，具体实现如下： 12345678910111213141516171819202122int max(int x,int y)&#123; if ( x &gt;= y) &#123; return x; &#125; else &#123; return y; &#125;&#125;int main(void)&#123; int a , b ,c; int (*p)(int , int); p = max; //代表p指向max scanf("%d %d", &amp;a, &amp;b); c = (*p)(a,b); printf("\n a = %d , b = %d , max = %d",a,b,c); return 0;&#125; int (*函数指针)(参数列表); 对指向函数的指针变量，进行运算，如p++,p–是毫无意义的事情 结构体类型定义的时候并不分配内存空间，只有申明变量的时候才分配内存。 结构体里面允许嵌套结构体，使用.（成员运算符）来逐级访问。 共用体的大小取决于最长成员所占用的存储空间，而结构体则是所有成员之和。如下例子 12345678union data&#123; int a; float b; double c; char d;&#125;obj;//这个data所占的空间为double所占的8字节。、 不能同时引用两个或两个以上的共用体成员，否则出错。 枚举序号默认从0开始排列，但是也可以初始化，不允许后面复制。 大坑待填]]></content>
      <categories>
        <category>C语言记录</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的初步体验]]></title>
    <url>%2F2017%2F09%2F17%2FGit%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[初步了解Git的使用，在此做下笔记。 涉及Git安装配置，创建版本库以及其他多方面内容，防止自己遗忘。 Git的安装 安装过程极度简单，不做记录。 Git的账号配置12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot; git conifg命令中的–global参数，用了这个参数，表示这台机器所有用户都会使用这个配置，也可以不添加。创建版本库 选择合适地方创建空目录 在当前目录下使用如下代码来初始化仓库。1git init 可以观察到当前目录下生成了 .git 的文件夹,如果没有特殊情况，最好不要修改这个目录。添加文件 一般情况下，不要使用windows自带的记事本去编辑文件，容易出各种奇怪的错误。 使用如下代码添加文件 1git add 文件名 使用如下代码提交到仓库 1git commit -m &quot;注释&quot; -m 后面为修改的注释，一般情况下最好添加，也方便自己以后查看修改记录。 commit可以一次提交多个文件，所以最好 add多个文件后，使用commit提交。 查看状态 使用如下代码查看当前状态：1git status 这条命令可以让我们掌握仓库的状态，产看那些文件已经更改过了。 使用如下代码查看详细状态1git diff HEAD --文件名 此条命令可以让我们查询到文件做了哪些更改。 需要注意的是这是对比工作区和缓存区的差别，所以需要先使用add提交。 查看日志 使用如下代码查看文件修改过的日志1git log 可以加上 –pretty=oneline,出现的是commit的版本号，有 Head的那一行为最新修改的版本。 查看文件历史变动的内容 有的时候我们需要回看文件修改的内容，可以使用12git log --pretty=oneline #获取文件的哈希值git show 哈希值 版本回退 使用如下代码回退版本123git reset --hard HEAD^#亦或者使用git reset --hard 回退后的id 注意,在windows平台中的cmd下，符号 ^应当使用双引号括起来，它是特殊字符，否则会出现 More? 的现象。 上一个版本是 HEAD^，上上个版本则是 HEAD^^ ，以此类推。 当版本数过多的时候，使用^容易数不过来，可以使用 HEAD~100 来回退版本。 如果不小心回退错误，可以使用: git reset –hard 版本号来回退版本。 只需写版本号前几位即可，系统会进行自动查找。 获取回退后的ID 使用如下代码1git reflog 这条命令可以显示你之前输入的所有命令，以此来获得 commit id。 这条命令用于记录输入过的命令。 跟踪修改 git跟踪的是修改内容而非文件本身，如果不使用 add将文件添加至暂存区， commit只会提交暂存区的内容，所以文件不会发生改变。丢弃修改未使用 add前 提交前,使用如下代码，可以丢弃工作区的修改：1git chekout -- 文件名 可以撤销修改 此处中的 – 十分重要，缺少其中一个则可能编程另外一个命令。使用了 add后 提交后，我们可以使用如下命令，来讲暂存区的修改回退为工作区：1git reset HEAD 文件名 删除文件一般情况下 一般情况下，直接将文件删除，这时可以使用如下代码，来查看状态：1git status 这时Git知道我们删除了文件，工作区和版本库不一致，我们可以使用如下代码，来完成删除并提交：12git rm 文件名git commit -m &quot;删除注释&quot; 误删的情况 如果是误删了文件，我们可以使用如下代码来恢复文件：1git checkout -- 文件名 git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 恢复只能恢复到 最近一次 提交的内容。 创建远程仓库 首先先观察在系统盘用户目录下是否存在 .ssh 的文件夹,并观察是否有id_rsa和id_rsa.pub这两个文件。 如果不存在说明没有密钥，使用如下代码创建密钥： 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 并在github里面添加id_rsa.pub这个文件中的密钥。 添加远程库 首先在Github上面使用 New repository 创建新的仓库。 接下来使用如下代码来关联仓库:1git remote add origin git@github.com:fjlyx97/TestRespository.git 注意其中的名字变换，远程库的名字就是origin，Git的默认叫法。 使用如下代码来将本地库的内容推送到远程库上：1git push -u origin master 第一次可以使用 -u的参数，可以将本地的master分支内容推送的远程新的master分支。 以后可以使用 git push origin master来直接推送。 可以使用如下代码来查看当前有的远程库1git remote 从远程库克隆 从零开始时最好先创建远程库，并使用如下代码：1git clone 地址 从远程仓库同步到本地仓库 当使用多台电脑编辑文件时，我们需要将远程仓库同步到本地仓库。1git pull 创建合并分支 我们可以使用如下代码来创建分支 1234git checkout -b 分支名 //创建分支并切换//等同于git branch 分支名git checkout 分支名 //切换分支 可以使用如下命令查看分支 1git branch 合并分支 1git merge 分支名 删除分支 1git branch -d 分支名 创建忽略文件 有的时候我们并不想所有文件都被同步到仓库中，所以我们可以通过创建一个 .gitignore 文件。 github为我们准备了模板，可以点击：gitignore模板 文件中以 # 开头的为注释，而 * 为通配符。 这个方法针对未被提交的文件，如果文件已经被提交的话，需要输入如下代码: git rm -r –cached . git add . git commit -m “注释” 大坑待填]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[霞浦一中2017届高三十班]]></title>
    <url>%2F2017%2F09%2F10%2F%E9%9C%9E%E4%B8%AD%E9%AB%98%E4%B8%89%E5%8D%81%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[我有一个梦想，就是完成一部可以保存一生的视频前言 晃晃悠悠，终于做完了毕业MV，也算完成了一部可以存一生的视频，给自己的高中生涯画上了一个圆满的句号。很感谢各方同学的支持，提供了好多素材给我们，让我们得以成功完成回忆同学的部分。同时也很感谢导演苏锦钰同学的认真态度，为了录制老师的最后一课，多次在学校以及老师家里来回奔波。从素材的收集到视频的录制，以及最后视频的完成。来来回回也耗时了三个月，诸多不易，但所幸，我们最终坚持了下来，最终在9月10号这一天，我们将它发布了出来。在此欢迎各位老师同学捧场，霞中高三十班制作组，倾情献上。 毕业MV制作人员 总导演，摄影师：苏锦钰 监制，后期处理：梁煜鑫 摄影助理：连凯琦 背景音乐《不说再见》演唱人员:林心烨，陈丽清，邓恬悦 特别鸣谢：梁柠，郑洋帆，谢凌巍，郑铭 背景音乐 new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 0, music: { title: "不说再见", author: "陈丽清，林心烨，邓恬悦", url: "http://ovsp71cnj.bkt.clouddn.com/%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90.mp3", pic: "autoplay=false", } }); 毕业视频通过手机观看的用户注意一下，请手机用户通过以下链接观看。霞浦一中2017届高三十班毕业MV 结语 故事的开头总是这样，适逢其会、猝不及防。我们相信这个世界四通八达，却很少抵达某个最真实的地方。后来的后来……一别一聚、一絮一语。从前赋予我们七零八散的往事及可爱的人。但故事的结尾总是这样，花开两朵、天各一方。山高水阔，来日方长。愿此去前程似锦，再相逢依旧如故。愿你走出半生，归来仍是少年。 敲黑板！！！ 零经费剧组经历3个月的创作，付出了许许多多的时间，精力，甚至财力。望各位看官看完之际，觉得视频不错的，就按下方Donate打赏点钱。打赏的钱我会分给全体剧组人员，犒劳下这三个月的辛苦。我谨代表全体剧组人员感激不尽！]]></content>
      <categories>
        <category>爱生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>霞浦一中</tag>
        <tag>生活</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python + selenium实现浏览器自动登录]]></title>
    <url>%2F2017%2F08%2F28%2F%E4%BD%BF%E7%94%A8python-%2B-selenium%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[使用python + selenium实现浏览器自动登录 python版本为3.6.2 系统为windows10 记录自己学习的心得，也是为了防止以后时间久了自己也遗忘了 1.安装selinium 安装的过程十分简单，只需要使用pip安装即可1pip install selenium 2.安装对应的webdriver（驱动）本文以edge浏览器为例子百度edge webdriver，搜索完第一个就是微软的官网了。这里附上链接:WebDriver如下图：选择对应的版本,这里十分重要!!版本可以通过windows的运行快速查看1dxdiag 如下图： 下载完毕之后，将MicrosoftWebDriver.exe复制到python安装目录下的scripts文件夹里面。至此安装环境配置完毕，开始实战。 3.实战 首先在python中导入selenium的webdriver的库from selenium import webdriver 实例化出一个浏览器browser = webdriver.Edge() 打开网址需要使用get方法，我们在这里以小米官网为例子browser.get(&quot;https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180&quot;)我们可以试着运行代码，可以看到浏览器已经自动打开小米官网了 获取元素元素的方法有很多种： find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 在这方面网上有很多资料首先我们要定位到一个元素，在这里我们可以用浏览器自带的工具右键登录按钮，点击检查元素，如图： 我们就可以定位到元素了 可以查看到他有着name属性，id属性定位元素的方法多种多样，没有规定一定要用哪一种，适合即可。123name = browser.find_element_by_name("user")#亦或者name = browser.find_element_by_id("username") 于是乎，我们已经定位到账号的输入框了。接下来是输入内容，输入内容可以使用send_keys的方法name.send_keys(&quot;hello&quot;)运行试试看，我们会发现已经成功在输入框中输入我们所要的内容。 同理我们可以定位到密码框passwd = browser.find_element_by_name(&quot;pwd&quot;) 以及往里面填充内容passwd.send_keys(&quot;hello&quot;)如下图所示： 输入完账号密码，最后一步便是点击登录按钮了 12login_button = browser.find_element_by_id("login-button")login_button.click() 运行试试，我们可以看到已经登录过了，当然账号密码是随便输入的。 最后附上代码：123456789101112from selenium import webdriverimport timebrowser = webdriver.Edge()browser.get("https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180")time.sleep(2)name = browser.find_element_by_name("user")name.send_keys("账号")passwd = browser.find_element_by_name("pwd")passwd.send_keys("密码")login_button = browser.find_element_by_id("login-button")login_button.click() 4.其它定位xpath定位 通常情况下，我们不一定能通过name或id定位,这时候我们可以用其它方法，通过xpath就是一种不错的选择，这里以百度的输入框为例。xpath可以通过谷歌浏览器或者其它浏览器直接查看，如图： 单击后即可复制,如下//*[@id=&quot;kw&quot;] 我们可以使用它path = browser.find_element_by_xpath(&quot;//*[@id=&#39;kw&#39;]&quot;) 记得将里面的双隐号改成单隐号，否则报错。可以试试是否定位到了path.send_keys(&quot;hello&quot;) 使用elements定位很多时候元素定位都很模糊，要定位到并不是十分容易，我们可以换个思路，同时定位一组元素，通过取下标的方法，读取元素，以百度的首页为例： 通过查看元素我们可以发现： 上面一组元素具有许多相同的特征，于是我们可以使用如下代码：123elements = browser.find_elements("css selector" , ".mnav")#或是elements = browser.find_elements_by_css_selector(".mnav") 两个定位是相同的，不过写法不同而已，这个方法和之前的区别主要就是find_elements，使用的是复数定位，最后通过下标来选择元素。1elements[0].click() 这样便是点击第一个元素，也就是新闻的按钮。附上测试代码: 5.终 selenium的资料网上很多，遇到问题善用搜索引擎，一般问题都可以得到解决。 大坑这里要特别说明一点，在测试时，浏览器的缩放比例不能调，不能调，不能调。这真的是一个大坑，我当时电脑的缩放比例是125%,定位元素始终不能成功，一直会提示：困扰了我好久，查阅好多资料始终不得解，偶然之下将缩放比例调回100%，终于解决这个问题，这也是我目前遇到最大的坑，在此特别记录，以防自己以后忘记。 最后附上我学习时的参考资料： Selenium2+python自动化45-18种定位方法Python爬虫利器五之Selenium的用法]]></content>
      <categories>
        <category>python记录</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
