<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[趣谈网络协议笔记]]></title>
    <url>%2F2019%2F01%2F23%2F%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[根据极课时间课程趣谈网络协议所作的笔记 记录网络协议的相关知识 要讲解的网络协议从底层到上层进行讲述 应用层：DHCP HTTP HTTPS RTMP P2P DNS GTP RPC 传输层：UDP TCP 网络层：ICMP IP OSPF BGP IPSec GRE 链路层：ARP VLAN STP 物理层：网络跳线 网络分层的真实含义 只要是网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层 理解网络协议的工作模式，可以始终想象自己是以后个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去 ifconfig:最熟悉又陌生的命令行首先记录两个常用命令 ipconfig(windows) / ifconfig(linux) ipaddr(linux) ip地址是一个网卡在网络世界的通讯地址，相当于我们世界的门牌号码，而MAC地址更像是身份证，是一个唯一的标识，因此希望记住以下几点： ip是地址，有定位功能；MAC是身份证，无定位功能； CIDR（无类型域间选路），可以用来判断是否为本地人。它将32位IP地址一分为二，前面为网络号，后面为主机号，如下： 110.100.122.2/24 //IP间有一个/，斜杠后面的24为32位中，前24位为网络号，后8位位主机号 ip分为公有ip以及私有ip。 DHCP与PXE:IP是怎么来的，又是怎么没的 DHCP协议主要用来给客户租用IP地址，和房产中介很想，要商谈，签约，续租，广播，还不能“抢单” DHCP协议能给客户推荐“装修队”PXE，能够安装操作系统，在云计算领域大有用处 从物理层到MAC层：如何在宿舍里自己组网玩联机游戏 MAC层是用来解决多路访问的堵车问题（交换机记录MAC，确定唯一地址，可以防止数据包多次转发，造成浪费） ARP是通过吼的方式来寻找目标MAC地址的，吼完之后要记住一段时间，被称为缓存 交换机是有MAC地址学习能力的，学完了它就知道谁在哪了，不用广播了 交换机与VLAN：办公室太复杂，我要回学校 当交换机数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用STP协议，通过华山论剑比武的方式（比较BPDU网络协议数据单元），将有环路的图变为没有环路的树，从而解决环路问题。 交换机数目多会面临隔离问题，可以通过VLAN形成虚拟局域网，从而解决广播问题和安全问题 ICPM和ping：投石问路的侦察兵 ICMP相当于网络世界的侦察兵。有多种类型的报文，如主动探查的查询报文，异常报告的差错报文 ping使用查询报文，Traceroute使用差错报文 世界这么大，我想出网关：欧洲十国游与玄奘西行 如果离开本局域网，就需要经过网关，网关是路由器的一个端口 路由器是一个三层设备，里面有如何寻找下一跳的规则 经过路由器之后MAC的头要变，如果IP不变，相当于不换护照的欧洲旅游，如果IP变，相当于换护照的玄奘西行]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中c++架构实战（二）]]></title>
    <url>%2F2019%2F01%2F22%2Flinux%E4%B8%ADc%2B%2B%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[linux c++架构实战系列课程笔记（二） 服务器框架初步 服务器框架初步目录结构规划123456789101112- nginx：主目录- _include目录： 专门存放各种头文件- app目录： 放主应用程序.c，如main函数以及比较核心的目录. link_obj：临时目录，存放临时的.o文件，不手工创建，后续使用makefile脚本创建 dep:临时目录，会存放临时的.d开头的依赖文件，依赖文件能告知系统那些相关的文件发生变化，需要重新编译 nginx.c：主文件，main()入口函数 ngx_conf.c，普通源码文件- misc目录：专门存放杂合性不好归类的C文件- net目录：专门存放和网络处理相关的文件- proc目录：专门存放和进程处理有关的多个文件- signal目录：专门用于存放有关信号处理的文件 ngx_signal.c Makefile编写 makefile:编译项目的入口脚本，起到总体控制 config.mk：配置脚本，应付一些可变的东西 common.mk 最核心的编译脚本，定义makefile的编译规则，依赖规则等，通用性很强，各个子目录中都用到这个脚本 基础配置读取使用配置文件，使我们的服务器程序有了极大的灵活性，使我们作为服务器程序开发者必须首先搞定的问题 配置文件：文本文件，里边除了注释行之外不要用中文，只在配置文件中使用字母，数字，下划线。以#开头的为注释行（注释行可以有中文）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux</tag>
        <tag>c家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式基础]]></title>
    <url>%2F2019%2F01%2F17%2Fcss%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[网页设计一直不大美观 尝试通过视频课程学习CSS 涉及CSS基础样式，选择器 常用标签归类 盒子模型 定位技术 引入CSS注释1/* */ 行间样式 使用style属性进行引入1234&lt;div style=" width:100px; height:100px;"&lt;/div&gt; 页面级CSS 使用style标签12345&lt;style type="text/css"&gt; div &#123; height: 100px; &#125;&lt;/style&gt; 引入外部CSS 使用link标签1&lt;link rel="stylesheet" href=""&gt; 选择器id选择器在头标签使用标签取名 html 1&lt;div id="only"&gt;123&lt;/div&gt; css 123#only &#123; background-color: green;&#125; 一个元素只能有一个ID值，一一对应 class选择器与id选择器不同的是，一个class可以对应多个元素 html 1&lt;div class="demo"&gt;cssdemo&lt;/div&gt; css 123.demo&#123; background-color: green;&#125; 标签选择器所有的标签都可以选择，如下： css123div&#123; background-color: green;&#125; 通配符选择器全选所有的标签，如下： css123* &#123; font-size: 100px;&#125; 属性选择器如果拥有这个属性，则可以全部选出来 css123456[id] &#123; font-size: 100px;&#125;[id="only"] &#123; font-size: 100px;&#125; 优先级选择器!important &gt; 行间样式 &gt; id &gt; class || 属性选择器 &gt; 标签选择器 &gt; 通配符 class 和 属性选择器，按先后顺序来确定 复杂选择器css权重1234561. important Infinity2. 行间样式 10003. id 1004. class|属性|伪类 105. 标签|伪元素 16. 通配符 0 数值为256进制，举例行间样式如下:121 0 0 00-255 0-255 0-255 0-255 如果所有选择器写在了同一行，则将他们的权重相加，进行判定 父子选择器/派生选择器 html 123&lt;div id="only"&gt; &lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; css 123div span&#123; font-size: 20px;&#125; 既然是父子选择器，则父亲下所有的子类都可以被覆盖 不一定非要使用标签选择器，同样可以用其他选择来替代 浏览器底层为自右向左遍历 直接子元素选择器不同于父子选择器，这代表父级下直接的子元素 html 123&lt;div id="only"&gt; &lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; css 123div &gt; span&#123; font-size: 20px;&#125; 并列选择器中间不允许加空格，且顺序不能引起歧义 html 123&lt;div&gt;1&lt;/div&gt;&lt;div class="demo"&gt;2&lt;/div&gt;&lt;p class="demo"&gt;3&lt;/p&gt; css 123div.demo&#123; font-size: 20px;&#125; 分组选择器将所有东西分为一组，以逗号分隔 css12345em,strong,span&#123; font-size: 30px;&#125; css基本属性 border:1px solid black; 边框粗细 属性 颜色，对应border-width border-style border-color，同样可是用border-left或其他指定位置设置 文本属性12345text-align: center; 文字对齐方式text-indent: 2em; 文字缩进，em为文本距离，1em=1*font-sizetext-decoration: line-through; 文本装饰，等效&lt;del&gt;line-height: 16px; 单行文本高度，类比word的行距cursor: pointer; 设置鼠标指到的光标样式 设置单行文本垂直居中，通用手法为文本高度等于容器高度，即line-height == height，还有其他方法为：padding 字体属性12345font-size : 30px; 字体大小，设置字体高度font-weight : bold; 设置字体属性，如加粗font-style : italic; 设置字体样式font-family: arial; 设置字体，如微软雅黑color: red; 设置字体颜色 字体颜色有三种格式，纯英文单词，颜色代码，颜色函数。颜色代码如：#ff44ff，每两位代表一个颜色，分别代表rgb,范围从00-ff，或使用rgb(0-255,0-255,0-255) 伪类选择器先选中标签，加上冒号，如下为伪类选择器之一123a:hover &#123; background-color: orange;&#125; 标签归类拥有隐式属性display 行级元素 inline特性 内容决定元素所占位置 不可以通过CSS改变宽高常用行级元素 span strong em a del 块级元素 block特性 独占一行 可以通过CSS改变宽高常用块级元素 div p ul li ol form address 行级块元素 inline-block特性 内容决定大小 可以改变宽高常用行级块元素 img ，在修改宽高时，可以只设置其中一个，会自动等比例缩放，如果两个都修改的话有可能会出现比例失衡 凡是带有inline的元素，都有文字特性，如下例子：12345&lt;img src="1.jpg"&gt;&lt;img src="1.jpg"&gt;&lt;img src="1.jpg"&gt;&lt;img src="1.jpg"&gt;&lt;!-- 四张图片出现缝隙 --&gt; 盒子模型盒子模型分为四大部分 外边距 margin 1body拥有默认的margin，为8像素，所以常使用通配符选择器进行初始化 盒子壁 border 内边距 padding 12345678910padding: 100px 100px 100px 100px 上 右 下 左padding: 100px 100px 100px 上 左右 下padding: 100px 100px 上下 左右padding: 100px四个方向其余同理 盒子内容 width+height 定位技术样式中拥有一个参数为position，且拥有left,right,top,bottom可以与之相配合，使用z-index设置位于层数 left和right不能同时出现，分别为左边线距离和边线距离 绝对定位使用absolute，进行绝对定位。会脱离原来的层，跑到上一层，因此下一个元素会覆盖之前的位置 相对于最近的有定位的父级进行定位，如果寻找不到，相对于Document进行定位 相对定位使用relative，进行相对定位。保留原来位置进行定位，即下一个位置无法覆盖之前的位置。 相对于自己的出生位置进行定位 固定定位使用fixed，进行固定定位，不管怎么移动始终在同个位置 居中样例如下css:12345div&#123; position: absolute; left: 50%; height: 50%;&#125; relative常用于支架而absolute常用于移动元素 两个经典BUG第一个BUG（margin塌陷）当子集元素使用margin-top时，无法下移，只有大于父亲的marginn-top时，才能将整体下移 垂直方向的margin，会粘合到一起，取最大的值解决方案第一个解决方案可以通过在父级元素添加border-top:1px solid red;进行修复（不推荐）第二个解决方案触发一个盒子的BFC position:absolute; display:inline-block; float:left/right; overflow:hidden; //溢出部分隐藏 第二个BUG（margin合并）当两个元素，一个元素使用margin-bottom:100px，另外一个元素使用margin-top:200px，他们的真实距离不是300，而是取最大值，但是这种BUG通常不会使用BFC进行修复，我们默认他们是存在的，而是通过计算像素的方法进行手动修复 浮动模型float 元素仅仅具有两个选项：left以及right，作用为元素站队，中间同样可以加其他元素 html如下 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;first html&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="stylesheet" type="text/css" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="content"&gt;1&lt;/div&gt; &lt;div class="content"&gt;2&lt;/div&gt; &lt;div class="content"&gt;3&lt;/div&gt; &lt;div class="content"&gt;4&lt;/div&gt; &lt;div class="content"&gt;5&lt;/div&gt; &lt;div class="content"&gt;6&lt;/div&gt; &lt;div class="content"&gt;7&lt;/div&gt; &lt;div class="content"&gt;8&lt;/div&gt; &lt;div class="content"&gt;9&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt; css如下 1234567891011121314151617* &#123; margin: 0; border: 0;&#125;.wrapper&#123; width: 300px; height: 300px; border: 1px solid black;&#125;.content&#123; float: left; width: 100px; height: 100px; background-color: green;&#125; 原理浮动元素产生了浮动流，所有产生了浮动流的元素，块级元素看不到他们，产生了BFC的元素和文本类属性的元素以及文本都能看到浮动元素 清除浮动流使用 clear:both即可以清除浮动流 伪元素一个元素出生的时候就具有伪元素，如下代码： html 123&lt;span&gt; very good!&lt;/span&gt; css 12345678span::before&#123; Hi&#125;span::after&#123; content:""; display:block; clear:both;&#125; 伪元素可以被CSS正常操作，但是不能作为结构。且伪元素天生是行级元素，可以通过修改display进行修改。因此可以通过在伪元素添加clear让最后的元素可以看到浮动元素，因此块级元素可以自适应 凡是涉及了positon:abolute，float:left/right，打内部把元素转换成inline-block 文字溢出处理单行文本 先让文本失去换行功能，white-space:nowrap; 设置溢出部分隐藏，overflow:hidden; 设置溢出部分用点号，text-overflow: ellipsis; 多行文本由于浏览器版本不齐，因此常将文字直接传入后台，进行截断处理，手动添加… 背景图片处理使用div时，允许添加背景图片 css123456.logo &#123; width: 100px; height: 100px; background-image: url('./1.jpg'); background-repeat: no-repeat;&#125; 图片代替文字第一种解决方案当网速低的时候，浏览器使用默认加载策略，禁用JavaScript以及CSS，这样如果没做特殊处理，图片挂掉后就不能点击链接。因此我们可以使用以下代码来隐藏链接文字： text-indent:容器宽度， white-space: nowrap; overflow: hidden;第二种解决方案容器高度设置为0，padding-top设置为图片高度，使用overflow:hidden来隐藏文字 规定 p标签不能嵌套div元素 a标签不能嵌套a标签]]></content>
      <categories>
        <category>网页设计</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>网页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中c++架构实战（一）]]></title>
    <url>%2F2018%2F12%2F28%2Flinux%E4%B8%ADc%2B%2B%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[linux c++架构实战系列课程笔记（一） 涉及nginx开发初步 终端进程的基本概念 信号的基本概念 fork函数，僵尸进程，守护进程 nginx目录结构123456789101112nginx-1.14.2├── auto //一些自动化脚本├── CHANGES //版本更新说明├── CHANGES.ru //俄语版本更新说明├── conf //默认配置文件目录├── configure //编译nginx之前必须先执行的脚本文件├── contrib //脚本和工具，如VIM高亮├── html //存放两个起始界面的html文件├── LICENSE //许可证├── man //包含man手册，可以直接使用man调用├── README //说明文件└── src //源文件 auto目录12345auto├── cc //检查编译器脚本├── lib //检查依赖库脚本├── os //检查操作系统类型的脚本├── types //检查平台类型的脚本 src目录12345678src├── core //核心代码├── event //事件模块相关代码├── http //http(web)服务相关代码├── mail //邮件相关代码├── misc //辅助代码，测试C++头文件兼容性├── os //操作系统相关代码└── stream //流处理相关代码 编译nginx一、安装依赖 nginx内核版本2.6以上 gcc编译器 pcre函数库，用以支持正则表达式 zlib库，解压缩功能 openssl库，ssl相关功能库1apt install build-essential libpcre3-dev libz-dev libssl-dev 二、用configure进行配置安装 –prefix:指定最终安装到的目录，默认为：/usr/local/nginx（父目录） –sbin-path 指定可执行文件目录，为prefix的子目录，默认为：sbin/nginx –conf-path 指定配置文件目录，为prefix的子目录，默认为：conf/nginx.conf –with为缺省不编译，–without为缺省编译123./configure //直接缺省配置makemake install 三、nginx的启动和简单使用12cd /usr/local/nginx/sbin./nginx nginx整体结构ps -ef简要说明 第一列：UID 进程所属用户ID 第二列：进程ID（PID），用来唯一的标识一个进程 第三列：父进程ID（GPID），被fork创建出来的子进程 nginx进程模型一个master有一到多个worker进程，这种工作机制是对外服务的。这种工作机制保证了nginx能够稳定灵活的运行 master进程责任：监控进程，本身不处理业务，监控worker进程 worker进程责任：用来干主要的活，处理用户业务 master进程和用户进程通讯，可以用信号，或者是共享内存 稳定性：workder进程一旦挂掉，master进程会立刻fork一个新进程投入到工作中去 调整worker进程数量公认的做法：多核计算机，让每个worker运行在一个单独的核上，最大限度减少CPU切换成本，提高稳定性1lscpu //查看CPU数据 在nginx目录下的conf文件夹中，修改nginx.conf配置文件，修改worker_process 终端和进程的关系终端与bash进程使用如下命令查看bash1ps -ef | grep bash 可以观察到拥有pts/0，pts代表虚拟终端，/后面为编号 每个进程还属于一个进程组，一个或者多个进程的集合，每个进程组拥有一个唯一的进程ID，可以使用系统函数来调用或者加入进程组（PGRP） 会话（session）是一个或者多个进程组的集合，而这个会话有一个session leader，那么这个bash（shell）通常就是session leader。但是可以调用系统函数调用新session strace工具的使用1sudo strace -e trace=signal -p 进程id 忽略SIGHUP信号使用signal.h进行忽略信号引入头文件signal.h，使用对应的signal函数进行忽略信号1234567891011121314#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;using namespace std;int main()&#123; signal(SIGHUP,SIG_IGN); //系统函数，告诉操作系统忽略SIGHUP信号，不要杀死进程 for (;;) &#123; sleep(1); cout &lt;&lt; "Sleep 1 sec" &lt;&lt; endl; &#125; return 0;&#125; 一旦程序允许，退出终端，程序tty变为？且ppid变为1（祖宗节点），被称为孤儿进程 setsidsetsid函数setsid不适合进程组组长调用，程序退出时，bash会往相同的Session里面发送SIGHUP信号，因此可以使用fork函数进行创建进程1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; pid_t pid; pid = fork(); //出现子进程 if (pid &lt; 0)&#123; cout &lt;&lt; "Fork Error" &lt;&lt; endl; &#125; else if (pid == 0)&#123; cout &lt;&lt; "Son" &lt;&lt; endl; setsid(); //新建独立的session，但进程组组长调用setsid时无效的 for (;;) &#123; sleep(1); cout &lt;&lt; "Sleep 1 sec" &lt;&lt; endl; &#125; return 0; &#125; else&#123; cout &lt;&lt; "Father" &lt;&lt; endl; //pid&gt;0 return 0; &#125; return 0;&#125; setsid命令启动一个进程，而且能够使其在新的session中，终端退出不退出1setsid ./可执行程序 nohup命令1nohup ./可执行程序 &amp; 信号的基本概念进程之间的常用通信手段：发送信号,kill 信号：通知（事件通知）用来通知某个进程发生了某个事情 名字一般以SIG开头 信号既有名字，也是一些正整数常量（宏定义），需要包含signal.h头文件，在/usr/include 信号的产生 由某个进程发送给另外一个进程或发送给自己 由内核（操作系统）发送给某个进程 kill命令kill工作是发个信号给进程，可以发送多种信号 kill -数字 进程id //能发出这个数字对应的信号，可以通过查看头文件获取定义 Unix/Linux操作系统体系结构类Unix操作系统体系结构分为两个状态 （1）用户态 （2）内核态 signal函数信号来了之后，我们可以选择进行捕捉或者忽略，signal第一个参数为要捕捉的信号，第二个参数指定函数名，代表捕捉到信号后要执行的函数 可重入函数在信号处理函数当中，调用它的安全的。这些函数可重入，被称为异步信号安全。 有一些周知的函数都是不可重入的，如malloc、printf等 处理函数注意事项 在信号处理的函数当中，尽量做简单的事情，尽量不要调用系统函数避免引起麻烦 如果一定要调用系统函数，调用可重入的系统函数，或异步信号安全的函数（有表可查） 如果一定要调用可能修改errno的值的可重入系统函数，那么必须备份errno的值，并调用结束之后进行恢复 一旦在信号处理中使用了不可重入函数，将会导致程序错乱（绝对不能犯！！） signal因为兼容性，历史原因，官方不建议使用，建议使用sigaction函数代替 信号集一个进程，必须能够记住这个进程当前阻塞了哪些信号，linux中用sigset_t结构类型来表示信号集，一个进程对应一个信号集 信号相关函数 sigemtpyset()把信号集中的所有信号清零，表示这60多个信号都没有出现 sigfillset()把信号集中所有信号设置为1，跟sigemptyset()相反 用sigaddset()，sigdelset()就可以往信号集中增加信号，或者从信号集中删除指定信号 sigprocmask(),sigismember()。sigprocmask()函数能够设置该进程对应的信号集中的内容，sigismember测试信号是否被屏蔽（为1）样例代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //malloc#include &lt;unistd.h&gt;#include &lt;signal.h&gt;//信号处理函数void sig_quit(int signo)&#123; printf("收到了SIGQUIT信号!\n"); if(signal(SIGQUIT,SIG_DFL) == SIG_ERR) &#123; printf("无法为SIGQUIT信号设置缺省处理(终止进程)!\n"); exit(1); &#125;&#125;int main(int argc, char *const *argv)&#123; sigset_t newmask,oldmask; //信号集，新的信号集，原有的信号集，挂起的信号集 if(signal(SIGQUIT,sig_quit) == SIG_ERR) //注册信号对应的信号处理函数,"ctrl+\" &#123; printf("无法捕捉SIGQUIT信号!\n"); exit(1); //退出程序，参数是错误代码，0表示正常退出，非0表示错误，但具体什么错误，没有特别规定，这个错误代码一般也用不到，先不管他； &#125; sigemptyset(&amp;newmask); //newmask信号集中所有信号都清0（表示这些信号都没有来）； sigaddset(&amp;newmask,SIGQUIT); //设置newmask信号集中的SIGQUIT信号位为1，说白了，再来SIGQUIT信号时，进程就收不到，设置为1就是该信号被阻塞掉呗 //sigprocmask()：设置该进程所对应的信号集 if(sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask) &lt; 0) //第一个参数用了SIG_BLOCK表明设置 进程 新的信号屏蔽字 为 “当前信号屏蔽字 和 第二个参数指向的信号集的并集 &#123; //一个 ”进程“ 的当前信号屏蔽字，刚开始全部都是0的；所以相当于把当前 "进程"的信号屏蔽字设置成 newmask（屏蔽了SIGQUIT)； //第三个参数不为空，则进程老的(调用本sigprocmask()之前的)信号集会保存到第三个参数里，用于后续，这样后续可以恢复老的信号集给线程 printf("sigprocmask(SIG_BLOCK)失败!\n"); exit(1); &#125; printf("我要开始休息10秒了--------begin--，此时我无法接收SIGQUIT信号!\n"); sleep(10); //这个期间无法收到SIGQUIT信号的； printf("我已经休息了10秒了--------end----!\n"); if(sigismember(&amp;newmask,SIGQUIT)) //测试一个指定的信号位是否被置位(为1)，测试的是newmask &#123; printf("SIGQUIT信号被屏蔽了!\n"); &#125; else &#123; printf("SIGQUIT信号没有被屏蔽!!!!!!\n"); &#125; if(sigismember(&amp;newmask,SIGHUP)) //测试另外一个指定的信号位是否被置位,测试的是newmask &#123; printf("SIGHUP信号被屏蔽了!\n"); &#125; else &#123; printf("SIGHUP信号没有被屏蔽!!!!!!\n"); &#125; //现在我要取消对SIGQUIT信号的屏蔽(阻塞)--把信号集还原回去 if(sigprocmask(SIG_SETMASK,&amp;oldmask,NULL) &lt; 0) //第一个参数用了SIGSETMASK表明设置 进程 新的信号屏蔽字为 第二个参数 指向的信号集，第三个参数没用 &#123; printf("sigprocmask(SIG_SETMASK)失败!\n"); exit(1); &#125; printf("sigprocmask(SIG_SETMASK)成功!\n"); if(sigismember(&amp;oldmask,SIGQUIT)) //测试一个指定的信号位是否被置位,这里测试的当然是oldmask &#123; printf("SIGQUIT信号被屏蔽了!\n"); &#125; else &#123; printf("SIGQUIT信号没有被屏蔽，您可以发送SIGQUIT信号了，我要sleep(10)秒钟!!!!!!\n"); int mysl = sleep(10); if(mysl &gt; 0) &#123; printf("sleep还没睡够，剩余%d秒\n",mysl); &#125; &#125; printf("再见了!\n"); return 0;&#125; fork函数在一个进程（程序中，可以用fork()创建一个子进程，当子进程被创建时，它从fork()指令的下一条开始执行与父进程相同的代码123456789101112131415161718#include &lt;iostream&gt;#include &lt;unistd.h&gt;using namespace std;int main()&#123; pid_t pid; pid = fork(); if (pid &lt; 0) &#123; cout &lt;&lt; "Fork error" &lt;&lt; endl; &#125; for (;;) &#123; cout &lt;&lt; "Thread id : " &lt;&lt; getpid() &lt;&lt; endl; &#125; return 0;&#125; fork之后，是父进程先执行还是子进程先执行是不一定的。 僵尸进程（Z+） 僵尸进程：已经被终止，但是依旧没被内核舍弃，内核认为父进程可能需要子进程的信息。作为开发者，解决不允许僵尸进程的存在僵尸进程的产生，在Unix系统中，一个子进程结束了，而它的父进程还存活，但该父进程没有调用（wait/waitpid）函数来进行额外的处置，那么这个子进程就会变成一个僵尸进程 干掉僵尸进程 重启电脑 kill掉父进程 SIGCHLD信号：当一个进程被终止的时候，这个信号会被发送给父进程对于源码中有fork的行为，应当拦截处理SIGCHLD信号。在这里我们使用waitpid函数如下：12345678//waitpid用于获取子进程的终止状态，这样子进程就不会成为僵尸进程int status;pid_t pid = waitpid(-1,&amp;status,WNOHANG); //-1表示等待所有子进程，第二个参数为保存子进程信息，第三个参数提供额外选项，让这个waitpid()立即返回if (pid == 0) //子进程未结束，会立即返回这个数字，一般不应该出现这个数字 return;if (pid == -1) //表示waitpid调用有错误，有错误也返回出去 return;return; //正常退出 进一步认识fork函数fork产生新进程的速度非常快，且并不复制原进程的内存空间，而是和原进程一起共享内存空间，但这个内存空间可以同时被多个进程同时读写内存。但如果内存被修改的话，这个内存则会被重新复制一份 fork会返回两次，父进程返回新建立子进程的id进程，子进程返回0 fork失败的可能性 系统中进程太多（缺省最大的pid为32727） 每个用户拥有允许开启的进程总数 守护进程一种长期运行的进程，在后台运行，且不与任何控制终端关联 基本特点 生存周期长，操作系统启动时它就启动，操作系统关闭时它就关闭（非必须，但推荐） 守护进程和终端无关联，不控制终端，即终端退出，守护进程不会退出 linux操作系统本身拥有很多守护进程在运行 ppid=0；内核进程，跟随系统启动而启动，声明周期贯穿整个系统 cmd列名字带[]这种，为内核守护进程 老祖init：系统守护进程，它负责启动各运行层次特定的系统服务；所以很多进程的ppid为init，而这个init同样收养孤儿进程 cmd列中不带[]的普通守护进程（用户级守护进程） 守护进程的编写规则 调用umask(0)，用来限制屏蔽一些文件权限。 fork()一个子进程，然后父进程退出。固定套路 守护进程不会收到的信号 SIGHUP信号。守护进程不会收到来自内核的SIGHUP信号，意味着如果守护进程收到了这个信号，一定是其他程序发给它的。很多通知文件把这个信号作为通知信号，表示配置文件已经发生改动，守护进程应该重新读入信号 SIGINT信号（终端中断符,CTRL+C） SIGWINCH信号（终端窗口大小改变信号） 守护进程和后台进程的区别 守护进程和终端不挂钩，但是后台进程可以往终端输入东西 守护进程关闭终端时不受影响，而后台进程会退出 守护进程范例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //malloc#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;//创建守护进程//创建成功则返回1，否则返回-1int ngx_daemon()&#123; int fd; switch (fork()) //fork()子进程 &#123; case -1: //创建子进程失败，这里可以写日志...... return -1; case 0: //子进程，走到这里，直接break; break; default: //父进程，直接退出 exit(0); &#125; //只有子进程流程才能走到这里 if (setsid() == -1) //脱离终端，终端关闭，将跟此子进程无关 &#123; //记录错误日志...... return -1; &#125; umask(0); //设置为0，不要让它来限制文件权限，以免引起混乱 fd = open("/dev/null", O_RDWR); //打开黑洞设备，以读写方式打开 if (fd == -1) &#123; //记录错误日志...... return -1; &#125; if (dup2(fd, STDIN_FILENO) == -1) //先关闭STDIN_FILENO[这是规矩，已经打开的描述符，动他之前，先close]，类似于指针指向null，让/dev/null成为标准输入； &#123; //记录错误日志...... return -1; &#125; if (dup2(fd, STDOUT_FILENO) == -1) //先关闭STDIN_FILENO，类似于指针指向null，让/dev/null成为标准输出； &#123; //记录错误日志...... return -1; &#125; if (fd &gt; STDERR_FILENO) //fd应该是3，这个应该成立 &#123; if (close(fd) == -1) //释放资源这样这个文件描述符就可以被复用；不然这个数字【文件描述符】会被一直占着； &#123; //记录错误日志...... return -1; &#125; &#125; return 1;&#125;int main(int argc, char *const *argv)&#123; if(ngx_daemon() != 1) &#123; //创建守护进程失败，可以做失败后的处理比如写日志等等 return 1; &#125; else &#123; //创建守护进程成功,执行守护进程中要干的活 for(;;) &#123; sleep(1); //休息1秒 printf("休息1秒，进程id=%d!\n",getpid()); //你就算打印也没用，现在标准输出指向黑洞（/dev/null），打印不出任何结果【不显示任何结果】 &#125; &#125; return 0;&#125; 首先编写守护进程函数ngx_daemon，并规定返回值为1的时候，开启成功。在函数中进行fork开启分支。如果fork返回值为0代表是子进程，可以直接继续，如果返回值为-1则代表开启子进程失败，否则其他情况为父进程，则直接终止父进程。 使用setsid函数来成为一个会话的leaderk，并使用umask来提高创建文件的权限 使用文件指针打开空文件描述符/dev/null，并使用dup2函数将输入以及输出，错误文件描述与它相关联 关闭文件指针，释放资源 一些概念文件描述符正数，用来标识一个文件，当打开一个文件或创建文件，操作系统都会返回一个文件描述符。后续对文件操作的函数都会用到文件描述符作为参数。linux中三个特殊的描述符，分别为0，1，2； 0为标准输入【键盘】，对应符号常量STDIN_FILENO 1为标准输出【屏幕】，对应符号常量STDOUT_FILENO 2为标准错误【屏幕】，对应符号常量STDERR_FILENO一旦程序被运行起来，这三个文件描述符0，1，2被自动打开（自动指向对应设备）空设备/dev/null 一个特殊的设备文件，它丢弃一切往里面写入的数据（如黑洞一般） 服务器程序目录规划信号高级认识范例一旦信号处理函数当中，处理了sleep函数，那么接下来就是多次触发了同样的信号处理函数，也同样不会处理。而是等待上一个信号处理函数执行函数执行完毕才会再次执行信号处理函数。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux</tag>
        <tag>c家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker使用笔记]]></title>
    <url>%2F2018%2F12%2F27%2Fdocker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[docker在Ubuntu下的安装使用 docker的使用命令 启动docker后台服务1sudo service docer start 测试hello-world1sudo docker run hello-world docker常用命令启动docker -d参数：后台运行 -i参数：交互式运行 -t参数：分配一个伪输入终端，一般和-i使用 -p参数：端口映射 本地:容器 –name参数： 指定容器姓名1docker run -d -it 容器名 查看本地镜像查看本地镜像，-a参数为列出所有1docker images -a 删除镜像 使用-f参数强制删除1docker rmi 镜像名 查看正在运行的docker -a参数可以查看历史的记录1docker ps 重命名docker1docker rename 索引名 新名字 删除docker1docker rm 索引 重新启动一个docker（已存在）1docker start 索引 进入一个docker12docker attach 索引docker exic -it 索引 /bin/bash #退出时容器不退出，或者CTRL+P+Q 查询docker1docker search 名字 拉取docker1docker pull 名字]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++并发与多线程（四）]]></title>
    <url>%2F2018%2F12%2F22%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[承接上一篇C++并发与多线程（三） 内容过多分篇记录 涉及async,future创建后台应用 std::packaged_task std::promise std::future其他函数 原子操作 自动析构技术 补充知识点 async,future创建后台应用如果希望线程返回结果,我们可以依赖async或者feture，需要引入future头文件 asyncstd:async 是个函数模板，用来启动一个异步任务，它返回一个std::feture对象 启动异步任务：自动创建一个线程并执行对应的线程入口函数 使用普通函数12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;int mythread() //线程入口函数&#123; cout &lt;&lt; "mythread start " &lt;&lt; "Thread id::" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::millisecond dura(50000); //休息五秒 std::this_thread::sleep_for(dura); cout &lt;&lt; "mythread end" &lt;&lt; endl; return 5;&#125;int main()&#123; cout &lt;&lt; "main : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; //代表async的对象和future绑定在一起 std::future&lt;int&gt; result = std::async(mythread); cout &lt;&lt; "continue : " &lt;&lt; result.get() &lt;&lt; endl; //还有一个wait函数，等待线程返回，本身不返回结果 //result.wait(); system("pause"); return 0;&#125; 使用get类成员函数来获得返回值 wait函数只等待线程，并不返回结果 使用类成员函数1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;class A&#123;public: int mythread(int mypar) //线程入口函数 &#123; cout &lt;&lt; "mypar : " &lt;&lt; mypar &lt;&lt; endl; cout &lt;&lt; "mythread start " &lt;&lt; "Thread id::" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::millisecond dura(50000); //休息五秒 std::this_thread::sleep_for(dura); cout &lt;&lt; "mythread end" &lt;&lt; endl; return 5; &#125;&#125;;int main()&#123; A a; int tmppar = 12; cout &lt;&lt; "main : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result = std::async(&amp;A::mythread,&amp;a,tmppar); cout &lt;&lt; result.get() &lt;&lt; endl; system("pause"); return 0;&#125; async额外参数我们可以通过向std::async()传递一个参数，类型为std::launch类型（枚举类型），来达到一些特殊的目的 std::launch::deferred:表示线程入口调用被延迟到std::future的wait()或get()函数被调用时才执行，延迟调用，并且没有创建新线程，在主线程中调用的线程入口函数 std::launch::async:在调用async的时候就创建了线程，且强制创建线程 若不填写，默认为 std::launch::async | std::launch::deferred测试代码如下：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;class A&#123;public: int mythread(int mypar) //线程入口函数 &#123; cout &lt;&lt; "mypar : " &lt;&lt; mypar &lt;&lt; endl; cout &lt;&lt; "mythread start " &lt;&lt; "Thread id::" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::millisecond dura(50000); //休息五秒 std::this_thread::sleep_for(dura); cout &lt;&lt; "mythread end" &lt;&lt; endl; return 5; &#125;&#125;;int main()&#123; A a; int tmppar = 12; cout &lt;&lt; "main : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result = std::async(std::launch::async,&amp;A::mythread,&amp;a,tmppar); cout &lt;&lt; result.get() &lt;&lt; endl; system("pause"); return 0;&#125; std::async深入谈如果系统资源紧张，很有可能在创建thread时会失败，由于第一个参数默认为 std::launch::async | std::launch::deferred，由系统来确定同步执行还是异步执行（是否创建新线程） std::packaged_taskstd::packaged_task为类模板，模板参数为各种可调用对象，通过这个类模板，可以包装各种可调用对象，方便将来作为线程入口函数来调用12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;int mythread(int mypar) //线程入口函数&#123; cout &lt;&lt; "mypar : " &lt;&lt; mypar &lt;&lt; endl; cout &lt;&lt; "mythread start " &lt;&lt; "Thread id::" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::millisecond dura(50000); //休息五秒 std::this_thread::sleep_for(dura); cout &lt;&lt; "mythread end" &lt;&lt; endl; return 5;&#125;int main()&#123; std::packaged_task&lt;int(int)&gt; mypt(mythread);//返回值为int（尖括号），参数也为int（圆括号） std::thread t1(std::ref(mypt),1); std::future&lt;int&gt; result = mypt.get_future(); //使用get_future，然后就可以使用get获得返回值了 cout &lt;&lt; result.get() &lt;&lt; endl; t1.join(); system("pause"); return 0;&#125; 写法如上，可以使用get_future函数，来返回std::futrue对象，因此还可以继续使用get函数进行获得返回值 包装lambda表达式12345678910111213141516171819#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;int main()&#123; std::packaged_task&lt;int(int)&gt; mypt([](int i)&#123; cout &lt;&lt; "i is : " &lt;&lt; i &lt;&lt; endl; return i; &#125;);//返回值为int（尖括号），参数也为int（圆括号） std::thread t1(std::ref(mypt),1); std::future&lt;int&gt; result = mypt.get_future(); //使用get_future，然后就可以使用get获得返回值了 cout &lt;&lt; result.get() &lt;&lt; endl; t1.join(); system("pause"); return 0;&#125; package_task本身就是可以调用的对象，因此可以不用创建线程，代码如下：123456789101112131415161718#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;int main()&#123; std::packaged_task&lt;int(int)&gt; mypt([](int i)&#123; cout &lt;&lt; "i is : " &lt;&lt; i &lt;&lt; endl; return i; &#125;);//返回值为int（尖括号），参数也为int（圆括号） mypt(10); std::future&lt;int&gt; result = mypt.get_future(); //使用get_future，然后就可以使用get获得返回值了 cout &lt;&lt; result.get() &lt;&lt; endl; system("pause"); return 0;&#125; 这种写法没有创建多线程，相当于函数直接调用 std::promise同样也是一个类模板，我们能够在某个线程中给它复制，然后在其他线程中，把值取出来使用1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;void mythread(std::promise&lt;int&gt; &amp;tmpp , int calc)&#123; //做一系列操作 calc++; calc *= 10; std::chrono::millisecond dura(50000); //休息五秒 std::this_thread::sleep_for(dura); int result = calc; tmpp.set_value(result); //保存结果&#125;int main()&#123; std::promise&lt;int&gt; myprom; //对象保存的值为int类型 std::thread t1(mythread,std::ref(myprom),180); t1.join(); std::future&lt;int&gt; ful = myprom.get_future(); cout &lt;&lt; ful.get() &lt;&lt; endl; system("pause"); return 0;&#125; 使用promise进行存储值，在多线程中使用set_value进行存储，同样有get_future进行获得future成员，并且使用get进行获取值，但是get只能调用一次，不能调用多次，否则必然报错 只要用了thread对象，就一定要join，不然容易报错 future其他成员函数std::future_status这个函数可以设置等待时间，通过future的wait_for去判定一个线程是否符合自己所需要等待的时间，std::future_status::ready,std::future_status::timeout,std::future_status::differed，其中如若async不指定第一个参数，默认返回结果为differed. 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;int mythread() //线程入口函数&#123; cout &lt;&lt; "mythread start " &lt;&lt; "Thread id::" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::chrono::milliseconds dura(5000); //休息五秒 std::this_thread::sleep_for(dura); cout &lt;&lt; "mythread end" &lt;&lt; endl; return 5;&#125;int main()&#123; //cout &lt;&lt; "main : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::future&lt;int&gt; result = std::async(std::launch::async,mythread); //枚举类型 std::future_status status = result.wait_for(std::chrono::seconds(1)); //等待线程是否超时 if (status == std::future_status::timeout) &#123; //超时表示线程还没结束完 cout &lt;&lt; "Time limit" &lt;&lt; endl; &#125; else if (status == std::future_status::ready) &#123; cout &lt;&lt; "Ready" &lt;&lt; endl; result.get(); &#125; else if (status == std::future_status::deferred)//延迟 &#123; cout &lt;&lt; "Differed" &lt;&lt; endl; &#125; system("pause"); return 0;&#125; std::shared_future传统future只能被get一次，而使用移动语义将future过渡到std::shared_future之后，则可以被get多次12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;#include &lt;mutex&gt;using namespace std;int mythread(int num) //线程入口函数&#123; cout &lt;&lt; "mythread start " &lt;&lt; "Thread id::" &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; "mythread num : " &lt;&lt; num &lt;&lt; endl; std::chrono::milliseconds dura(5000); //休息五秒 std::this_thread::sleep_for(dura); cout &lt;&lt; "mythread end" &lt;&lt; endl; return 5;&#125;int main()&#123; //cout &lt;&lt; "main : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; std::packaged_task&lt;int(int)&gt; mypt(mythread); std::thread t1(std::ref(mypt),1); t1.join(); std::future&lt;int&gt; result = mypt.get_future(); std:shared_future&lt;int&gt; result_s(std::move(result)); //或直接使用get_future获得对象 //std:shared_future&lt;int&gt; result_s(mypt.get_future()); cout &lt;&lt; result_s.get() &lt;&lt; endl; cout &lt;&lt; result_s.get() &lt;&lt; endl; system("pause"); return 0;&#125; 原子操作std::atomic原子操作：多线程中不会被打断的程序片段，且效率比互斥量效率更进一筹。即要么完成，要么未完成，不可能出现半完成状态 原子操作一般针对一个变量而不是一个代码段 使用std::atomic类模板，生成对象，且可以像操作普通对象一样操作它1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;atomic&gt;std::atomic&lt;int&gt; g_count(0);//int g_count = 0;void mythread()&#123; for (int i = 0 ; i &lt; 10000000 ; i++) &#123; g_count++; &#125;&#125;using namespace std;int main()&#123; std::thread t1(mythread); std::thread t2(mythread); t1.join(); t2.join(); cout &lt;&lt; g_count &lt;&lt; endl; system("pause"); return 0;&#125; 叙谈std::atomic并不是所有运算符都支持原子操作的，一般atomic原子操作针对++,–,+=,&amp;=,|=,^=,其他的可能不支持。如之前的代码改为g_count = g_count + 1，返回的结果就出问题了 windows临界区临界区可以近似看成mutex，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;windows.h&gt;#define __WINDOWSJQ_using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex;#ifdef __WINDOWSJQ_ CRITICAL_SECTION my_winsec; //windows临界区，近似于互斥量#endifpublic:#ifdef __WINDOWSJQ_ A() &#123; InitializeCriticalSection(&amp;my_winsec); //初始化临界区 &#125;#endif void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123;#ifdef __WINDOWSJQ_ EnterCriticalSection(&amp;my_winsec); myData.push_back(i); LeaveCriticalSection(&amp;my_winsec);#else my_mutex.lock(); myData.push_back(i); my_mutex.unlock();#endif &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123;#ifdef __WINDOWSJQ_ EnterCriticalSection(&amp;my_winsec); myData.pop_front(); LeaveCriticalSection(&amp;my_winsec);#else my_mutex.lock(); myData.pop_front(); my_mutex.unlock();#endif &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 在同一个线程，可以多次进入临界区，但是相应的也需要多次退出临界区。但是使用mutex不能多次加锁 自动析构技术RAII类（Resource Acquisition is initialization） 资源获取即初始化 即构造函数进行锁操作，析构函数进行解锁，在括号体内直接声明对象即可 recursive_mutex递归独占互斥量 std::mutex 独占互斥量，自己lock时，别人就无法lock recursive_mutex 递归独占互斥量，允许多次lock，解决多次调用的问题 timed_mutex 带超时的互斥量，如果在一定时间内拿不到锁，流程继续往下走，拥有函数try_lock_for，以及try_lock_until来尝试获取锁 recursive_timed_mutex 递归带超时的互斥量 补充知识点虚假唤醒如果多次调用notify_one，则可能造成虚假唤醒，因此可以在wait中第二个参数加入lambda函数，来防止虚假唤醒12345my_cond.wait(sbguard1,[this]&#123; if (!myData.empty()) return true; return false; &#125;); 浅谈线程池 如果业务有需求，线程数量尽量不要超过500个，能控制在200个以内]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++并发与多线程（三）]]></title>
    <url>%2F2018%2F12%2F14%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[承接上一篇C++并发与多线程（二） 内容过多分篇记录 设计单例模式共享数据分析 std::call_once的使用 进程间的通讯 设计模式概括用设计模式写出来的代码程序灵活，维护起来可能方便，但是写出来的代码很晦涩，别人接管代码，阅读代码不大方便 单例设计模式单例设计模式使用频率较高，单例：整个项目中，由某个或者或某些特殊的类，属于该类的对象，只允许创建一个 单例类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class MyCAS&#123;private: MyCAS() //私有化了构造函数 &#123; &#125; private: static MyCAS *m_instance; //静态成员变量public: static MyCAS* GetInstance() &#123; if (m_instance == NULL) &#123; m_instance = new MyCAS(); &#125; static CGarhuishou cl; //静态对象生命周期一直到程序退出 return m_instance; &#125; class CGarhuishou //类中套类，用来释放对象 &#123; public: ~CGarhuishou() &#123; if (MyCAS::m_instance) &#123; delete MyCAS::m_instance; MyCAS::m_instance = NULL; &#125; &#125; &#125;; void func() &#123; cout &lt;&lt; "Test " &lt;&lt; endl; &#125;&#125;;MyCAS* MyCAS::m_instance = NULL;int main()&#123; MyCAS* p_a = MyCAS::GetInstance(); //创建一个对象，返回该类的指针 system("pause"); return 0;&#125; 单例模式本质就是将构造函数私有化，设置静态成员函数进行初始化成员，一旦类中的静态成员不为NULL，就New一个出来，否则返回静态成员 值得一提的是要如何释放它已经new出来的空间，在这里我们要在类中再套一个类，并在构造成员的同时，声明一个static的对象，这个对象会在程序整个生命周期结束的时候，调用自身的析构函数，从而释放整片空间 单例设计模式共享数据分析、解决为了共享单例类的数据，我们引入多线程，但是原先的代码有可能碰到多次new同一个类成员，因此我们需要引入锁，进行双重保护，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;std::mutex rescource_mutex;class MyCAS&#123;private: MyCAS() //私有化了构造函数 &#123; &#125; private: static MyCAS *m_instance; //静态成员变量public: static MyCAS* GetInstance() &#123; // 提高效率 if (m_instance == NULL) //双重锁定，提高效率 &#123; std::unique_lock&lt;std::mutex&gt; mymutex(rescource_mutex); if (m_instance == NULL) &#123; m_instance = new MyCAS(); &#125; static CGarhuishou cl; //静态对象生命周期一直到程序退出 &#125; return m_instance; &#125; class CGarhuishou //类中套类，用来释放对象 &#123; public: ~CGarhuishou() &#123; if (MyCAS::m_instance) &#123; delete MyCAS::m_instance; MyCAS::m_instance = NULL; &#125; &#125; &#125;; void func() &#123; cout &lt;&lt; "Test " &lt;&lt; endl; &#125;&#125;;MyCAS* MyCAS::m_instance = NULL;void initThread()&#123; cout &lt;&lt; "In" &lt;&lt; endl; MyCAS::GetInstance(); cout &lt;&lt; "Out" &lt;&lt; endl; return;&#125;int main()&#123; std::thread t1(initThread); std::thread t2(initThread); t1.join(); t2.join(); system("pause"); return 0;&#125; std::call_once() 函数模板C++11引入的函数，其中第二个参数为函数名，功能：能够保证多线程的情况下，函数A只被调用一次 具备互斥量的能力 据说比互斥量消耗的资源更少 需要结合标记结合使用，std::once_flag，是一个结构，只要once_flag被设置为已调用的状态，后续的函数就不会再被执行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;std::mutex rescource_mutex;std::once_flag g_flag;class MyCAS&#123; static void createInstance() &#123; m_instance = new MyCAS(); static CGarhuishou cl; //静态对象生命周期一直到程序退出 &#125;private: MyCAS() //私有化了构造函数 &#123; &#125; private: static MyCAS *m_instance; //静态成员变量public: static MyCAS* GetInstance() &#123; std::call_once(g_flag,createInstance); cout &lt;&lt; "CallOnce over" &lt;&lt; endl; return m_instance; &#125; class CGarhuishou //类中套类，用来释放对象 &#123; public: ~CGarhuishou() &#123; if (MyCAS::m_instance) &#123; delete MyCAS::m_instance; MyCAS::m_instance = NULL; &#125; &#125; &#125;; void func() &#123; cout &lt;&lt; "Test " &lt;&lt; endl; &#125;&#125;;MyCAS* MyCAS::m_instance = NULL;void initThread()&#123; cout &lt;&lt; "In" &lt;&lt; endl; MyCAS::GetInstance(); cout &lt;&lt; "Out" &lt;&lt; endl; return;&#125;int main()&#123; std::thread t1(initThread); std::thread t2(initThread); t1.join(); t2.join(); system("pause"); return 0;&#125; 单例模式建议在主线程先创建完对象之后，再开多线程 进程间的通讯std::condition_variable类本质上为一个类，等待条件达成，需要和互斥量进行配合工作 需要引入头文件condition_variable 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex1; std::condition_variable my_cond;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 1000 ; i++) &#123; std::unique_lock&lt;std::mutex&gt; sbguard(my_mutex1); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_cond.notify_one(); //尝试唤醒wait的线程 &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; while(true) &#123; std::unique_lock&lt;std::mutex&gt; sbguard1(my_mutex1); //wait用来等一个东西 //如果第二个参数（lambda）返回值为false,wait解锁互斥量，并堵塞到本行 //如果返回值为true,wait()直接返回 //堵塞到其他某个线程调用notify_one()成员函数为止 //如果缺少第二个参数，结果就和lambda返回false一样 //一旦被唤醒，会重新进行判断，如果返回true就继续往下执行 my_cond.wait(sbguard1,[this]&#123; if (!myData.empty()) return true; return false; &#125;); myData.pop_front(); sbguard1.unlock(); cout &lt;&lt; "Pop Data" &lt;&lt; endl; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); system("pause"); return 0;&#125; wait代表用来等一个东西 如果第二个参数（lambda）返回值为false,wait解锁互斥量，并堵塞到本行 如果返回值为true,wait()直接返回 堵塞到其他某个线程调用notify_one()成员函数为止 如果缺少第二个参数，结果就和lambda返回false一样 一旦被唤醒，会重新进行判断，如果返回true就继续往下执行 notify_all()某些情况下，我们可以同时唤醒多个线程，因此代码更改如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex1; std::condition_variable my_cond;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 1000 ; i++) &#123; std::unique_lock&lt;std::mutex&gt; sbguard(my_mutex1); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_cond.notify_all(); //尝试唤醒wait的线程 &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; while(true) &#123; std::unique_lock&lt;std::mutex&gt; sbguard1(my_mutex1); //wait用来等一个东西 //如果第二个参数（lambda）返回值为false,wait解锁互斥量，并堵塞到本行 //如果返回值为true,wait()直接返回 //堵塞到其他某个线程调用notify_one()成员函数为止 //如果缺少第二个参数，结果就和lambda返回false一样 //一旦被唤醒，会重新进行判断，如果返回true就继续往下执行 my_cond.wait(sbguard1,[this]&#123; if (!myData.empty()) return true; return false; &#125;); myData.pop_front(); cout &lt;&lt; "Thread id : " &lt;&lt; std::thread::get_id &lt;&lt; endl; cout &lt;&lt; "Pop Data" &lt;&lt; endl; sbguard1.unlock(); &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); std::thread thread3(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); thread3.join(); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++并发与多线程（二）]]></title>
    <url>%2F2018%2F12%2F11%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[承接上一篇C++并发与多线程（一） 内容过多分篇记录 主要涉及多个线程的创建 互斥量的基本概念 创建和等待多个线程可以使用vector进行存储线程，实例代码如下：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;using namespace std;void myprint(int inum)&#123; cout &lt;&lt; "Id: " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; inum &lt;&lt; endl;&#125;int main()&#123; vector&lt;thread&gt; mythreads; for (int i = 0 ; i &lt; 10 ; i++) &#123; mythreads.push_back(thread(myprint,i)); //这时候一旦创建就开始执行了 &#125; for (auto iter = mythreads.begin() ; iter != mythreads.end() ; iter++) &#123; iter-&gt;join(); &#125; cout &lt;&lt; "I love china" &lt;&lt; endl; system("pause"); return 0;&#125; 数据共享内存分析只读数据只读数据十分安全，不需要特别的处理手段，直接读取即可 有读有写数据如果代码没有特殊处理，肯定崩溃。最简单的不崩溃处理：读的时候不能写，写的时候不能读 互斥量保护共享数据，防止多个线程同时操作同一片内存空间，因此引入互斥量，将数据锁住 lock以及unlock是mutex头文件中定义的函数，要成对使用，否则必然报错，示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; my_mutex.lock(); //cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_mutex.unlock(); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; my_mutex.lock(); //cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); my_mutex.unlock(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 为了防止忘记unlock，引入类似智能指针的类模板std::lock_guard，可以同时取代lock以及unlock两个东西，因此不能再次lock以及unlock12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex); //cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex); //cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 作用原理：std::lock_guard在语句块里面声明，构造函数上锁，出了语句块调用析构函数进行解锁，但是并不如手动上锁进行灵活 死锁死锁的产生死锁产生的前提条件是必须有两个锁（互斥量）才会产生，死锁演示:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; my_mutex.lock(); my_mutex1.lock(); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_mutex.unlock(); my_mutex1.unlock(); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; my_mutex1.lock(); my_mutex.lock(); cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); my_mutex.unlock(); my_mutex1.unlock(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 死锁的一般解决方案 只要保证两个互斥量上锁顺序一致，就不会产生死锁 std::lock()函数模板功能：一次锁住两个或两个以上的互斥量（至少两个），不存在因锁头顺序问题而导致的死锁问题。如果其中一个互斥量没锁住，它就释放已经锁住的锁，直到所有互斥量都锁住。必须手动unlock1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; std::lock(my_mutex,my_mutex1); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_mutex.unlock(); my_mutex1.unlock(); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; std::lock(my_mutex,my_mutex1); cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); my_mutex.unlock(); my_mutex1.unlock(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 使用std::lock和std:lock_guard进行组合默认情况下，std::lock_guard构造的变量会将变量上锁，但是可以手工指定第二个参数为std::adopt_lock进行忽略，std::adopt_lock为一个结构体对象，起到标记作用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; std::lock(my_mutex,my_mutex1); std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; std::lock(my_mutex,my_mutex1); std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; unique_lock取代lock_guardunique_lock是个类模板，工作中一般lock_guard（推荐使用）。unique_lock比lock_guard灵活许多，但是灵活的代价是效率差了点，内存占用大了点。 在缺省的情况下，unique_lock和lock_guard第一个参数都相同，用起来区别不大。lock_guard第二个参数用std::adopt_lock作为标记，表示互斥量已经被标记，必须保证互斥量已经提前被lock过了，否则会报异常。同理unique_lock也可以用这个标记。 std::try_to_lock假设当下有两个线程在争夺一把锁，其中一个线程在拿到锁之后，线程进行休眠，这样子另一个线程则会因此而等待休眠结束。因此我们的第二个参数可以使用try_to_lock try_to_lock：尝试用mutex的lock去锁定这个mutex，但是如果没有锁定成功，会立即返回，并不会阻塞。但是自己千万不能进行手动lock，否则相当于lock两次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; //std::lock(my_mutex,my_mutex1); //std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); //std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); std::unique_lock&lt;std::mutex&gt; sblock(my_mutex,std::try_to_lock); if (sblock.owns_lock()) &#123; //cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); &#125; else &#123; cout &lt;&lt; "Thread1 cannot get lock" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; //std::lock(my_mutex,my_mutex1); //std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); //std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); std::unique_lock&lt;std::mutex&gt; sblock(my_mutex,std::try_to_lock); std::chrono::milliseconds dura(200000); std::this_thread::sleep_for(dura); if (sblock.owns_lock()) &#123; cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); &#125; else &#123; cout &lt;&lt; "Cannot get lock" &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; std::defer_lock用这个defer_lock的前提是，你不能自己先lock，否则会报异常。defer_lock就是初始化一个没有加锁的mutex unique_lock的成员函数 lock() 加锁 unlock() 解锁 try_lock() 尝试给互斥量加锁，拿到锁返回true，这个函数不阻塞 release() 返回它所管理的mutex对象指针，并释放所有权。也就是说这个unique_lock和mutex不再有关系（绑定在一起的关系进行分开），如果原来mutex处于加锁状态，有责任接管过来自己解锁。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; std::unique_lock&lt;std::mutex&gt; sbguard(my_mutex); std::mutex* ptx = sbguard.release(); ptx-&gt;unlock(); myData.push_back(i); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; std::unique_lock&lt;std::mutex&gt; sbguard1(my_mutex1,std::defer_lock); sbguard1.lock(); myData.pop_front(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; unique_lock所有权的传递unique_lock和mutex进行绑定到一起从而发挥作用，假设std::unique_lock sbguard1(my_mutex1)，sbguard1可以把my_mutex1所有权转移给unique_lock其他对象，但是不允许复制，和智能指针一样 123456789101112std::unique_lock&lt;std::mutex&gt; sbguard2(std::move(my_mutex1)); //移动语义，相当于sbguared2和my_mutex1绑定到了一起//另一种写法class A &#123;public: std::unique_lock&lt;std::mutex&gt; rtn_unique_lock() &#123; std::unique_lock&lt;std::mutex&gt; tmpguard(my_mutex1); //会自动生成unique_lock对象，并调用移动构造函数 return tempguard; &#125;&#125;;]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++并发与多线程（一）]]></title>
    <url>%2F2018%2F12%2F09%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++小白进阶之路 了解多线程是如何编写的 跟随网易云课堂视频学习 内容涵盖线程启动，创建，传参以及detach的坑点 并发，进程，线程两个或者更多的任务同时发生进行，一个程序同时执行多个任务，由操作系统统一调度 进程与主线程唇齿相依，线程可以近似理解成执行代码的通路，且主线程唯一 线程并不是越多越好，每个线程都需要一个独立的堆栈空间（1M理论值），线程需要保存中间状态，耗费本该属于程序运行的时间 多进程并发进程之间的通信（同一个电脑：管道，文件，消息队列，共享内存）（不同电脑：socket通信技术） 多线程并发每个线程都有自己独立的路径，但是一个进程所有线程共享地址空间（共享内存），全局变量，指针，引用都可以在线程之间传递，因此使用多线程的开销远远小于多进程 共享内存带来新问题，数据是否为一致性（线程锁等） 多进程并发和多线程并发虽然可以混合使用，但是建议优先考虑多线程技术而不是多进程 C++11新标准线程库以往Windows：CreateThread() , _beginthread(),_beginthreadexe() 以往Linux:pthread_create() 以往多线程不能跨平台，C++11新标准允许。 线程创建，启动，结束进程结束的标志是主线程是否执行完毕，如果主线程执行完毕了，代表整个进程执行完毕。（一般情况）如果其他子线程还没有执行完毕，那么这些子线程也会被操作系统强行终止。因此得出结论：如果想保持子线程的运行状态，需要保持主线程一直运行。（但是有例外情况） 范例（主线程等待子线程）123456789101112131415161718192021#include &lt;iostream&gt;//包含thread头文件#include &lt;thread&gt;//创建一个函数void myprint()&#123; std::cout &lt;&lt; "Thread begin.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; return;&#125;int main()&#123; std::thread myobj(myprint); //阻塞主线程，并等待myprint子线程执行完毕 myobj.join(); std::cout &lt;&lt; "I love China!" &lt;&lt; std::endl; system("pause"); return 0;&#125; join阻塞主线程，当子线程执行完毕，才可以继续往下运行 范例（主线程不等待子线程）传统多线程程序，主线程需要等待子线程执行完毕，然后自己再最后退出 detach分离，一旦detach之后，与主线程关联的thread对象，就会失去与主线程的关联，此时子线程就会驻留在后台运行，（主线程跟子线程相当于被C++运行时库接管），当子线程执行完毕之后，由运行时库负责清理该线程相关的资源（守护线程） 123456789101112131415161718192021#include &lt;iostream&gt;//包含thread头文件#include &lt;thread&gt;//创建一个函数void myprint()&#123; std::cout &lt;&lt; "Thread begin.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; return;&#125;int main()&#123; std::thread myobj(myprint); myobj.detach(); std::cout &lt;&lt; "I love China!" &lt;&lt; std::endl; system("pause"); return 0;&#125; joinable函数判断是否可以成功调用join或者detach函数，返回true或者false 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;//包含thread头文件#include &lt;thread&gt;//创建一个函数void myprint()&#123; std::cout &lt;&lt; "Thread begin.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; return;&#125;int main()&#123; std::thread myobj(myprint); myobj.join(); if (myobj.joinable()) &#123; std::cout &lt;&lt; "1:joinable() == true" &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; "2:joinable() == false" &lt;&lt; std::endl; &#125; std::cout &lt;&lt; "I love China!" &lt;&lt; std::endl; system("pause"); return 0;&#125; 一旦join或者detach之后，joinable返回false，再次调用引发异常 其他创建线程的手法用类进行调用1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class TA&#123;public: void operator()() &#123; cout &lt;&lt; "我的线程开始执行了" &lt;&lt; endl; cout &lt;&lt; "我的线程结束了" &lt;&lt; endl; &#125;&#125;;int main()&#123; TA ta; thread myobj(ta); myobj.join(); cout &lt;&lt; "I love China!" &lt;&lt; endl; system("pause"); return 0;&#125; 使用detach的坑123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class TA&#123;public: int &amp;m_i; TA(int &amp;i) : m_i(i) &#123; &#125; void operator()() &#123; cout &lt;&lt; "m_i1 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i2 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i3 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i4 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i5 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; &#125;&#125;;int main()&#123; int myi = 6; TA ta(myi); thread myobj(ta); myobj.detach(); cout &lt;&lt; "I love China!" &lt;&lt; endl; return 0;&#125; 由于传入的myi是引用，当程序结束时，变量被回收，子线程将是不确定的值 新问题出现了，当程序结束的时候，对象被回收了，但是却不影响调用，因此得出结论，对象是被复制到线程当中去的，ta被销毁，所复制的ta对象依然存在 用lambda表达式123456789101112131415#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;int main()&#123; auto mylambda = []&#123; cout &lt;&lt; "线程开始执行了" &lt;&lt; endl; &#125;; thread myobj(mylambda); myobj.join(); cout &lt;&lt; "I love China!" &lt;&lt; endl; system("pause"); return 0;&#125; 线程传参传递临时对象作为线程参数1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void myprint(const int &amp;i,char* pmybuf)&#123; //不推荐用引用传参，绝对不要用指针 cout &lt;&lt; i &lt;&lt; endl; //分析认为,i的地址和main函数中i地址不相同，因此i的值是安全的（i被复制了一份） cout &lt;&lt; pmybuf &lt;&lt; endl; //pmybuf指向的是main函数中的mybuf，不安全 return;&#125;int main()&#123; int mvar = 1; int&amp; mvary = mvar; char mybuf[] = "this is a test!"; thread myobj(myprint,mvar,mybuf); myobj.detach(); cout &lt;&lt; "I Love China" &lt;&lt; endl; return 0;&#125; （陷阱1）如上可以看出参数为引用虽然可以，但是不大推荐，指针则是极其危险的。但是一定要传的话，可以尝试将char* pmybuf 更改为const string&amp; pmybuf（依然有BUG） （陷阱2）mybuf到底在何时转为string的？因此可以用如下改法 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;void myprint(const int &amp;i,const string&amp; pmybuf)&#123; //不推荐用引用传参，绝对不要用指针 cout &lt;&lt; i &lt;&lt; endl; //分析认为,i的地址和main函数中i地址不相同，因此i的值是安全的（复制的） cout &lt;&lt; pmybuf &lt;&lt; endl; //pmybuf指向的是main函数中的mybuf，不安全 return;&#125;int main()&#123; int mvar = 1; int&amp; mvary = mvar; char mybuf[] = "this is a test!"; //thread myobj(myprint,mvar,mybuf); //存在mybuf被回收了，才开始复制 //正确写法 thread myobj(myprint,mvar,string(mybuf)); myobj.detach(); cout &lt;&lt; "I Love China" &lt;&lt; endl; return 0;&#125; 小结 若传递int这种简单类型参数，建议都是值传递，不要用引用，防止节外生枝 如果传递类对象，避免隐式类型转换，全部都在创建线程时，构造出临时对象，函数体使用引用来接 终极结论：建议不使用detach，只使用join，这样就不存在局部变量失效导致对内存的非法引用。 传递临时对象作为线程参数（续）线程id可以通过标准库函数获得如下：1std::this_thread::get_id(); 传递类对象、智能指针作为线程参数类对象默认往线程中传递类对象时，假设目前有类A，即使自己使用的是const A&amp; a，依然会拷贝构造出一个类对象，且const必须加，不加新型编译器会报错。 std::ref函数则可以真正将一个对象传递进去，且const可以去掉，成员变量也不需要使用mutable关键字，ref函数传入的类对象不会被复制，因此主线程和新建的线程使用的是同一个对象，写法如下： 12class A;std::ref(A); 智能指针unique_ptr智能指针直接作为参数传入会报错，因此需要使用std::move进行传输，代码如下： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;void myprint(unique_ptr&lt;int&gt; i)&#123; //不推荐用引用传参，绝对不要用指针 cout &lt;&lt; *i &lt;&lt; endl; //分析认为,i的地址和main函数中i地址不相同，因此i的值是安全的（复制的） cout &lt;&lt; "Thread new : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return;&#125;int main()&#123; unique_ptr&lt;int&gt; myp(new int(100)); thread myobj(myprint,std::move(myp)); myobj.join(); system("pause"); return 0;&#125; 用成员函数指针作为线程函数第一个参数为成员函数的地址，第二个参数为传入的类成员 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;class A&#123;public: void say() &#123; cout &lt;&lt; "Son thread begin.." &lt;&lt; endl; &#125;&#125;;int main()&#123; A myobj; thread mytobj(&amp;A::say,&amp;myobj); mytobj.join(); system("pause"); return 0;&#125; 类成员尽量使用引用传入函数，可以保证使用的是同一个类成员而不被复制一份]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmake的使用]]></title>
    <url>%2F2018%2F11%2F04%2Fcmake%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用开源框架SeetaFaceEngine需要手动改写CMakeList.txt 简要入门cmake的使用 单个源文件 目录树如下： 1234cpp├── build├── CMakeLists.txt└── main.cpp 源文件放置于根目录，进行CMakeLists.txt的编写 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Hello)# 指定生成目标add_executable(Hello main.cpp) 切换到目录build，使用cmake .. &amp;&amp; make进行编译，即可得到可执行文件Hello 12345678910# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Hello)# 指定生成目标# 这里指定目录，得到变量# 格式：aux_source_directory(&lt;dir&gt; &lt;variable&gt;)aux_source_directory(. DIR_SRCS)add_executable(Hello $&#123;DIR_SRCS&#125;) 多个目录多个源文件 现有目录如下： 1234567cpp├── CMakeLists.txt├── include│ └── temp.h└── src ├── main.cpp └── temp.cpp temp中含有一个say函数，再main函数中进行调用，编写CMakeLists如下： 1234567891011121314cmake_minimum_required(VERSION 2.6)project(hello)#引入头文件include_directories(./include)#导入目录aux_source_directory(. PROJECT_ROOT)aux_source_directory(./src SRC)add_executable(hello $&#123;PROJECT_ROOT&#125; $&#123;SRC&#125;)#生成共享库add_library(libhello SHARED $&#123;PROJECT_ROOT&#125; $&#123;SRC&#125;) 常用编译选项1234567891011#设置工程所生成的目标文件所需要的链接的库，在这里我们需要libhello.so这个库target_link_libraries ($&#123;PROJECT_NAME&#125; libhello)#add_definitions 设置编译选项add_definitions (&quot;-g&quot;) #-g编译成可调试的程序#设置编译好的可执行文件在执行时连接库的路径set (CMAKE_INSTALL_RPATH .;/usr/local/lib64)set (CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)add_subdirectory #将工程中的子目录加入编译工程中,子目录当中需要CMakeLists.txt文件]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux下的QQ配置]]></title>
    <url>%2F2018%2F06%2F17%2Farchlinux%E4%B8%8B%E7%9A%84QQ%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[QQ重度患者 Linux配置QQ过程繁琐，坑众多 在此记录Linux下的QQ配置 发行版：archlinux 64位 安装wine 由于是基于archlinux，所以安装配置十分简单 首先先启用Multilib仓库 1234sudo vim /etc/pacman.conf#取消以下注释[multilib]Include = /etc/pacman.d/mirrorlist 更新系统 1sudo pacman -Syy 安装wine 1sudo pacman -S wine wine_gecko wine-mono winetricks wine的版本问题 最新的wine版本似乎不支持直接使用 可以在官方wiki找到如下： Archlinux打包的wine-3.8与wine-3.9.1版本均在安装QQ后无法打开，出现无法加载gdi32.dll的错误 可以使用命令“sudo pacman -U /var/cache/pacman/pkg/wine-3.7-1-x86_64.pkg.tar.xz”将wine降级到之前的3.7版本解决。 为了避免被升级到新3.9版本而无法使用QQ，可以编辑”/etc/pacman.conf”文档，去掉”IgnorePkg”一行前面的”#”号，并在该行”=”号后面添加”wine”；在后续更新中该问题得到解决后，记得去掉wine，以便更新之。 可以很明显观察到如果想要使用QQ，必须将wine降级到3.7 所以需自行下载wine3.7的安装包手动降级 找到下载地址：wine3.71sudo pacman -U wine-3.7-1-x86_64.pkg.tar.x 安装QQ 由于目前许多QQ都十分不稳定 官方wiki中的deepin-qq-im在这里安装完后无法使用，谷歌许久后，选择清风QQ进行安装 地址如下：清风QQ 下载完其中压缩包之后，按说明的命令进行解压 1tar xvf wineQQ9.0.3_23719.tar.xz -C ~/ 解压完之后即可在程序中看到QQ的图标 已知问题 无法记住密码 无法打开群文件 无法使用我的手机进行传输文件 删除方法123rm -rf ~/.winerm -rf ~/.local/share/applications/wine-QQ.desktoprm -rf ~/.local/share/icons/hicolor/256x256/apps/QQ.png 参考文章清风的网络空间ArchLinux安装配置WineQQ]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile的编写]]></title>
    <url>%2F2018%2F06%2F13%2Fmakefile%E7%9A%84%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[在linux下一旦需要编译的文件过多 使用gcc过于繁琐，可以通过编写makefile文件来减轻工作量 记录如何编写makefile 创建makefile文件 首先在工程目录当中创建一个makefile文件 早期makefile首字母必须大写，不过现在大小写均可 基本makefile格式 编写格式如下： 1234target: dependencies command//dependencies为需要的依赖//command为需要的命令 示例如下 12test: HelloWorld.cpp g++ HelloWorld.cpp -o test make编译 使用make命令进行直接编译 多个文件编写makefile 假设当前目录下拥有三个文件 123main.ctool.ctool.h 编写如下makefile 123456main: main.c tool.o gcc main.c tool.o -o main//但是tool.o并不存在所以需要告知编译器tool.o位置tool.o: tool.c gcc -c tool.c//-c代表直接编译成.o的文件 常见后端文件用途12345678910Windows下：h：头文件，给编译器用来检查语法lib：主要包含了如何找到函数的地址的信息，以及附带一些编译了一半的二进制数据obj：编译了一半的二进制数据dll、exe：可以运行linux下：.o,是目标文件,相当于windows中的.obj文件 .so 为共享库,是shared object,用于动态连接的,相当于windows下的dll .a为静态库,是好多个.o合在一起,用于静态连接 lib和DLL的区别 lib是编译时需要的，dll是运行时需要的。缺少dll文件程序将无法运行（动态链接库），而lib文件则是静态链接库 obj文件 obj里存的是编译后的代码跟数据，并且有名称，所以在连接时有时会出现未解决的外部符号的问题。当连成exe后便不存在名称的概念了，只有地址。lib就是一堆obj的组合。 删除指令 使用clean指令进行删除不必要的文件 12clean: rm *.o main 运行make clean进行删除文件 在makefile当中设置变量 设置变量的方式与普通编程语言方式差别不大，如下例子 1CC = gcc 具体使用的时候需要%符号 12main: main.c test.o $(CC) main.c test.o -o main 编写两个可执行文件 默认情况下似乎无法同时编译出两个可执行文件 假设需要编写两个可执行文件，文件名为main_max,main_min 须在开头加入：1all: main_max main_min]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <url>%2F2018%2F06%2F13%2Fgdb%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在linux下面使用gdb进行断点调试 介绍如何操作gdb 编译文件 平时调试代码直接使用gcc或g++即可编译 1gcc test.c -o test 需要使用gdb编译需要加上-g参数 1gcc -g test.c -o test 调试文件 使用gdb命令打开文件1gdb test 常用命令设置断点 使用b设置断点1b main //在main函数设置断点 运行命令 使用r运行程序 单步运行 使用n进入下一行（不进入的单步执行） 使用s为进入的单步执行，finish为单步跳出 显示变量 p可以显示变量名1p 变量名 查看代码 使用list，简写l 查看断点，监视 info b //断点 info watch //监视 运行到下一个断点 continue 简写为c 终止运行 使用kill来终止 删除断点 使用delete breakpoint 1 //需先使用info进行查看 检查汇编 disas 查看汇编代码 查看寄存器内容 info registers 查看寄存器的值，可以用print $name 打印寄存器内容 每步执行 stepi 检查寄存器或某个地址 x $rsp]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django+nginx+uwsgi进行服务器部署]]></title>
    <url>%2F2018%2F06%2F08%2Fdjango-nginx-uwsgi%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[django的服务器配置可以说是十分繁琐的部分 哪怕严格按照步骤也会有不明错误 再此详细记录操作步骤 版本Ubuntu 16.04 LTS 64位 服务器：腾讯云学生机 由于配置繁琐，所以操作步骤实在全新系统进行配置 准备django文件 由于已经有过django项目，所以直接将django上传至服务器 目录树如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ubuntu@VM-246-186-ubuntu:~/site$ tree BlogBlog├── Blog│ ├── __init__.py│ ├── __pycache__│ │ ├── __init__.cpython-36.pyc│ │ ├── settings.cpython-36.pyc│ │ ├── urls.cpython-36.pyc│ │ └── wsgi.cpython-36.pyc│ ├── settings.py│ ├── urls.py│ └── wsgi.py├── db.sqlite3├── manage.py├── myblog│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ │ ├── 0001_initial.py│ │ ├── __init__.py│ │ └── __pycache__│ │ ├── 0001_initial.cpython-36.pyc│ │ └── __init__.cpython-36.pyc│ ├── models.py│ ├── __pycache__│ │ ├── admin.cpython-36.pyc│ │ ├── __init__.cpython-36.pyc│ │ ├── models.cpython-36.pyc│ │ ├── urls.cpython-36.pyc│ │ └── views.cpython-36.pyc│ ├── static│ │ └── myblog│ │ ├── css│ │ │ ├── semantic.css│ │ │ └── themes│ │ │ └── default│ │ │ └── assets│ │ │ ├── fonts│ │ │ │ ├── brand-icons.eot│ │ │ │ ├── brand-icons.svg│ │ │ │ ├── brand-icons.ttf│ │ │ │ ├── brand-icons.woff│ │ │ │ ├── brand-icons.woff2│ │ │ │ ├── icons.eot│ │ │ │ ├── icons.otf│ │ │ │ ├── icons.svg│ │ │ │ ├── icons.ttf│ │ │ │ ├── icons.woff│ │ │ │ ├── icons.woff2│ │ │ │ ├── outline-icons.eot│ │ │ │ ├── outline-icons.svg│ │ │ │ ├── outline-icons.ttf│ │ │ │ ├── outline-icons.woff│ │ │ │ └── outline-icons.woff2│ │ │ └── images│ │ │ └── flags.png│ │ └── js│ │ ├── jquery-3.3.1.js│ │ ├── jquery-3.3.1.min.js│ │ ├── semantic.js│ │ └── vue.js│ ├── tests.py│ ├── urls.py│ └── views.py└── templates └── myblog ├── detail.html └── index.html 目录树不必在意，主要操作的文件为manage.py 配置环境安装依赖 Ubuntu系统默认为python2，但是这里测试的django版本为2.0以上，需要python3版本来安装 为了防止打乱系统环境，还需要virtualenv进行管理python环境 12sudo apt-get install python3-pipsudo pip install virtualenv 准备就绪之后进行创建新环境 12virtualenv env27 --python=python3.5#其中env27为环境名称，自己替换 进入新环境 1source test/bin/activate 由于我的django项目中包含了django-suit以及markdown，所以在运行django前需要提前准备完这两个包 1(test) ubuntu@VM-246-186-ubuntu:~/site$ pip install django django-suit markdown 进行django测试 在云服务器上部署确保安全组端口已经开放 确保是在虚拟环境当中，注意命令行前的test配置setting文件 首先要让服务器知道静态文件的位置以及允许访问的ip 进入Blog目录中，编辑setting.py文件 1234567#找到ALLOWED_HOSTS = []#将其配置为ALLOWED_HOSTS = ['*']#配置静态文件目录，在文件尾部直接添加STATIC_ROOT = os.path.join(BASE_DIR , "static/")#找到DEBUG = True，改为False，亦可最后再来改动方便定位错误DEBUG = False 配置完毕之后，回到根目录执行收集静态文件操作 1python manage.py collectstatic 可以看到在目录当中生成了一个static的文件夹，该文件夹包含了网站的全部静态文件 登录网站测试 在项目根目录处运行服务器测试命令，确保8001端口未被占用，如果被占用需手动指定端口号 1python manage.py runserver 0.0.0.0 8001 如果一切顺利的话，应该可以通过IP进行直接访问网站 在浏览器输入IP地址+端口号进行服务器测试 可以观察到网站可以进入，并且CSS样式加载正常 安装uwsgi 由于前面环境已经配置妥当，安装uwsgi只需要一句命令，请确保在虚拟环境当中 1pip install uwsgi 在网站根目录下执行 12uwsgi --http :8001 --plugin python --module Blog.wsgi# 其中Blog.wsgi需要自行替换成自己的网站名字，比如自己的网站APP为Test，则修改为Test.wsgi 通过访问IP地址加端口号进行测试，例如118.25.3.239:8001（例子虚拟，自行替换IP） 如果访问正常我们应该看到的是不带CSS样式的界面 配置uwsgi文件 为了让服务器可以运行，我们需要手动在根目录创建一个uwsgi.ini的文件 内容如下： 1234567891011121314[uwsgi]#chidr用于指定自己的网站根目录（自行更改）chdir = /home/ubuntu/Blog#module指定网站中APP的文件（自行更改）module = Blog.wsgi#home用于指定python的虚拟环境，即我们最初创建的虚拟环境位置（自行更改）home = /home/ubuntu/env27#master不用更改master = true#socket用于指定端口号，可以不更改socket = :8001#以下两个可以不用更改chmod-socket = 666vacuum = true 配置完内容之后可以在shell中运行，并访问网站观察十分成功运行 1sudo uwsgi --ini uwsgi.ini 配置nginx 安装过程很简单，一句命令 1sudo apt-get install nginx nginx安装完默认是启动的，可以通过直接在浏览器访问ip的方式观察到nginx的欢迎界面 这里我原先使用的Chrome浏览器，不知为何会强制重定向到https，导致网站无法访问 更换浏览器以后访问便正常了 推荐使用edge或者自带的ie进行简单的测试 nginx默认会读取/etc/nginx/sites-enabled/default文件中的配置，修改其中配置如下： 123456789101112131415161718upstream django &#123; server 127.0.0.1:8001; #此处端口可以替换，需与uwsgi.ini之中的端口一致&#125;server &#123; listen 80; server_name 118.25.3.239; #此处需要自行替换成自己的IP地址 charset utf-8; client_max_body_size 75M; #django配置文件 location /static &#123; alias /home/ubuntu/Blog/static; #此处需要自行替换为网站根目录下的静态文件夹 &#125; #以下不必改动 location / &#123; uwsgi_pass django; include /etc/nginx/uwsgi_params; &#125;&#125; 重启服务器 一切配置完毕之后，执行命令 1sudo /etc/init.d/nginx restart 浏览器中输入IP即可发现网站成功构建完毕 参考文章及视频文章 很详细的一篇文章 Ubuntu上通过nginx部署Django笔记视频 视频讲解非常透彻，如果一步一步跟着执行出错可能性极低 【教程】Nginx + uWsgi 部署 Django + Mezzanine 生产服务器(「自由小径」自由软件教程) - 1/2 【教程】Nginx + uWsgi 部署 Django + Mezzanine 生产服务器(「自由小径」自由软件教程) - 2/2]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective c++ 记录]]></title>
    <url>%2F2018%2F04%2F06%2FEffective-c%2B%2B-%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[改善程序与设计55个具体做法 防止阅后遗忘 再次记录易于遗忘的条款 条款2：尽量使用const，enum,inline替换#define 取一个const地址是合法的，但取一个enum，和#define的地址就不合法。 12enum &#123;NumTurn = 5&#125;;//近似看成#define NumTurn 5 单纯常量：最好以const对象或enum替换#define，对于宏，使用inline函数替换#define。 const出现在类型前面和类型和后面表达的意思相同，如下： 12345678910111213141516171819202122232425const int a;int const a;``` - const出现在指针\*前面代表物是常量，在\*后面代表指针自身是常量。- 如果一个变量申明有mutable，即便在const的成员函数当中，也可以修改。- const_cast的使用```cpp#include &lt;iostream&gt;using namespace std;int main()&#123; /*似乎发生了常量折叠，在编译阶段，对该变量进行值替换，同时，该常量拥有自己的内存空间，并非像宏定义一样不分配空间。*/ const int a = 20; int&amp; b = const_cast&lt;int&amp;&gt;(a); cout &lt;&lt; b &lt;&lt; endl; //20 b = 30; cout &lt;&lt; b &lt;&lt; endl; //30 cout &lt;&lt; a &lt;&lt; endl; //20 return 0;&#125; 条款4：确定对象被使用前已被初始化 使用local static对象替换non-local static对象，如下使用函数来唯一初始化一个对象：12345678class FileSystem&#123;...&#125;;FileSystem&amp; tfs()&#123; //使用static进行初始化，并返回该对象的引用 static FileSystem fs; return fs;&#125;//使用tfs()来获得该对象 条款6：若不想使用编译器自动生成的函数，就该明确拒绝 所有编译器默认生成的函数都属于public，如果不想使用他们，则应明确将其申明为private 使用专门的基类来防止被拷贝，如下：123456789class Uncopyable&#123;protected: Uncopyable()&#123;&#125; ~Uncopyable()&#123;&#125;private: Uncopyable(const Uncopyable&amp;); //参数名称可写可不写，反正不予实现。 Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;; 条款7：为多态基类声明virtual析构函数 对于大多数人的心得而言：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。 c++并没有禁止派生的机制，所以尽量不要继承STL容器，STL容器当中析构函数并非虚析构 条款8：别让异常逃离析构函数 析构函数绝对不要吐出异常，如果产生异常将导致异常之后的代码无法执行，会导致资源泄露 如果需要对异常做出反应，那么class应该提供一个普通函数（非析构函数）来处理异常 try中出现异常，try中的后继代码不执行，但是try之外的代码需要执行 使用如下代码将释放资源代码返回客户手上，并拥有双保险123456789101112131415161718192021222324252627class DBConn&#123;public: ... void close() &#123; db.close(); &#125; ~DBConn() &#123; if (!closed) &#123; try &#123; db.close(); &#125; catch (...) &#123; //制作运转记录，记下调用close失败的原因 ... &#125; &#125; &#125;private: DBConnection db; bool closed;&#125;; 条款09：绝不在构造和析构函数中调用virtual函数 由于基类的构造函数会先被调用，即如果在基类构造函数中有virtual函数，调用的是基类的函数，而非派生类的函数 对象在基类构造函数执行之前不会成为一个真正的对象（成品） 析构函数一旦开始执行，所有成员变量便成为未确定的值，所以virtual也被认为是基类的函数。 所以确保构造函数和析构函数当中没有虚函数，哪怕是他们调用的函数也要服从该约定 条款10：令operator=返回一个reference to *this 赋值操作符尽量返回的是reference to *this（this的引用），如 **return \this** 尽可能返回const的类型，可阻止用户因自定义类型而犯错 条款11：在operator=中处理“自我赋值“ 先查看一份不安全代码 1234567891011121314class Bitmap&#123;...&#125;;class Widget&#123;...private: Bitmap* pb;&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;// 一旦使用如上代码进行自我赋值，pb将会被销毁 传统的改进方法是增加”证同测试“，加入如下语句： 1if (this == &amp;rhs) return *this; 我们只需在复制pb时无需删除pb即可改进代码，如下 1234567Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 所以确定任何函数操作一个以上的对象时候，并且多个对象是同一个对象的时候，其行为依然正确。 条款12：复制对象时勿忘其每一个部分 在任何时候只要你承担起“为派生类编写构造函数的”责任，必须保证基类所有的成分都被复制。 由于大多数时候基类成员为private，所以应让派生类的构造函数调用相应的基类函数。 在派生类中重载=，需要对基类的成分同样将进行赋值，使用如下代码： 12345PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)&#123; //假设基类为Customer Customer::operator=(rhs);&#125; 在派生类构造函数当中调用copy assignment是不合法的，以至于根本没有这样的语法。 条款13：以对象管理资源 可以使用auto_ptr智能指针进行释放内存 1234567Investment* createInvestment();void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); &#125;// 多个auto_ptr不允许指向相同的对象// 若是通过拷贝构造函数或使用赋值运算符复制auto_ptr，它们会变成NULL auto_ptr的替代方案为shared_ptr，如下代码： 12345void f()&#123; std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());&#125;//shared_ptr允许复制 但是两个指针销毁时候都是使用delete，而不是delete[]，所以不允许指向动态分配而得的数组 条款15：在资源管理类中提供对原始资源的访问 shared_ptr和auto_ptr都提供一个get成员函数，可以用来显示转换，也就是可以返回智能指针内部的原始指针，假设如下代码： 1234int daysHeld(const Investment* pi);std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());int days = daysHeld(pInv); //错误的用法，需要Investment类型的指针，不是传递shared_ptr的对象int days = daysHeld(pInv.get()); //正确的用法 shared_ptr和auto_ptr也重载了运算符-&gt;和*，可以像平时指针一样使用。 条款16：成对使用new和delete时要采取相应的形式 为了避免一些潜在错误，尽量不要对数组使用typedef，如下代码：1234typedef std::string AddressLines[4];std::string* pal = new AddressLines;delete pal; //错误，是一个数组delete[] pal; //正确 条款17：以独立语句将newed对象置入智能指针 如果不这么做的话，一旦抛出异常，将造成指针指向未知位置，造成难以察觉的内存泄漏 条款18：让接口容易被正确使用，不易被误用 假设有如下不安全代码： 12345678class Date&#123;public: Date(int month , int day , int year); ...&#125;;//如果使用如下代码调用，将会导致使用方式出错Date d(30,3,1995); 改进了之后，代码如下： 123456789101112131415161718192021struct Day&#123; explicit Day(int d) : val(d) &#123;&#125; int val;&#125;;struct Month&#123; explicit Month(int d) : val(d) &#123;&#125; int val;&#125;;struct Year&#123; explicit Year(int d) : val(d) &#123;&#125; int val;&#125;;class Date&#123;public: Date(const Month&amp; m , const Day&amp; d, const Year&amp; y);&#125;;//如果使用这种方法创建就可以预防出错。 条款20：宁以pass-by-reference-to-const替换pass-by-value 使用引用(by reference)的方式可以避免对象切割(slicing)的问题 。 条款21：必须返回对象的时候，别妄想返回其reference 假设有如下代码： 123456const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)&#123; Rational result(lhs.n * rhs.n , lhs.d * rhs.d); return result;&#125;//一旦函数结束了之后，result被释放，返回引用将被定义为不明确的行为 再看如下代码，以下代码试图完善上文代码: 123456const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)&#123; Rational* result = new Rational(lhs.n * rhs.n , lhs.d * rhs.d); return *result;&#125;//代码看似可以完成任务，确无法决定谁对代码进行delete 条款22：将成员变量声明为private 如果不出意外尽量都将成员变量声明为private。 protected并不比public更具封装性 条款23：宁以non-member,non-friend替换member函数 面对对象守则要求，数据以及操作数据的那些函数应该被捆绑在一块，这句话其实并不正确。 如果使用成员函数，则对类有较大的操纵权限，所以可以考虑友元函数或者普通函数进行操纵成员。]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux小记]]></title>
    <url>%2F2018%2F03%2F15%2Flinux%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[偶然发现自己一些常用的命令经常忘记 在此做一些笔记 记录学习linux的琐事 fsck修复 如果文件系统损坏，出现分区受损，可以使用如下命令，结束后使用reboot重启 1fsck -y /dev/sdXX #第一个X指的是硬盘，第二个X指的是分区 如果不知道哪个分区受损，直接使用fsck修复就好了 文件权限变更 以下三个命令可以使用-R参数进行递归操作 使用chgrp变更组 使用chown变更所有者 使用chmod变更权限 w权限主要用于修改目录，增删文件这类操作，而r用于查看目录，最后x用于是否可以进入这个目录 用户管理增加用户 使用useradd 添加用户，常用选项如下： 1234567-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。用户名 指定新账号的登录名。 可以使用如下代码生成一个用户 1useradd -d /home/test -m test -s /bin/bash 修改用户 常使用：usermod 选项 用户名 来改变一个用户的属性 Vim强行保存 如果以普通用户编写了文件，但是发现权限不足时，可以使用强行保存：1:w !suod tee % python快速开httpserver 使用如下命令：1python3 -m http.server]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习记录]]></title>
    <url>%2F2018%2F03%2F05%2FC%2B%2B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学校课程新增C++ 记录易错知识点以及易忘知识点 大坑待填 cout有控制符，如转换进制的如下： 1234cout &lt;&lt; hex &lt;&lt; ;hex 十六进制oct 八进制dec 十进制 const 与 #define 不同，它拥有存储单元，有地址，指针可指向它。建议取代define. const在指针的不同位置： 1234567const char* name = "chen"; //当const位于类型前面的时候，内容不允许改变，指针指向的地址可以改变。name[3] = 'o'; //不允许name = "hello"; //允许char* const name = "chen"; //当const位于类型后面的时候，代表常指针，指针所指向的地址不允许改变。name[3] = 'o'; //允许name = "hello"; //不允许 const常用于操作数组时，不改变数组内容。 函数省略类型时，默认为int。 inline内联函数定义必须在头文件中实现。 函数指定默认值的参数必须放在最右侧，以便达到一一对应。 函数重载以参数个数及其类型判断，即可以参数个数相同，类型不同。返回值类型不参与判断！！！ 可以使用::访问全局变量，如下： 123456int x;int main()&#123; int x; cout &lt;&lt; ::x;&#125; union可以有多个成员，但是只能使用一个成员变量。 使用new进行分配空间时，需要提供所有维大小。（待定） 引用必须初始化，可以作为返回值。 不允许建立void类型的引用，不能建立引用的数组。 引用不是一种数据类型，指针是。所以没有引用的引用，也没有引用的指针。 结构体成员变量默认为public，而类默认为private。 C++推荐在类外定义函数，如果在类内定义函数，则默认为inline内联函数。 在类声明中，不允许对数据成员赋值。 类在实例化对象时，不允许加括号，如下 12CPeople xiaoming(); //不允许，这代表实例化一个CPeople的函数CPeople* xiaohong = new CPeople(); //允许，并且推荐这种写法。 构造函数是没有返回值，哪怕是void。 const对象以及引用对象，必须在构造函数的初始化列表中进行初始化。 数据成员是按照类中声明顺序进行初始化，而与初始化中的列表无关。（重要） 析构函数不允许被重载。 类数组，如果只有一个成员数据，可以使用大括号进行初始化。如果两个参数，可以如下： 1CPeople pep[3] = &#123; CPeople(1,2) , CPeople(2,3) , CPeople(3,4) &#125;; 在写一个函数的时候，尽量为其完善构造函数，拷贝构造，析构函数。 使用拷贝构造时，默认使用浅拷贝，如果遇到指针在里面，需要注意指针，使用深拷贝。即构造函数参数为：const&amp; 类名。 调用拷贝构造有三种情况。 1231.一个类初始化另一个类2.函数的参数是类的对象3.函数的返回值是类的对象 一个类多个对象数据共享，需要使用静态成员。 静态成员应在类外初始化，并且在定义对象前就必须初始化完毕。不允许被初始化列表初始化（重要） 静态成员函数主要用于访问静态数据成员。并且如果是private，则不能被外部访问。 静态成员函数没有this指针，并且只能通过对象名来访问静态成员。（重要） 类外定义友元函数，可以不必加上类名，只需保证参数相同。友元函数必须通过入口参数传递进对象名。 友元关系是单项的，不具备交换性。 子类调用构造函数时，如果父类也有构造函数，需要在子类构造函数初始化列表中为父类初始化。 如果将一个对象申明为常对象(类名 const 名字)，则不能调用该对象的非const的成员函数，否则报错。常成员函数例子如下：void print() const; 常成员函数只能用于类中，并且可以和同名非常函数进行重载。 继承如果不指定类型，默认以private继承。 子类可以继承父类的private成员，但是需要父类提供的public函数才能访问。 如果一个函数的参数为int&amp; ，则它不可以传入类似i3这样的变量。如果这样做了，在内部可以近似认为生成了一个const int&amp; temp@ = i\3。所以如果参数为const int&amp;，则可以传入不报错。 static在c++和c中有细微的差别，如果在C中加上static代表只能在本文件中访问。 在运算符重载当中，如果运算符右边为整数，则会尝试调用重载函数参数中类的构造函数。（重要，可以使用构造函数将数字转换成类对象） 继承当中，如果父类成员是private，不管使用哪一种继承限定词，子类都是无法直接访问父类成员。 C++推荐使用int(a)这种方式进行强制转换，而不是使用(int)a，进行强制转换，前者更像调用一个函数。 explicit在构造函数之前添加，可以告诉编译器这就是一个构造函数，不能用来强制转换。 operator 目标类型() ，可以用来指定数据类型转换为类的对象 构造函数首先调用基类，然后是类对象成员，最后是派生类的构造函数体。 父类指针可以指向子类，但是只能访问子类从父类继承而来的成员。 虚函数必须是成员函数，不能是友元函数或者是静态成员函数。因为需要特定的对象才能激活虚函数。 输入输出流拥有各种成员函数： 12345cout.put() //输出字符，可以是ASCII码cin.get() //读取一个字符cin.getline() //读取一行cin.ignore(n,终止字符) //跳过n个字符读取，可以只含一个参数//.... 流成员函数进行格式控制： 12345setf(flags) //设置格式unsetf(flags) //取消格式width(n) //指定宽度fill(ch) //填充字符precision(n) //设置小数精度 数组作为函数参数时候，如果使用sizeof计算其大小，会得到指针的大小。 在VC6.0的时候，输入输出流返回必须是引用，因为ostream和istream对象是不可复制的。 函数调用选择顺序如下：非模板函数，显式具体化，模板函数。显式具体化的例子: 1234567891011121314151617181920212223include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;void swaper(T&amp; a , T&amp; b)&#123; T temp = a; a = b; b= temp; return;&#125;template&lt;&gt; void swaper&lt;double&gt;(double&amp;a , double&amp; b)&#123; cout &lt;&lt; a + b &lt;&lt; endl;//调用&#125;int main()&#123; double a = 10 , b = 20; swaper(a,b); //显式具体化后，调用的其实是cout&lt;&lt; a+b; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b; system("pause"); return 0;&#125; const修饰的成员函数可以改变static的变量，因为static变量储存在静态区而不属于类。 使用string类，如果使用&lt;或&gt;比较符，是从左往右比较，与字符长度大小无关 拷贝构造时，基类会被调用，需要自己在初始化列表中调用 引用不允许指向不同的对象，独一无二。 对象在基类构造函数执行之前不会成为一个真正的对象（成品） 析构函数一旦开始执行，所有成员变量便成为未确定的值 namespace和classes不同，namespace可以跨越多个文件，但是classes不行 在类当中，子类是无法赋值给父类，反之可以 c++实现多态引用同样可以实现 一旦继承中出现虚基类，以后继承皆为虚基类（待定） ostream对象不允许拷贝构造，即返回值必须为ostream&amp; operator++为前置运算符，operator++(int)为后置运算符 12345678//exampleclass Base;Base Base::operator++(int)&#123; Base t(*this); this-&gt;num++; return t;&#125; 缺省构造函数即代表没有参数列表的构造函数，一旦手动定义带参数的构造函数，编译器则不会帮我们生成缺省的构造函数]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易Socket编程]]></title>
    <url>%2F2018%2F02%2F28%2F%E7%AE%80%E6%98%93Socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进行简单的socket编程尝试 使用C++和python分别编写服务端与客户端 简单传输文本 代码编写随意，仅供回忆 编程步骤服务端 加载套接字(WSAStartup()) 绑定套接字到IP和端口上(bind()) 设置为监听模式(listen()) 接收到请求后，返回本次请求所对应的套接字(accept()) 发送与接受数据(send()/recv()) 关闭套接字(WSACleanup()) 客户端 加载套接字(WSAStartup()) 发出连接请求(connect()) 发送与接受数据(send()/recv()) 关闭套接字(WSACleanup()) 记录代码C++服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;WinSock2.h&gt;#include &lt;iostream&gt;/*静态加入Lib文件，编译时需加上-lwsock32*/#pragma comment(lib,"ws2_32.lib")int main(void)&#123; WORD sockVersion = MAKEWORD(2, 2); //指定socket版本号 WSADATA wsaData; /*初始化socket库*/ if (WSAStartup(sockVersion, &amp;wsaData)!=0) &#123; return 0; &#125; /*创建套接字*/ /*第一个参数指定IPv4，第二个参数指定流式传输，适用tcp，第三个参数指定tcp协议，设置为0将自动判断*/ SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sin; sin.sin_family = AF_INET; //指定协议 sin.sin_port = htons(6000); //必须采用网络数据格式，使用htons来包装 sin.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); /*进行绑定*/ if (bind(slisten, (SOCKADDR*)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; "bind error ! " &lt;&lt; std::endl; &#125; /*5为等待连接数目*/ if (listen(slisten, 5) == SOCKET_ERROR) &#123; std::cout &lt;&lt; "listen error" &lt;&lt; std::endl; &#125; /*接受数据*/ SOCKET sClient; sockaddr_in remoteAddr; char revData[255]; int nAddrlen = sizeof(remoteAddr); while (true) &#123; std::cout &lt;&lt; "等待连接" &lt;&lt; std::endl; sClient = accept(slisten, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrlen); std::cout &lt;&lt; "连接成功" &lt;&lt; std::endl; send(sClient, "连接成功" , sizeof("连接成功"), 0); int ret = 1; //为下面接受数据判断 while (ret &gt; 0) &#123; ret = recv(sClient, revData, 255, 0); std::cout &lt;&lt; revData &lt;&lt; std::endl; &#125; &#125; return 0;&#125; python服务端12345678910111213141516import socketHOST = "127.0.0.1"PORT = 50007s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.bind((HOST,PORT))s.listen(1)print("服务器正在运行\n")while True: conn,addr=s.accept() print("connected by %s" %&#123;addr&#125;) conn.send(b'hello') while True: data = conn.recv(1024) print(data.decode("utf-8")) input_data = input("") conn.send(bytes(input_data,"utf-8")) python客户端123456789101112131415import socketimport chardetHOST = "127.0.0.1"PORT = 6000s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((HOST,PORT))while True: rec = s.recv(1024) L = chardet.detect(rec) code = L['encoding'] print(rec.decode(code)) cmd = input('Please input data:') cmd = bytes(cmd,"gb2312") s.send(cmd) s.close()]]></content>
      <categories>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息安全铁三赛write_up]]></title>
    <url>%2F2018%2F01%2F19%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%93%81%E4%B8%89%E8%B5%9Bwrite-up%2F</url>
    <content type="text"><![CDATA[信息安全铁三赛write_up 题目共有六题 随手记录 权限 题目描述：你是管理员吗？ 解题链接：http://ctf4.shiyanbar.com/web/root/index.php 答案格式：flag{} 步骤 首先先浏览网页源代码，易于发现在源代码底部有提示如下： 1&lt;!--password.txt&gt; 可以发现存在password.txt，在地址栏构造出地址如下： 1http://ctf4.shiyanbar.com/web/root/password.txt 可以进入包含一个许多密码的页面，由此可以推测出密码是其中的一个。 密码框长度默认只有5个长度，手动用审查元素找到maxlength=5，将数据改成999 由于密码过多，我们可以需要使用buresuite进行爆破，使用教程可以参考:使用教程 通过爆破以后，我们可以发现Nsf0cuS这个密码有些与众不同。它的提示是这里没有flag哦！ 再次抓包发现Response当中有一项： 1Set-Cookie: newpage=MjkwYmNhNzBjN2RhZTkzZGI2NjQ0ZmEwMGI5ZDgzYjkucGhw; 使用base64解码后得到一个php文件，如下： 1290bca70c7dae93db6644fa00b9d83b9.php 构造URL后可以看到小黑留言板，再次抓包尝试 通过分析发现Cookie中有个IsLogin=0这个参数，并且userlevel为guest 将IsLogin改为1，userlevel改为root，点击go再次尝试 可以得到flag为： 1Flag=flag%7BC0ngratulati0n%7D 使用url解码得到flag为 1Flag=flag&#123;C0ngratulati0n&#125; IOS 题目描述：无 解题链接：http://ctf4.shiyanbar.com/web/IOS/index.php 答案格式：flag{} 步骤 通过界面可得系统已经升级到ios99，可以通过抓包修改user-agent来更改所需系统 user-agent如下： 1User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 99 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A5313e Safari/7534.48.3 发送后得到flag为： 1flag&#123;LMvBi8w9$m1TrgK4&#125; 照猫画虎 题目描述：照猫画虎 解题链接：http://ctf4.shiyanbar.com/web/copy/index.php 答案格式：flag{} 步骤 通过界面可知1234567890th的访客可以得到奖励，当前是2699th的访客 抓包分析，发现Request中存在如下： 1Visitor=MjY5OTowNDE1NzQwZWFhNGQ5ZGVjYmM4ZGEwMDFkM2ZkODA1Zg%3D%3D; 先使用url解码，再使用base64解码发现如下： 12699:0415740eaa4d9decbc8da001d3fd805f 分析发现冒号后面可以使用MD5解密，解密得到答案为2699，也就是最终结果为： 12699:2699 使用1234567890逆向加密回去，可得 11234567890:e807f1fcf82d132f9bb018ca6738a19f 再使用base64和url加密，可得 1MTIzNDU2Nzg5MDplODA3ZjFmY2Y4MmQxMzJmOWJiMDE4Y2E2NzM4YTE5Zg%3D%3D 使用buresuite改变Visitor的值为如上密码，发送后可得flag为： 1flag&#123;T4mmL9GhpaKWunPE&#125; 问题就在这 题目描述：找答案 GPG key: GhairfAvvewvukDetolicDer-OcNayd# 解题链接：http://ctf4.shiyanbar.com/ste/gpg/john.tar.gz.gpg 答案格式：flag{} 步骤 首先下载下来解题文件，由题意可得这个文件通过GPG加密，并且密钥已经给出 打开gpg4win这个软件，使用如上密钥，可以解密出文件john.tar.gz，解压后得到john.tar，发现还是个压缩包，再次解压可以得到john-in-the-middle.pcap这个数据包文件。 使用WireShark打开这个数据包，观察到其中有许多PNG图片，点击上方文件，导出对象，HTTP来导出所有文件，得到一堆文件 使用Stegsolve来逐个分析图片文件，可得到flag为：1flag&#123;J0hn_th3_Sn1ff3r&#125; 你最美 题目描述：无 解题链接：http://ctf4.shiyanbar.com/misc/123/123.exe 答案格式：flag{} 步骤 首先下载题目文件，并拖入winhex进行分析，发现它是一个png图片，并使用base64加密。 使用在线图片转换base64工具，将winhex的内容全部复制进去，可以还原出一个二维码，扫描后可得flag为：1flag&#123;you are beautiful&#125; shellcode 题目描述：无 解题链接：http://ctf4.shiyanbar.com/re/shellcode/shellcode.txt 答案格式：flag{} 步骤 首先打开题目所给的链接，发现如下字符串: 1\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x34\x00\x00\x00\x65\x63\x68\x6f\x20\x5a\x6d\x78\x68\x5a\x33\x74\x54\x53\x45\x56\x73\x62\x47\x4e\x76\x5a\x47\x56\x66\x53\x56\x4e\x66\x63\x32\x39\x66\x51\x32\x39\x76\x62\x48\x30\x4b\x7c\x62\x61\x73\x65\x36\x34\x20\x2d\x64\x00\x57\x53\x89\xe1\xcd\x80 使用chrome的控制台，使用如下语句 1alert("\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x34\x00\x00\x00\x65\x63\x68\x6f\x20\x5a\x6d\x78\x68\x5a\x33\x74\x54\x53\x45\x56\x73\x62\x47\x4e\x76\x5a\x47\x56\x66\x53\x56\x4e\x66\x63\x32\x39\x66\x51\x32\x39\x76\x62\x48\x30\x4b\x7c\x62\x61\x73\x65\x36\x34\x20\x2d\x64\x00\x57\x53\x89\xe1\xcd\x80") 可以得到字符串如下： 1j XRfh-cçh/sh h/binãRè4 echo ZmxhZ3tTSEVsbGNvZGVfSVNfc29fQ29vbH0K|base64 -d WSáÍ 分析可得下面代码是使用base64位加密的： 1ZmxhZ3tTSEVsbGNvZGVfSVNfc29fQ29vbH0K 解密后可得flag为： 1flag&#123;SHEllcode_IS_so_Cool&#125;]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>write_up</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT自学之路（一）]]></title>
    <url>%2F2018%2F01%2F01%2FQT%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QT作为一个图形库，可以以简单的代码构造出图形界面 在此记录QT的学习记录 内容较长，大坑待填 QDialog 对话框有模态与非模态对话框 模态对话框窗口置顶，必须先点击它 1234567//模态对话框QDialog dialog(this);dialog.exec();//非模态对话框QDialog * dialog = new QDialog(this);dialog-&gt;show();//dialog-&gt;setModal(ture);这种写法也可创建模态对话框 QDialog如果按下后，QDialog.exec() == QDialog::Accepted 颜色对话框 包含在 QColorDialog头文件当中1QColor color = QColorDialog::getColor(Qt::red,this,"颜色对话框"); 文件对话框 包含在 QFileDialog头文件当中123//返回文件路径QString filename = QFileDialog::getOpenFileName(this,"文件对话框","D","文件图片(*.jpg *.png");qDebug() &lt;&lt; "filename is :" &lt;&lt; filename &lt;&lt; endl; 字体对话框 包含在 QFontDialog头文件当中1234567891011121314bool ok;QFont font = QFontDialog::getCont(&amp;ok,this);if (ok)&#123; ui-&gt;pushButton-&gt;setFont(font); else qDebug() &lt;&lt; "没有选择字体";&#125;## 输入对话框- 包含在头文件 QInputDialog当中```cppbool ok;QString string = QInputDialog::getText(this,"输入字符串对话框","请输入用户名",Q)LineEdit::Normal,"admin",&amp;ok); 消息对话框 包含QMessageBox头文件中1int ret1 = QMessageBox::question(this,"问题对话框","你了解qt吗？",QMessageBox::Yes,QMessageBox::No); 进度对话框 包含在 QProgressDialog当中 一般是模态对话框，如果要非模态对话框，需要借助定时器的帮助1234567891011121314//QProgressDialog* dialog = new QProgressDialog("文件对话框","取消",0,100,this);QProgressDialog dialog("文件复制进度","取消",0,50000,this);//dialog-&gt;show();dialog.show();for ( int i = 0 ; i &lt; 500000 ; i++)&#123; dialog.setValue(i); QCoreApplication::processEvents(); if (dialog.wasCanceled()) &#123; break; &#125;&#125;dialog.setValue(50000) 信号与槽 槽一般以public slot修饰，写在头文件当中，在源文件中实现定义 可以使用alt+enter来快速添加定义 使用connect来连接，具体代码如下123456//button是一个指针变量//第二个参数是按钮自带的选项//第三个参数代表按钮与当前窗口相连接//第四个参数代表已经定义的槽函数//复杂点说依次为：发射信号的对象，发射的信号，接受信号的对象，要执行的槽函数connect(button,&amp;QPushButton::clicked,this,&amp;MainWindow::showChildDialog); QLabel]]></content>
      <categories>
        <category>QT学习记录</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>图形</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++STL初步]]></title>
    <url>%2F2017%2F12%2F11%2FC%2B%2BSTL%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[竞赛中常用到STL模板库来提升速度 在此记录平日里做题用到的常用的函数及其模板 大坑待填 sort函数 函数包含在algorithm头文件中 sort可以对任意对象进行排序，默认以元素从小到大进行排序12345678910111213141516171819202122vector &lt;int&gt; vect;sort(vect.begin(),vect.end());//或者int num[10];sort(num,num+10);/* 运行自定义函数进行排序 */bool cmp(int a, int b)&#123; return a &gt; b; // a&gt;b为true,不交换 // a&lt;b为false,交换&#125;sort(num,num+10,cmp);/* 允许使用其他模板进行排序 */equal_to 相等not_equal_to 不相等less 小于 greater 大于 less_equal 小于等于greater_equal 大于等于sort(num,num+1,greater&lt;int&gt;()); lower_bound 以及 upper_bound函数 函数包含在algorithm头文件中 查找第一个大于或者等于x的第一个位置 查找最后一个大于或者等于x的第一个位置12int num[10];int tmp = lower_bound(num,num+10); 不定长数组vector 函数包含在vector头文件中123456789vector&lt;int&gt; a; //申明一个向量vector&lt;int&gt; a(10); //申明一个向量包含十个元素vector&lt;vector&lt;int&gt;&gt; a; //申明一个二维向量a.size(); //读取大小a.resize(); //改变大小a.push_back(); //向尾部添加元素a.pop_back(); //删除尾部元素a.clear(); //清空向量，只清空内容，不包括大小//允许使用下标进行赋值运算等 set集合 函数包含于set头文件中1234567891011set &lt;string&gt; s;begin() //返回set容器的第一个元素end() //返回set容器的最后一个元素clear() //删除set容器中的所有的元素empty() //判断set容器是否为空max_size() // 返回set容器可能包含的元素最大个数size() //返回当前set容器中的元素个数rbegin() // 返回的值和end()相同rend() // 返回的值和rbegin()相同count() // 判断是否存在，0，1erase() //删除元素 map映射 函数包含于set头文件中1234567map &lt;string,int&gt; mouth_name //表示月份名字到月份编号mouth_name["july"] = 7;map&lt;string,int&gt;::iterator it;for ( it = mouth_name.begin (); it != mouth_name.end();++it)&#123; //允许通过it-&gt;first或者it-&gt;second来访问数据&#125; 栈 包含在stack头文件中123456push() //将元素压入栈顶pop() //将元素弹出top() //访问栈顶元素empty() //判断是否栈空size() //返回元素个数stack&lt;int&gt; s; //声明一个栈 队列 包含在queue头文件中1234567push() //将元素入队pop() //将元素出队front() //取队首元素但不删除back() //取队尾元素但不删除empty() //判断是否栈空size() //返回元素个数queue&lt;int&gt; s; //声明一个队列 优先队列1234567priority_queue&lt;int&gt; pq; //数字越大优先级越大pq.top() //访问优先级最高的元素pq.push() //入队pq.pop() //出队/* 定义优先级 */prioiry_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; //数字越小优先级越大，最小堆/* greater 大的在底下 less小的在底下]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全工具]]></title>
    <url>%2F2017%2F10%2F23%2Fweb%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[根据网易web安全工程师所做笔记 记录学习之路 前文完结 本文为第三章 大坑待填 浏览器拓展初级 可以将阻止弹出式窗口关闭，便于测试 Firefox四个插件 Firebug HackBar Advanced Cookie Manager Proxy Switcher #代理的工作原理 “代理”可对经过的数据包进行记录，拦截，修改，再次发送，丢弃等操作 ##浏览器的代理设置 可以手动设置 常用HTTP代理工具：Burpsuite ， Charles ， Fiddler #敏感文件探测实践 猜测文件名，根据返回的HTTP状态码判断文件是否存在 200：文件存在 301：文件发生跳转 用”御剑”扫描敏感文件 通过判断index的文件类型确定网站脚本类型，如在网址中访问index.asp、index.php、index.aspx、index.jsp来选择字典]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>安全</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全基础]]></title>
    <url>%2F2017%2F10%2F21%2Fweb%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[根据网易web安全工程师所做笔记 记录学习之路 前文完结 本文为第二章 大坑已填 利用搜索引擎关键字 intitle:Hacked by //网站被黑关键字，不过是黑客为了炫耀罢了 intitle:keyword //标题中含有关键字的网页 intext:keyword //正文中含有关键字的网页 site:域名 //搜索某个域名或者子域名的网页 暗链 隐藏在网站当中链接 网游/医疗/博彩/色情 针对搜索引擎，提高在搜索引擎的排名（SEO） Webshell 网页 功能强大（大部分的命令操作） asp/php/jsp 后门程序 XSS什么是XSS? Cross Site Script 跨站脚本 危害：盗取用户信息，钓鱼，蠕虫 针对前端语言的注入，可以盗取CookieXSS分类？存储型 访问网站，触发XSS 从数据库中提取XSS反射型 主动访问携带XSS脚本的链接 触发XSSDOM型 主动访问携带XSS脚本的链接 触发XSS CSRF漏洞 Cross-site request forgery 跨站请求伪造 危害：执行恶意操作（转账，制造蠕虫等） 利用用户已登录的身份，在用户毫不知情的情况下，以用户名义完成操作 点击劫持漏洞 通过覆盖不可见的框架进行攻击 隐蔽性高 骗取用户操作 UI-覆盖攻击 利用iframe或者其他标签的属性 URL跳转漏洞 Header头跳转 Javascript跳转 META标签跳转 http://www.熟悉链接.com?url=www.诈骗网站.com SQL注入 常见web安全漏洞，攻击者利用这个漏洞，可以访问和修改数据，或者利用数据库漏洞攻击 必备条件 可以控制输入的数据 服务器要执行的代码拼接了控制的数据 数据和代码未分离，即数据当成代码来执行 危害 获取服务器权限 植入Webshell 读取服务器敏感文件 万能密码 命令注入 调用可执行系统命令的函数 函数或函数的参数可控 拼接注入命令 文件操作漏洞文件上传漏洞- 上传头像 - 上传附件 &gt; - 文件处理不当 - 可以上传可执行脚本 - 脚本拥有执行权限 任意文件下载- 下载APP - 下载附件 &gt; - 没有验证请求文件名 &gt; - 没有限制请求路径 文件包含漏洞- 本地文件包含 - 远程文件包含]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>安全</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web基础知识]]></title>
    <url>%2F2017%2F10%2F21%2Fweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[在不断打代码的过程中，消遣生活 丰富课余生活 记录web安全学习之路 根据网易web安全工程师课程所作笔记 本文为第一章 大坑已填 web是什么？ World Wide Web 万维网 非常普遍的互联网应用 平时流量的网页 经历了Web1.0，Web2.0等阶段 Web1.0主要是静态页面 Web2.0类似于博客等页面 web的工作流程 通过dns请求，发送域名到dns服务器，得到解析后的ip地址，然后便可以通过解析完毕的ip地址来访问一个网址。 url的详细格式 schema://host[:port#]/path/…/[?query-string][#anchor] schema：底层协议，如:http,https,ftp host：服务器域名或者IP地址 port： 端口，默认80端口 path： 访问资源的路径 ?query-string： 发送给http服务器的数据 anchor： 锚 什么是HTTP? web使用的协议，即超文本传输协议 应用最广泛，web基础 Hyper Text Transfer Protocol什么是HTTPS? 可以简单来说，HTTPS = HTTP + SSL 相对于HTTP来说，HTTPS更为安全 HTTP标准端口是80，HTTPS标准端口则为443 HTTP无需加密，HTTPS对传输的数据进行加密 HTTP无需证书，HTTPS需要认证证书 Javascript Bom 警告弹窗 alert() 确认弹窗 confirm() 提示弹窗 prompt() Bom浏览器对象模型 以后测试可能会用到 检验是否有漏洞 建议熟记 HTML常用标签1234567891011121314151617181920&lt;h1&gt;&lt;/h1&gt; 标题标签，最多到&lt;h6&gt;&lt;/h6&gt;，标题依次从大小&lt;p&gt;&lt;/p&gt; 段落标签，浏览器会自动已排版的格式&lt;a href="https://www.baidu.com"&gt;用了href属性&lt;/a&gt; 链接标签&lt;img src="path" width=数字 height=数字 /&gt; 插入图片的标签&lt;!--注释--&gt; 注释标签&lt;hr /&gt; 插入水平线&lt;br&gt; 换行标签&lt;b&gt; 文本加粗标签&lt;strong&gt; 文本加粗标签&lt;big&gt; 文本放大标签&lt;em&gt; 文本斜体标签&lt;small&gt; 文本缩小标签&lt;sub&gt;&lt;/sub&gt; 文本下标标签&lt;sup&gt;&lt;/sup&gt; 文本上标标签&lt;del&gt;&lt;/del&gt; 文本删除线标签&lt;ins&gt;&lt;/ins&gt; 文本下划线标签&lt;pre&gt;&lt;/pre&gt; 文本格式化标签，允许控制空行和空格&lt;a href="mailto:webmaster@example.com"&gt;Mr L&lt;/a&gt; 邮箱标签&lt;!--大坑待填--&gt; 自定义本地host windows系统下，hosts文件默认在：C:\Windows\System32\drivers\etc目录下 linux系统下，hosts文件则在 /etc/hosts 可以通过输入IP + 网址来解析 ， 如下 192.168.1.138 www.testweb.com Mysql操作 SQL对大小写不敏感，分号代表语句结束12345678910111213141516171819202122CREATE DATABASE 数据库名字; #创建数据库show databases; #查看数据库USE 数据库名字; #使用数据库DROP DATABASE 数据库名字; #删除数据库SELECT database(); #打印当前数据库名称SELECT current_user(); #打印当前登录用户名SELECT load_file(path); #打开文件----------------分割线-----------------/*创建数据表*/CREATE TABLE 表名&#123;id int(4), name char(20), sex char(20)&#125;;/*查看数据表*/show tables;/*查询数据表*/SELECT * FROM 表名; #后面可选WHERE id = 1 and name = "LY";等类似句子 /*插入数据表*/INSERT INTO 表名(name,sex) VALUES("大风烈酒孤独自由","Malo"); #id可以自增长/*更新数据*/UPDATE 表名 SET name = "LY" WHERE id = 1;/*删除数据*/DELETE FROM 表名 WHERE name = "LY";#大坑待填]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>安全</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法小记]]></title>
    <url>%2F2017%2F10%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[当刷OJ日益困难的时候 我意识到我需要自学数据结构和算法了 特开一篇小文章记录所学笔记 更新缓慢，大坑待填 时间复杂度 时间复杂度可以忽略较小的常数 快速幂取余算法 假设题目为 a^b mod c常规算法 这种算法一般来说都会超时 123456int ans = 1;for(int i = 1;i&lt;=b;i++)&#123; ans = ans * a;&#125;ans = ans % c; 核心公式： a^b mod c = (a mod c) ^ b % c 所以我们可以将代码进行如下优化 1234567int ans = 1;a = a % c;for(int i = 1;i &lt;= b; i++)&#123; ans *= a;&#125;ans = ans % c; 但是尽管进行优化之后，效率依然很低 如果某个因子取余之后，再相乘，再取余，所得的结果不变。 我们可以继续优化代码 1234567int ans = 1;a = a % c;for ( int i = 1 ; i &lt;= b ; i++)&#123; ans = (ans * a) % c;&#125;ans = ans % c; 快速幂算法 a ^ b mod c = (a^2)^(b/2) mod c b是偶数 a ^ b mod c = ((a^2)*a) mod c b是奇数12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; long long a , b , c; long long ans = 1; scanf("%I64d %I64d %I64d",&amp;a,&amp;b,&amp;c); while ( b &gt; 0 ) &#123; if ( b % 2 == 1) &#123; ans = (ans * a ) % c; &#125; b /= 2; a = (a * a) % c; //将a不断递归下去 &#125; printf("%I64d",ans); system("pause"); return 0; 桶排序简易桶排序 来看如下示例，输入几个数字，将它从小到大排列而出：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[11] = &#123;0&#125;; int i = 0; int j = 0; int a; for (i = 0 ; i &lt; 5 ; i++) &#123; scanf("%d",&amp;a); num[a]++; &#125; for ( i = 0 ; i &lt; 11 ; i++) &#123; if (num[i] == 0) &#123; continue; &#125; for ( j = 0 ; j &lt; num[i] ; j++) &#123; printf("%d ",i); //出现几次就输出几次 &#125; &#125; system("pause"); return 0;&#125; 这里采用了使用数组下标的方法，数组下标对应出现的数字。 从大到小或从小到大只取决于循环的开始 此版本为简易桶排序，只对数字排序，并不对个体进行排序z，且十分浪费空间 冒泡排序 若有N个数字，冒泡排序的执行次数为n-1次，每一次都从头开始比较。 内层循环考虑到排序完最后一位已经是最小的，循环次数可以相应减少。 如下示例，代码有缺陷，0不进行排序，可修改： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[5] = &#123;0&#125;; int i = 0; int j = 0; int temp; //储存临时变量 for (i = 0 ; i &lt; 5 ; i++) &#123; scanf("%d",&amp;num[i]); &#125; for (i = 0 ; i &lt; 5 ; i++) //循环次数取决于要排序的数字 &#123; for ( j = 0 ; j &lt; 5-i ; j++) //内层循环为冒泡排序，通过比较两个数字的大小，来交换他们的位置 &#123; if (num[j] &lt; num[j+1]) &#123; temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125; &#125; for ( i = 0 ; i &lt; 5 ; i++) &#123; if (0 == num[i]) &#123; break; &#125; printf("%d ",num[i]); &#125; system("pause"); return 0;&#125; 修正冒泡排序 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; printf("please input a num:"); int n; scanf("%d",&amp;n); float num[n]; int i = 0; int j = 0; int temp = 0; for (i = 0 ; i &lt; n ; i++) &#123; scanf("%f",&amp;num[i]); &#125; for ( i = 1 ; i &lt;= n-1 ; i++ ) &#123; for ( j = 0 ; j &lt; n-i ; j++) &#123; if (num[j] &lt; num[j+1]) &#123; temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125; &#125; for (i = 0 ; i &lt; n ; i++) &#123; printf("%.2f ",num[i]); &#125; system("pause"); return 0;&#125; 快速排序 桶排序浪费空间，冒牌排序浪费效率 于是，人们找到了既不浪费空间，又不浪费时间的算法 来看如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void quick_sort(int left , int right , int *num) //传入数组，左基准数&#123; if (left &gt; right) &#123; return; &#125; int i = left; //定义两个变量，分别指向左右端点，进行移动。 int j = right; int temp; //用于交换两个数值 int t = num[left]; //储存左奇数 while ( i != j) &#123; for ( ; j &gt; i ; j--) //从右端先起步，一旦碰到小于基准数，记录下标j &#123; if (num[j] &lt; num[left] ) &#123; break; &#125; &#125; for ( ; i &lt; j ; i++) //从左端起步，一旦碰到大于基准数，记录下标i &#123; if (num[i] &gt; num[left]) &#123; break; &#125; &#125; if ( i &lt; j ) //下标位置交换，i必须小于j &#123; temp = num[i]; num[i] = num[j]; num[j] = temp; &#125; &#125; num[left] = num[i]; //最后将基准数与i,j相遇位置交换 num[i] = t; quick_sort(left,i-1,num); //进行递归，对基准数左右进行排序 quick_sort(i+1,right,num);&#125;int main(void)&#123; int n; scanf("%d",&amp;n); int *num = (int*)malloc(sizeof(int) * n); int i = 0; for ( i = 0 ; i &lt; n ; i++) &#123; scanf("%d",&amp;num[i]); &#125; quick_sort(0,n-1,num); for ( i = 0 ; i &lt; n ; i++) &#123; printf("%d ",num[i]); &#125; system("pause"); return 0;&#125; 队列 队列是一种特殊的线性结构，只允许头进尾出。 来看如下代码： 123456struct queue&#123; int data[1000]; int head; int tail;&#125;; 这代表队列 再看如下示例：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct queue //初始化队列&#123; int data[1000]; int head; int tail;&#125;;int main(void)&#123; /** 解密数字 * 首先将第1 个数删除，紧接着将第2 个数放到这串数的末尾 * 再将第3 个数删除并将第4 个数放到这串数的末尾，再将第5 个数删除…… * 直到剩下最后一个数，将最后一个数也删除。 * 按删除顺序排列出数字。 **/ struct queue t; t.head = 1; t.tail = 1; int i = 0; for ( i = 1 ; i &lt;= 9 ; i++) &#123; scanf("%d",&amp;t.data[t.tail]); t.tail++; &#125; while (t.head &lt; t.head) &#123; printf("%d ",t.data[t.head]); t.head++; t.data[t.tail] = t.data[t.head]; t.tail++; t.head++; &#125; system("pause"); return 0;&#125; 栈 只能从顶部往下出去，即最底下的最后出去 模型如下示例： 12345struct stack&#123; char data[101]; //保存数据 int top; //自顶而下添加数据&#125;; 来看如下示例，判断一个字符串是否对称（回文字符串）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct stack&#123; char data[101]; int top;&#125;;int main(void)&#123; /*回文字符串，即判断一个字符串是否对称*/ struct stack s; //初始化栈 s.top = 0; char str[100]; scanf("%s",str); int len = strlen(str); int mid = len / 2 - 1;//中间位置 int i = 0; for (i = 0 ; i &lt;= mid ; i++) &#123; s.top++; s.data[s.top] = str[i]; &#125; int next; if (len % 2 == 0) &#123; next = mid + 1; &#125; else &#123; next = mid + 2; &#125; for ( i = next ; i &lt; len ; i++) &#123; if (str[i] != s.data[s.top]) &#123; break; &#125; s.top--; &#125; if ( 0 == s.top) &#123; printf("Yes"); &#125; else &#123; printf("No"); &#125; system("pause"); return 0;&#125; 深度优先搜索(DFS) 理解深度优先搜索的关键在于解决”当下如何做“，而对于下一步如何做和当下如何做是一样的 深度优先搜索的基本模型12345678void dfs(int step)&#123; 判断边界 尝试每一种可能 for ( i = 1 ; i &lt;= n ; i++) &#123; 继续下一步 dfs(step+1); &#125;&#125; 字典树 由于是刷OJ碰到的题目，稍微理解了一下思想 很多核心操作尚未了解，先简单记录一下定义节点1234567struct node&#123; /* 里面的内容是可选的，并不局限于一两个 */ int cnt; //代表这个单词是否出现过，一般初始化为0 int num; //代表单词出现次数 struct node* next[26]; //代表树二十六个字母的分支，需要手动分配为0空间&#125;*root; 插入过程123456789101112131415161718192021222324void insert_tree(char* str , node* root , int* max , char* max_str)&#123; node* p = root; //定义一个指针指向树 int i = 0; int l = strlen(str); //获取需要插入字符串的长度 for ( i = 0 ; i &lt; l ; i++) //遍历字符串 &#123; if (p-&gt;next[str[i] - 'a'] == NULL) //如果下一个节点为空，手动申请空间 &#123; p-&gt;next[str[i] - 'a'] = (node*)malloc(sizeof(node)); p-&gt;next[str[i] - 'a']-&gt;cnt = 0; //初始化节点 p-&gt;next[str[i] - 'a']-&gt;num = 0; memset(p-&gt;next[str[i] - 'a']-&gt;next,0,sizeof(p-&gt;next[str[i] - 'a']-&gt;next)); &#125; p = p-&gt;next[str[i] - 'a']; p-&gt;cnt += 1; &#125; p-&gt;num++; if (p-&gt;num &gt; *max) //比较长度，OJ题目需要，可选 &#123; *max = p-&gt;num; strcpy(max_str,str); &#125;&#125; 优先队列 优先队列通常适用于比较数字 通过堆的方式来实现，最大堆（顶部最大），最小堆（顶部最小） 序号是有规律的，若当前节点（父节点）的序号为i，它左边的子节点序号为(i*2)，右边的则为(i*2+1); 顶部元素下滑 首先来查看如下代码，将顶部元素下滑 1234567891011121314151617181920212223242526272829303132333435363738394041void swap(int x,int y,int* num)//交换节点函数&#123; int temp; temp = num[x]; num[x] = num[y]; num[y] = temp; return;&#125;void siftdown(int i,int* num,int n) //元素下滑&#123; int flag = 0; //判断程序状态 int temp; while (i * 2 &lt;= n &amp;&amp; flag == 0) &#123; if (num[i] &gt; num[i*2]) //判断父节点和左子节点哪个大 &#123; temp = i*2; //记录节点 &#125; else &#123; temp = i; &#125; if (i*2+1 &lt;= n) &#123; if (num[temp] &gt; num[i*2+1]) //判断右字节点和之前判断的节点比较 &#123; temp = i*2+1;//更新节点 &#125; &#125; if (temp != i) &#123; swap(temp,i,num);//交换节点 i = temp &#125; else &#123; flag = 1; &#125; &#125; return;&#125; 之前定义的是判断节点，即满足堆的特性。 接下来定义的是将节点上滑，为初始化堆做准备 底部元素上滑123456789101112131415161718192021void siftup(int i ,int* num , int n)&#123; int flag = 0; if ( i == 1 )//当是最顶部元素时，跳出 &#123; return; &#125; while (i != 1 &amp;&amp; flag == 0) &#123; if (num[i] &lt; num[i/2])//比较子节点和父节点大小 &#123; swap(i,i/2,num); &#125; else &#123; flag = 1; &#125; i /= 2;//很重要，更新节点序号 &#125; return;&#125; 当定义好元素上滑后，就可以对堆进行初始化了 来看如下代码 初始化堆123456789void create(int* num , int n)&#123; /* 本质就是一堆无序的数组，从倒二层开始排序 */ int i; for ( i = n / 2 ; i &gt;= 1 ; i--) &#123; siftup(i,num,n); //让元素上滑 &#125;&#125; 优先队列大致的轮廓便出现了 最后以学校OJ的题目结尾 大致代码就是前面的思路，但是多了一个删除元素 OJ题目结尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/*Description小明很喜欢算法和编程，他的大学学业生涯规划是：厦门理工学院程序设计大赛一等奖、福建省程序设计大赛金牌、蓝桥杯软件大赛全国一等奖、亚洲区域赛金牌、World final金牌、Google就业年薪百万。小明是懒癌晚期，他不想通过努力训练完成规划，他想通过吃药来提高智商，秒杀一众高手。 小明发现单吃一种药效果太差，他要将已有的N种药物混合成1种药再吃。已知每种药都有一定的毒性，将任意两种药混合的毒性为这两种药的毒性之和，混合产生的新药的毒性也同样为两种药的毒性之和。由于技术限制，小明每次只能挑选两种药进行混合。现在小明想知道将N种药合成1种药的最小毒性和。Input输入第一行为一个正整数N（1 &lt;= N &lt;= 100000） 接下来一行输入N个正整数，第i个整数a[i]代表第i种药的毒性( 1 &lt;= a[i] &lt;= 1000)Output输出一行一个整数，代表药的最小毒性和。Sample Input51 2 3 4 5Sample Output33*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int x,int y,int* num)&#123; int temp; temp = num[x]; num[x] = num[y]; num[y] = temp; return;&#125;void siftdown(int i,int* num,int n) //元素下滑&#123; int flag = 0; int temp; while (flag == 0 &amp;&amp; i * 2 &lt;= n) &#123; if (num[i] &gt; num[i*2]) &#123; temp = i * 2; &#125; else &#123; temp = i; &#125; if ( i*2+1 &lt;= n) &#123; if (num[i*2+1] &lt; num[temp]) &#123; temp = i*2+1; &#125; &#125; if ( temp != i) &#123; swap(i,temp,num); i = temp; &#125; else &#123; flag = 1; &#125; &#125; return;&#125;void create(int* num,int n)&#123; int i = n / 2; for ( i = n / 2 ; i &gt;= 1 ; i--) &#123; siftdown(i,num,n); &#125;&#125;int delete_min(int* num,int* n)&#123; /* 先将顶部元素删除，然后将尾部元素放到顶部，重新排序 */ int temp = num[1]; num[1] = num[*n]; *n -= 1; siftdown(1,num,*n); return temp; &#125;void siftup(int i , int* num , int n)&#123; int flag = 0; if (i == 1) &#123; return; &#125; while (i != 1 &amp;&amp; flag == 0) &#123; if (num[i/2] &gt; num[i]) &#123; swap(i/2,i,num); &#125; else &#123; flag = 1; &#125; i = i / 2; &#125; return;&#125;int main(void)&#123; int N; scanf("%d",&amp;N); int *num = (int*)malloc(sizeof(int)*(N+1)); //int num[N]; int i; for ( i = 1 ; i &lt;= N ; i++) &#123; scanf("%d",&amp;num[i]); &#125; create(num,N); //初始化堆 int result = 0; int min_1 , min_2; while (1) &#123; min_1 = delete_min(num,&amp;N); min_2 = delete_min(num,&amp;N); result += min_1+min_2; if (N == 0) &#123; break; &#125; N++; num[N] = min_1+min_2; siftup(N,num,N); &#125; printf("%d",result); free(num); system("pause"); return 0;&#125; 大数阶乘 当数字过大时，会造成数据溢出，通常需要使用数组来存储1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std; int cal[999999];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int N; int carry; int flag = 0; int ans; while (cin &gt;&gt; N) &#123; flag = 0; carry = 0; cal[0] = 1; for (int i = 2 ; i &lt;= N ; i++) &#123; for ( int j = 0 ; j &lt;= flag ; j++) &#123; ans = cal[j] * i + carry; cal[j] = ans % 10; carry = ans / 10; &#125; while (carry) &#123; flag++; cal[flag] = carry % 10; carry /= 10; &#125; &#125; for ( int i = flag ; i &gt;= 0 ; i--) &#123; cout &lt;&lt; cal[i]; &#125; cout &lt;&lt; endl; &#125; system("pause"); return 0;&#125;/*位数1数组内容0 0 0 1步骤二：2！＝2＊1！＝2位数1数组内容0 0 0 2步骤三：3！＝3＊2！＝3＊2＝6位数1数组内容0 0 0 6步骤四：4！＝4＊3！＝4＊6＝24位数1数组内容0 0 0 24因为24大于10，需要进位data[1]=data[1]+data[0]/10=0+2=2data[0]=data[0]%10=4所以数组内容为0 0 2 4位数2步骤五：5！＝5＊4！＝5＊24＝120位数2数组内容为0 0 2＊5 4＊5即0 0 10 20因为data[0]大于10，需要进位data[1]=data[1]+data[0]/10=10+2=12data[0]=data[1]%10=0此时数组内容为0 0 12 0data[2]=data[2]+data[1]/10=0+1=1data[1]=data[1]%10=2位数加1数组内容为0 1 2 0/* 并查集 并查集通过一维数组来实现，主要在寻根以及合并。 假设每个数组元素存储自己的编号，可以得出合并算法如下： 12345678910void merge(int a , int b)&#123; int t1 = getf(num[a]); //获取根部编号 int t2 = getf(num[b]); if (t1 != t2) &#123; num[t2] = t1; //靠左原则 return; &#125;&#125; 寻根算法如下，通过递归实现： 123456789101112int getf(int v)&#123; if (num[v] == v) &#123; return v; &#125; else &#123; num[v] = getf(num[v]); return num[v]; &#125;&#125; OJ做题小记 使用dfs的时候，如果是路径，需要记得将起始位置标志为已经走过，不然结果可能会翻倍。 树二叉树及其存储结构性质 如果一棵树所有节点存在（形似三角形），称为满二叉树或完美二叉树 如果一棵树在最底层从右往左缺少数个节点，但其余节点与满二叉树一一对应，被称为完全二叉树 二叉树第i层最多有2^(i-1)个节点 深度为k的二叉树最大节点数为(2^k)-1 设n0为叶节点个数，n2是度为2的非叶节点个数，两者满足n0=n2+1 先序遍历： 根 左子树 右子树 ， 中序遍历 ：左子树 根 右子树 ， 后序遍历： 左子树 右子树 根存储结构]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习笔记]]></title>
    <url>%2F2017%2F10%2F04%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日常学习中难免遇到一些坑 在此记录自己学习C语言时的笔记 更新缓慢，大坑已填 已结课 在早期的C89的标准中，必须在最开始的地方定义变量，不过现在的编译器没那么严格。（VC6.0碰到的坑） %o代表八进制，八进制以0开头。 %x代表十六进制，十六进制以0x开头。 %p代表指针变量。 变量最好在定义时就初始化，否则忘记赋值直接使用会出现特别大的奇怪数值。（刷OJ的时候碰到的坑）。 单精度(float)七位有效数字，双精度(double)十六位有效数字。小数有六位，逗号算一位 转义字符参见表格。 大小写ASCII码相差32。 一旦有实数参与运算，结果也为实数。否则大多数机器采取“向零取整”的策略。 scanf中，%*3d表示读取时跳过3列。 scanf中，若scanf(“%d,%d”); 出现了逗号，则输入时也要出现逗号。 scanf中，若scanf(“%d\n”); 出现了\n，则需要多输入一个任意字符。 i++是表达式，不能参与运算。 （书上例题） 代码若需要换行，可以使用\来连接（连接符）。 else总是和它上面最近的if配对（就近原则）。 do-while结尾中的分号不能少。 指针本质是变量，也拥有地址，二级指针就是用来存储指针地址，指针可以进行值传递。 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int a = 10; int *p = &amp;a; int* *p1 = &amp;p; //这里代表生成一个二级指针，指针也是有地址的 int *p2 = p; //这个代表的是地址的传递，忽略了指针的地址的事实。 system("pause"); return 0;&#125; 设p为指针，*p++可以看作*(p++)。 设p为指针，num为数组名，p指向num。则p[3]==num[3]。 指针和数组相差：指针可以参与运算，和数组名不可以。如p++成立而num++报错。 2[p]是合法的，等同于*(2+p)。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p = num; //在这里c只是普通指针，并不称为数组指针或者指针数组。 printf("%d",*p++); //在这里是先执行p++，在执行*p. //即*(p++) p[3] == num[3]; //这是成立的，指针的下标运算 , p[2] == p+2; int b = 4; int *p1 = &amp;b; p1[2] = 13; //按道理说已经越界，但编译器未报错 //数组名和指针变量 数组名不允许自加的，且不参与运算，而指针变量可以 //数组名是一个常量 , 而 2[p] 是合法的 ,等同于 *(2+p) system("pause"); return 0;&#125; 数组地址和数组第一个元素的地址相同。 数组中一旦一个元素被初始化，其他元素都会被初始化为0。但是如果没有初始化任一元素，则所有元素都是不确定的存在，使用风险很大。 int num[][3]是成立的，但是使用的同时一定要对它进行初始化，否则必将编译失败。 有的时候我们可以使用int num[2][3] = {1,2,3,4,5,6};来初始化一个数组，编译器会将其按顺序分配到内存当中。 数组在初始化的时候，不允许使用变量初始化，必须使用常量。(C99标准支持，偶然遇见,在此记录) 1234567891011121314int a = 10;int num[a]; //这是错误写法，但是有的编译器可以编译通过 //C不允许使用这种写法，但规则是人定的。 //C++至今不允许使用，但有vector代替//若是一定要动态分配的话int n;scanf("%d" , &amp;n);int* a = (int*)malloc(sizeof(int) * n);int i = 0;for (i = 0 ; i &lt; n ; i++)&#123; scanf("%d",&amp;a[i]);&#125;free(a); 数组之中不允许使用等号直接复制，数组名是常量，不允许在赋值运算符的左侧，可是使用循环赋值或memcpy赋值。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;memory.h&gt;int main(void)&#123; int a[5] = &#123;1,2,3,4,5&#125;; int b[5] = &#123;a[4]&#125;; //可以使用这种赋值方法，将a中的元素赋值给b //错误写法： b = a; //有两种常见赋值，一种是循环，一种是memcpy复制 int i = 0; //循环赋值 for (i = 0 ; i &lt; 5; i++) &#123; b[i] = a[i]; &#125; //memcpy赋值,包含在&lt;memory.h&gt;或&lt;string.h&gt;中 memcpy(要被赋值，要赋值，赋值大小); //内存拷贝，认地址不认元素 memcpy(b,a,sizeof(int)*5); memcpy(&amp;b[0],&amp;a[0],sizeof(int)*5); return 0; //由此我们可以引申出，如果要从a[3]开始对b赋值的话 memcpy(&amp;b[0],&amp;a[3],sizeof(int)*2);&#125; 数组指针和指针数组是不同的概念 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p[5] = &#123;&amp;num[0],&amp;num[1],&amp;num[2],&amp;num[3],&amp;num[4]&#125;; //指针数组，生成五个指针分别指向num中的元素。p先和[]结合。 /*-------------------------------------------------------------*/ //要生成一个指针指向数组，通过分解可以得到 //*p1 代表指针 //int[5]代表数组 //实际理解是int[5] *p1; 但是编译器不允许通过 //根据优先级int *p1[5]，会先和中括号结合，所以需要括号将p1括起来 int (*p1)[5] = &amp;num; //数组指针 //生成一个指针，指向数组，在C语言中，数组名是第一个元素的地址，但是数组本身也存在地址。 //元素个数一定要一样，否则就是不同类型 //两者可以看成是运算符优先级的不同，[]的优先级大于*，但是()的优先级是最大的。 return 0;&#125; 如果用到了自定义函数，返回值需要注意，输出为float但使用返回值为int的函数，结果会很奇怪。（OJ碰到的大坑） 如果碰到字符串切割或者拼接问题，printf输出时需要考虑\0，否则OJ报错。（OJ大坑） 除法使用向零取整，所以当使用： 1 / 10的时候，得到的答案是0。（刷Oj遇到的方法） 用到for循环的时候，需要注意到边界问题，否则有可能会超出时间限制。（刷oj遇到的超时问题） 写for循环时，一旦不小心在末尾加上分号，则初始化的值可能出现极大的偏差。（舍友遇到的大坑） 每个字符串末尾都需要加上\0,否则使用put或printf函数时，不会终止输出，出现乱码。（同学遇到的大坑，自己刷oj也碰到过）。 自增或自减运算符不能用于常量表达式，如5++，(a+b)++ 。且方向自右向。 转化时向高精度的方向转换，即int -&gt; float -&gt; double。 字符串和数字相互转换的函数: 1234567//需要包含在头文件stdlib.hatof(str) //返回doubleatoi(str) //返回intatol(str) //返回long/*-------------------*/itoa(num,str,radix) //radix是要求转换的进制数，int转strltoa(num,str,radix) //long转str i *= k+2 ，k+2为一个整体，即 i = i * (k + 2); a &gt; b &gt; c ，从左往右比较，并用0,1替换比较结果，即如果a &gt; b，会替换成： 1 &gt; c。 字符串和字符指针的区别，参考如下代码： 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char str1[] = "Hello World"; char *str2 = "Hello World"; printf("%p\n","Hello World"); printf("%p\n",str1); printf("%p\n",str2); /*这第一个和第三个结果是相同的。 *第一个代表字符串地址 *第三个代表生成一个指针指向字符串地址 *而第二个代表新生成一片空间，与原先字符串的空间两者相独立，互不干扰，所以打印出的指针地址不同。 */ return 0;&#125; 数组作为函数参数，如下代码： 12345678910111213141516/*当数组作为参数传入时，是可以直接修改数组内容的 *即数组首地址指针被传入到函数当中。 */#include &lt;stdio.h&gt;void input(double score[]) //不需要输入元素个数&#123; //函数实现;&#125;//亦或者使用如下写法void show(double* score) //两者等同，有细微差别，涉及底层机制。int main(void)&#123; double score[10]; input(score); return 0;&#125; 八进制为0~7 十进制为0~9 十六进制为0~9,A~F，其中A为10，F为15 声明一个负数，使用%u，即无符号整数打印 先将该数绝对值以二进制的方式表达出来 再将位数所有按位取反 最后将得到的二进制加1 逆推回十进制 转义字符中，存在八进制和十六进制 \ddd 三位八进制 不能超过三位，且数字为0-7 \xhh 二位十六进制 不能超过两位 十进制转二进制，一般采用除2取余法，直到商为0，得到的余数从最尾巴倒着排回去 转其他进制同样也可以采用除数取余法 其他进制转十进制，可以将数字展开，一次乘以各个数字的次方 二进制转八进制，从后往前，三位一组，不够用0补，然后以十进制方法转化，如(11001.101)2，其中001代表1，011代表3，所以这个数值就是31。 同理八进制转二进制也可以直接将每一位展开 二进制转十六进制，以四位为一段，如（11111101）2，从1111得出F，1101得出D，所以值是FD。 关于自增自减运算符的深入剖析（参考网络上的资料） 在不同编译器中，这个结果可能出现不同。 123456789101112int i = 3;int j = 4;int a = i++ + i++;int b = ++j + ++j;printf("%d, %d\n", a, b);/** *这个答案在VC6.0里面为6，12 *但是在vs2017里面测试确为7，12 *以以上的例子来说 *i++的理解应该是执行完整个表达式的其他操作后，然后才自增 *++j的理解为先自增再参与其他运算 */ 再看另一组代码 12345678910111213int i = 3;int j = 4;int a = i++ + i++ + i++;int b = ++j + ++j + ++j;printf("%d, %d\n", a, b);/** *这组结果为9，19 *vs2017中为12，19 *按上一组的理解，这一组应该为21 *但是这一组存在两个同级+运算 *根据+的左结合性，式子可看成(++j + ++j) + ++j; *即 (6 + 6) + 7; */ 最后一组代码 123456789101112int i=1;int j=1;int a = i++ + i++ + i++ + i++ + i++ + i++ + i++; // 七个int b = ++j + ++j + ++j + ++j + ++j + ++j + ++j;printf("%d, %d\n", a, b);printf("%d, %d\n", i, j); /** *a = 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7 *b = 3 + 3 + 4 + 5 + 6 + 7 + 8 = 36 *总的来说，后置++比较好看出来，前置++需要注意运算符的优先级 *如果非应试教育，应当尽量不使用这种式子，造成误解 */ 当碰到：a += a = a -= a = 3这类式子时，应从右往左一次计算，如下： 1234a *= 3;a = a - a;//......//此后不再叙述 使用extern声明全局变量的时候，可以扩大变量的作用域。如在其他文件中存在一个整形变量a，在本文件中可以使用extern int a来申明全局变量，类型名可写可不写，如使用extern a 使用static声明全局变量时，只能用于本文件，即便在其他文件中使用了extern这个关键字，也无法调用，那一行只能调用一次，不可重复调用，所以声明时最好就一同初始化，static 函数也同理 找到字符串结束符 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char *str = "hello world"; int i = 0; while (str[i] != '\0') &#123; i++; &#125; return 0;&#125; 注释不允许嵌套（练习大坑） ++允许使用在float上面，但是%必须是两个整型 原码：符号位加上真值的绝对值，即第一位是符号，其余位为值。符号位1代表符号，0代表正号 反码：整数的反码是本身。负数是在原码的基础上，符号位不变，其他位取反 补码：正数的补码是本身。负数的补码是在原码的基础上，符号位不变，其他位取反，最后+1。（即反码+1） 在使用&amp;&amp;进行判断时，如果前面为假，则代表短路，不再执行后面的语句。（习题大坑） 逻辑与运算符优先级大于逻辑或 逻辑运算问题，查看如下代码： 123456789101112#include &lt;stdio.h&gt;int main(void)&#123; int a = 1; int b = 1; int c = 1; ++a || ++b &amp;&amp; ++c; printf("a = %d , b = %d, c = %d\n", a, b, c); return 0;&#125; 运算符高是表示: ++a || (++b &amp;&amp; ++c)，但是运算顺序依旧从左往右 举四则运算的例子： 1 + (2 * 3) 而不是 ( 1 + 2 ) * 3 但他们是从左往右运算，即就从+而言，它先算1 所以回归问题，先演算++a，于是||出现短路 函数允许返回一个指针，例如 1234int * getaddress(int x)&#123; return &amp;x;&#125; 函数名即为地址，所以有函数指针这个说法，具体实现如下： 12345678910111213141516171819202122int max(int x,int y)&#123; if ( x &gt;= y) &#123; return x; &#125; else &#123; return y; &#125;&#125;int main(void)&#123; int a , b ,c; int (*p)(int , int); p = max; //代表p指向max scanf("%d %d", &amp;a, &amp;b); c = (*p)(a,b); printf("\n a = %d , b = %d , max = %d",a,b,c); return 0;&#125; int (*函数指针)(参数列表); 对指向函数的指针变量，进行运算，如p++,p–是毫无意义的事情 结构体类型定义的时候并不分配内存空间，只有申明变量的时候才分配内存。 结构体里面允许嵌套结构体，使用.（成员运算符）来逐级访问。 共用体的大小取决于最长成员所占用的存储空间，而结构体则是所有成员之和。如下例子 12345678union data&#123; int a; float b; double c; char d;&#125;obj;//这个data所占的空间为double所占的8字节。、 不能同时引用两个或两个以上的共用体成员，否则出错。 枚举序号默认从0开始排列，但是也可以初始化，不允许后面复制。 异或的独特用法 四种定义： 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 0 1 ^ 1 = 1 来看如下示例：123456//交换律a ^ b = b ^ a//结合律( a ^ b ) ^ c = a ^ ( b ^ c ) //逆运算( a ^ b ) ^ b = a; //这个可以用来判断：假设一堆数组里面其他数字出现两次，找出只出现一次的那一个。 使用左移运算符&lt;&lt;，例如3 &lt;&lt; 3 为3乘2的三次方，(3 &lt;&lt; 3) - 1 为3乘以2的三次方减一 signed char的范围是-128-127，超过之后可能变成负数，OJ题目留意（OJ题目碰到的坑） cin同样遇到空格也会停止，需要留意一下字符串问题。 十六进制不区分大小写 形式参数是局部变量 register保存在CPU寄存器当中，用以加快程序运行，常用于频繁使用的变量之上。 对未赋初值的静态局部变量，C编译程序将自动给予初值为0 当使用头文件时候，要防止重定义 1234#ifndef _H_#define _H_//Your Code#endif 大坑待填]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的初步体验]]></title>
    <url>%2F2017%2F09%2F17%2FGit%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[初步了解Git的使用，在此做下笔记。 涉及Git安装配置，创建版本库以及其他多方面内容，防止自己遗忘。 Git的安装 安装过程极度简单，不做记录。 Git的账号配置12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot; git conifg命令中的–global参数，用了这个参数，表示这台机器所有用户都会使用这个配置，也可以不添加。创建版本库 选择合适地方创建空目录 在当前目录下使用如下代码来初始化仓库。1git init 可以观察到当前目录下生成了 .git 的文件夹,如果没有特殊情况，最好不要修改这个目录。添加文件 一般情况下，不要使用windows自带的记事本去编辑文件，容易出各种奇怪的错误。 使用如下代码添加文件 1git add 文件名 使用如下代码提交到仓库 1git commit -m &quot;注释&quot; -m 后面为修改的注释，一般情况下最好添加，也方便自己以后查看修改记录。 commit可以一次提交多个文件，所以最好 add多个文件后，使用commit提交。 查看状态 使用如下代码查看当前状态：1git status 这条命令可以让我们掌握仓库的状态，产看那些文件已经更改过了。 使用如下代码查看详细状态1git diff HEAD --文件名 此条命令可以让我们查询到文件做了哪些更改。 需要注意的是这是对比工作区和缓存区的差别，所以需要先使用add提交。 查看日志 使用如下代码查看文件修改过的日志1git log 可以加上 –pretty=oneline,出现的是commit的版本号，有 Head的那一行为最新修改的版本。 查看文件历史变动的内容 有的时候我们需要回看文件修改的内容，可以使用12git log --pretty=oneline #获取文件的哈希值git show 哈希值 版本回退 使用如下代码回退版本123git reset --hard HEAD^#亦或者使用git reset --hard 回退后的id 注意,在windows平台中的cmd下，符号 ^应当使用双引号括起来，它是特殊字符，否则会出现 More? 的现象。 上一个版本是 HEAD^，上上个版本则是 HEAD^^ ，以此类推。 当版本数过多的时候，使用^容易数不过来，可以使用 HEAD~100 来回退版本。 如果不小心回退错误，可以使用: git reset –hard 版本号来回退版本。 只需写版本号前几位即可，系统会进行自动查找。 获取回退后的ID 使用如下代码1git reflog 这条命令可以显示你之前输入的所有命令，以此来获得 commit id。 这条命令用于记录输入过的命令。 跟踪修改 git跟踪的是修改内容而非文件本身，如果不使用 add将文件添加至暂存区， commit只会提交暂存区的内容，所以文件不会发生改变。丢弃修改未使用 add前 提交前,使用如下代码，可以丢弃工作区的修改：1git chekout -- 文件名 可以撤销修改 此处中的 – 十分重要，缺少其中一个则可能编程另外一个命令。使用了 add后 提交后，我们可以使用如下命令，来讲暂存区的修改回退为工作区：1git reset HEAD 文件名 删除文件一般情况下 一般情况下，直接将文件删除，这时可以使用如下代码，来查看状态：1git status 这时Git知道我们删除了文件，工作区和版本库不一致，我们可以使用如下代码，来完成删除并提交：12git rm 文件名git commit -m &quot;删除注释&quot; 误删的情况 如果是误删了文件，我们可以使用如下代码来恢复文件：1git checkout -- 文件名 git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 恢复只能恢复到 最近一次 提交的内容。 创建远程仓库 首先先观察在系统盘用户目录下是否存在 .ssh 的文件夹,并观察是否有id_rsa和id_rsa.pub这两个文件。 如果不存在说明没有密钥，使用如下代码创建密钥： 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 并在github里面添加id_rsa.pub这个文件中的密钥。 添加远程库 首先在Github上面使用 New repository 创建新的仓库。 接下来使用如下代码来关联仓库:1git remote add origin git@github.com:fjlyx97/TestRespository.git 注意其中的名字变换，远程库的名字就是origin，Git的默认叫法。 使用如下代码来将本地库的内容推送到远程库上：1git push -u origin master 第一次可以使用 -u的参数，可以将本地的master分支内容推送的远程新的master分支。 以后可以使用 git push origin master来直接推送。 可以使用如下代码来查看当前有的远程库1git remote 从远程库克隆 从零开始时最好先创建远程库，并使用如下代码：1git clone 地址 从远程仓库同步到本地仓库 当使用多台电脑编辑文件时，我们需要将远程仓库同步到本地仓库。1git pull 创建合并分支 我们可以使用如下代码来创建分支 1234git checkout -b 分支名 //创建分支并切换//等同于git branch 分支名git checkout 分支名 //切换分支 可以使用如下命令查看分支 1git branch 合并分支 1git merge 分支名 删除分支 1git branch -d 分支名 创建忽略文件 有的时候我们并不想所有文件都被同步到仓库中，所以我们可以通过创建一个 .gitignore 文件。 github为我们准备了模板，可以点击：gitignore模板 文件中以 # 开头的为注释，而 * 为通配符。 这个方法针对未被提交的文件，如果文件已经被提交的话，需要输入如下代码: git rm -r –cached . git add . git commit -m “注释” 大坑待填]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[霞浦一中2017届高三十班]]></title>
    <url>%2F2017%2F09%2F10%2F%E9%9C%9E%E4%B8%AD%E9%AB%98%E4%B8%89%E5%8D%81%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[我有一个梦想，就是完成一部可以保存一生的视频前言 晃晃悠悠，终于做完了毕业MV，也算完成了一部可以存一生的视频，给自己的高中生涯画上了一个圆满的句号。很感谢各方同学的支持，提供了好多素材给我们，让我们得以成功完成回忆同学的部分。同时也很感谢导演苏锦钰同学的认真态度，为了录制老师的最后一课，多次在学校以及老师家里来回奔波。从素材的收集到视频的录制，以及最后视频的完成。来来回回也耗时了三个月，诸多不易，但所幸，我们最终坚持了下来，最终在9月10号这一天，我们将它发布了出来。在此欢迎各位老师同学捧场，霞中高三十班制作组，倾情献上。 毕业MV制作人员 总导演，摄影师：苏锦钰 监制，后期处理：梁煜鑫 摄影助理：连凯琦 背景音乐《不说再见》演唱人员:林心烨，陈丽清，邓恬悦 特别鸣谢：梁柠，郑洋帆，谢凌巍，郑铭 背景音乐 console.error("Error: [hexo-tag-aplayer] Specified asset file not found (autoplay=false)"); 毕业视频通过手机观看的用户注意一下，请手机用户通过以下链接观看。霞浦一中2017届高三十班毕业MV 结语 故事的开头总是这样，适逢其会、猝不及防。我们相信这个世界四通八达，却很少抵达某个最真实的地方。后来的后来……一别一聚、一絮一语。从前赋予我们七零八散的往事及可爱的人。但故事的结尾总是这样，花开两朵、天各一方。山高水阔，来日方长。愿此去前程似锦，再相逢依旧如故。愿你走出半生，归来仍是少年。 敲黑板！！！ 零经费剧组经历3个月的创作，付出了许许多多的时间，精力，甚至财力。望各位看官看完之际，觉得视频不错的，就按下方Donate打赏点钱。打赏的钱我会分给全体剧组人员，犒劳下这三个月的辛苦。我谨代表全体剧组人员感激不尽！]]></content>
      <categories>
        <category>爱生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>霞浦一中</tag>
        <tag>生活</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python + selenium实现浏览器自动登录]]></title>
    <url>%2F2017%2F08%2F28%2F%E4%BD%BF%E7%94%A8python-%2B-selenium%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[使用python + selenium实现浏览器自动登录 python版本为3.6.2 系统为windows10 记录自己学习的心得，也是为了防止以后时间久了自己也遗忘了 1.安装selinium 安装的过程十分简单，只需要使用pip安装即可1pip install selenium 2.安装对应的webdriver（驱动）本文以edge浏览器为例子百度edge webdriver，搜索完第一个就是微软的官网了。这里附上链接:WebDriver如下图：选择对应的版本,这里十分重要!!版本可以通过windows的运行快速查看1dxdiag 如下图： 下载完毕之后，将MicrosoftWebDriver.exe复制到python安装目录下的scripts文件夹里面。至此安装环境配置完毕，开始实战。 3.实战 首先在python中导入selenium的webdriver的库from selenium import webdriver 实例化出一个浏览器browser = webdriver.Edge() 打开网址需要使用get方法，我们在这里以小米官网为例子browser.get(&quot;https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180&quot;)我们可以试着运行代码，可以看到浏览器已经自动打开小米官网了 获取元素元素的方法有很多种： find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 在这方面网上有很多资料首先我们要定位到一个元素，在这里我们可以用浏览器自带的工具右键登录按钮，点击检查元素，如图： 我们就可以定位到元素了 可以查看到他有着name属性，id属性定位元素的方法多种多样，没有规定一定要用哪一种，适合即可。123name = browser.find_element_by_name("user")#亦或者name = browser.find_element_by_id("username") 于是乎，我们已经定位到账号的输入框了。接下来是输入内容，输入内容可以使用send_keys的方法name.send_keys(&quot;hello&quot;)运行试试看，我们会发现已经成功在输入框中输入我们所要的内容。 同理我们可以定位到密码框passwd = browser.find_element_by_name(&quot;pwd&quot;) 以及往里面填充内容passwd.send_keys(&quot;hello&quot;)如下图所示： 输入完账号密码，最后一步便是点击登录按钮了 12login_button = browser.find_element_by_id("login-button")login_button.click() 运行试试，我们可以看到已经登录过了，当然账号密码是随便输入的。 最后附上代码：123456789101112from selenium import webdriverimport timebrowser = webdriver.Edge()browser.get("https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180")time.sleep(2)name = browser.find_element_by_name("user")name.send_keys("账号")passwd = browser.find_element_by_name("pwd")passwd.send_keys("密码")login_button = browser.find_element_by_id("login-button")login_button.click() 4.其它定位xpath定位 通常情况下，我们不一定能通过name或id定位,这时候我们可以用其它方法，通过xpath就是一种不错的选择，这里以百度的输入框为例。xpath可以通过谷歌浏览器或者其它浏览器直接查看，如图： 单击后即可复制,如下//*[@id=&quot;kw&quot;] 我们可以使用它path = browser.find_element_by_xpath(&quot;//*[@id=&#39;kw&#39;]&quot;) 记得将里面的双隐号改成单隐号，否则报错。可以试试是否定位到了path.send_keys(&quot;hello&quot;) 使用elements定位很多时候元素定位都很模糊，要定位到并不是十分容易，我们可以换个思路，同时定位一组元素，通过取下标的方法，读取元素，以百度的首页为例： 通过查看元素我们可以发现： 上面一组元素具有许多相同的特征，于是我们可以使用如下代码：123elements = browser.find_elements("css selector" , ".mnav")#或是elements = browser.find_elements_by_css_selector(".mnav") 两个定位是相同的，不过写法不同而已，这个方法和之前的区别主要就是find_elements，使用的是复数定位，最后通过下标来选择元素。1elements[0].click() 这样便是点击第一个元素，也就是新闻的按钮。附上测试代码: 5.终 selenium的资料网上很多，遇到问题善用搜索引擎，一般问题都可以得到解决。 大坑这里要特别说明一点，在测试时，浏览器的缩放比例不能调，不能调，不能调。这真的是一个大坑，我当时电脑的缩放比例是125%,定位元素始终不能成功，一直会提示：困扰了我好久，查阅好多资料始终不得解，偶然之下将缩放比例调回100%，终于解决这个问题，这也是我目前遇到最大的坑，在此特别记录，以防自己以后忘记。 最后附上我学习时的参考资料： Selenium2+python自动化45-18种定位方法Python爬虫利器五之Selenium的用法]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
