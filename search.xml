<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言学习笔记]]></title>
    <url>%2F2017%2F10%2F04%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日常学习中难免遇到一些坑 在此记录自己学习C语言时的笔记 更新缓慢，大坑待填 在早期的C89的标准中，必须在最开始的地方定义变量，不过现在的编译器没那么严格。（VC6.0碰到的坑） %o代表八进制，八进制以0开头。 %x代表十六进制，十六进制以0x开头。 %p代表指针变量。 变量最好在定义时就初始化，否则忘记赋值直接使用会出现特别大的奇怪数值。（刷OJ的时候碰到的坑）。 单精度(float)七位有效数字，双精度(double)十六位有效数字。 转义字符参见表格。 大小写ASCII码相差32。 一旦有实数参与运算，结果也为实数。否则大多数机器采取“向零取整”的策略。 scanf中，%*3d表示读取时跳过3列。 scanf中，若scanf(“%d,%d”); 出现了逗号，则输入时也要出现逗号。 scanf中，若scanf(“%d\n”); 出现了\n，则需要多输入一个任意字符。 i++是表达式，不能参与运算。 （书上例题） 代码若需要换行，可以使用\来连接（连接符）。 else总是和它上面最近的if配对（就近原则）。 do-while结尾中的分号不能少。 指针本质是变量，也拥有地址，二级指针就是用来存储指针地址，指针可以进行值传递。 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int a = 10; int *p = &amp;a; int* *p1 = &amp;p; //这里代表生成一个二级指针，指针也是有地址的 int *p2 = p; //这个代表的是地址的传递，忽略了指针的地址的事实。 system("pause"); return 0;&#125; 设p为指针，*p++可以看作*(p++)。 设p为指针，num为数组名，p指向num。则p[3]==num[3]。 指针和数组相差：指针可以参与运算，和数组名不可以。如p++成立而num++报错。 2[p]是合法的，等同于*(2+p)。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p = num; //在这里c只是普通指针，并不称为数组指针或者指针数组。 printf("%d",*p++); //在这里是先执行p++，在执行*p. //即*(p++) p[3] == num[3]; //这是成立的，指针的下标运算 , p[2] == p+2; int b = 4; int *p1 = &amp;b; p1[2] = 13; //按道理说已经越界，但编译器未报错 //数组名和指针变量 数组名不允许自加的，且不参与运算，而指针变量可以 //数组名是一个常量 , 而 2[p] 是合法的 ,等同于 *(2+p) system("pause"); return 0;&#125; 数组地址和数组第一个元素的地址相同。 数组中一旦一个元素被初始化，其他元素都会被初始化为0。但是如果没有初始化任一元素，则所有元素都是不确定的存在，使用风险很大。 int num[][3]是成立的，但是使用的同时一定要对它进行初始化，否则必将编译失败。 有的时候我们可以使用int num[2][3] = {1,2,3,4,5,6};来初始化一个数组，编译器会将其按顺序分配到内存当中。 数组在初始化的时候，不允许使用变量初始化，必须使用常量。(C99标准支持，偶然遇见,在此记录) 1234567891011121314int a = 10;int num[a]; //这是错误写法，但是有的编译器可以编译通过 //C不允许使用这种写法，但规则是人定的。 //C++至今不允许使用，但有vector代替//若是一定要动态分配的话int n;scanf("%d" , &amp;n);int* a = malloc(sizeof(int) * n);int i = 0;for (i = 0 ; i &lt; n ; i++)&#123; scanf("%d",&amp;a[i]);&#125;free(a); 数组之中不允许使用等号直接复制，数组名是常量，不允许在赋值运算符的左侧，可是使用循环赋值或memcpy赋值。 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;memory.h&gt;int main(void)&#123; int a[5] = &#123;1,2,3,4,5&#125;; int b[5] = &#123;a[4]&#125;; //可以使用这种赋值方法，将a中的元素赋值给b //错误写法： b = a; //有两种常见赋值，一种是循环，一种是memcpy复制 int i = 0; //循环赋值 for (i = 0 ; i &lt; 5; i++) &#123; b[i] = a[i]; &#125; //memcpy赋值,包含在&lt;memory.h&gt;或&lt;string.h&gt;中 memcpy(要被赋值，要赋值，赋值大小); //内存拷贝，认地址不认元素 memcpy(b,a,sizeof(int)*5); memcpy(&amp;b[0],&amp;a[0],sizeof(int)*5); return 0;&#125; 由此我们可以引申出，如果要从a[3]开始对b赋值的话1memcpy(&amp;b[0],&amp;b[3],sizeof(int)*2); 数组指针和指针数组是不同的概念1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p[5] = &#123;&amp;num[0],&amp;num[1],&amp;num[2],&amp;num[3],&amp;num[4]&#125;; //指针数组，生成五个指针分别指向num中的元素。p先和[]结合。 /*-------------------------------------------------------------*/ //要生成一个指针指向数组，通过分解可以得到 //*p1 代表指针 //int[5]代表数组 //实际理解是int[5] *p1; 但是编译器不允许通过 //根据优先级int *p1[5]，会先和中括号结合，所以需要括号将p1括起来 int (*p1)[5] = &amp;num; //数组指针 //生成一个指针，指向数组，在C语言中，数组名是第一个元素的地址，但是数组本身也存在地址。 //元素个数一定要一样，否则就是不同类型 //两者可以看成是运算符优先级的不同，[]的优先级大于*，但是()的优先级是最大的。 return 0;&#125; 大坑待填]]></content>
      <categories>
        <category>C语言记录</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的初步体验]]></title>
    <url>%2F2017%2F09%2F17%2FGit%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[初步了解Git的使用，在此做下笔记。 涉及Git安装配置，创建版本库以及其他多方面内容，防止自己遗忘。 Git的安装 安装过程极度简单，不做记录。 Git的账号配置12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot; git conifg命令中的–global参数，用了这个参数，表示这台机器所有用户都会使用这个配置，也可以不添加。创建版本库 选择合适地方创建空目录 在当前目录下使用如下代码来初始化仓库。1git init 可以观察到当前目录下生成了 .git 的文件夹,如果没有特殊情况，最好不要修改这个目录。添加文件 一般情况下，不要使用windows自带的记事本去编辑文件，容易出各种奇怪的错误。 使用如下代码添加文件 1git add 文件名 使用如下代码提交到仓库 1git commit -m &quot;注释&quot; -m 后面为修改的注释，一般情况下最好添加，也方便自己以后查看修改记录。 commit可以一次提交多个文件，所以最好 add多个文件后，使用commit提交。 查看状态 使用如下代码查看当前状态：1git status 这条命令可以让我们掌握仓库的状态，产看那些文件已经更改过了。 使用如下代码查看详细状态1git diff HEAD --文件名 此条命令可以让我们查询到文件做了哪些更改。 需要注意的是这是对比工作区和缓存区的差别，所以需要先使用add提交。 查看日志 使用如下代码查看文件修改过的日志1git log 可以加上 –pretty=oneline,出现的是commit的版本号，有 Head的那一行为最新修改的版本。 查看文件历史变动的内容 有的时候我们需要回看文件修改的内容，可以使用12git log --pretty=oneline #获取文件的哈希值git show 哈希值 版本回退 使用如下代码回退版本123git reset --hard HEAD^#亦或者使用git reset --hard 回退后的id 注意,在windows平台中的cmd下，符号 ^应当使用双引号括起来，它是特殊字符，否则会出现 More? 的现象。 上一个版本是 HEAD^，上上个版本则是 HEAD^^ ，以此类推。 当版本数过多的时候，使用^容易数不过来，可以使用 HEAD~100 来回退版本。 如果不小心回退错误，可以使用: git reset –hard 版本号来回退版本。 只需写版本号前几位即可，系统会进行自动查找。 获取回退后的ID 使用如下代码1git reflog 这条命令可以显示你之前输入的所有命令，以此来获得 commit id。 这条命令用于记录输入过的命令。 跟踪修改 git跟踪的是修改内容而非文件本身，如果不使用 add将文件添加至暂存区， commit只会提交暂存区的内容，所以文件不会发生改变。丢弃修改未使用 add前 提交前,使用如下代码，可以丢弃工作区的修改：1git chekout -- 文件名 可以撤销修改 此处中的 – 十分重要，缺少其中一个则可能编程另外一个命令。使用了 add后 提交后，我们可以使用如下命令，来讲暂存区的修改回退为工作区：1git reset HEAD 文件名 删除文件一般情况下 一般情况下，直接将文件删除，这时可以使用如下代码，来查看状态：1git status 这时Git知道我们删除了文件，工作区和版本库不一致，我们可以使用如下代码，来完成删除并提交：12git rm 文件名git commit -m &quot;删除注释&quot; 误删的情况 如果是误删了文件，我们可以使用如下代码来恢复文件：1git checkout -- 文件名 git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 恢复只能恢复到 最近一次 提交的内容。 创建远程仓库 首先先观察在系统盘用户目录下是否存在 .ssh 的文件夹,并观察是否有id_rsa和id_rsa.pub这两个文件。 如果不存在说明没有密钥，使用如下代码创建密钥： 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 并在github里面添加id_rsa.pub这个文件中的密钥。 添加远程库 首先在Github上面使用 New repository 创建新的仓库。 接下来使用如下代码来关联仓库:1git remote add origin git@github.com:fjlyx97/TestRespository.git 注意其中的名字变换，远程库的名字就是origin，Git的默认叫法。 使用如下代码来将本地库的内容推送到远程库上：1git push -u origin master 第一次可以使用 -u的参数，可以将本地的master分支内容推送的远程新的master分支。 以后可以使用 git push origin master来直接推送。 可以使用如下代码来查看当前有的远程库1git remote 从远程库克隆 从零开始时最好先创建远程库，并使用如下代码：1git clone 地址 从远程仓库同步到本地仓库 当使用多台电脑编辑文件时，我们需要将远程仓库同步到本地仓库。1git pull 创建合并分支 我们可以使用如下代码来创建分支 1234git checkout -b 分支名 //创建分支并切换//等同于git branch 分支名git checkout 分支名 //切换分支 可以使用如下命令查看分支 1git branch 合并分支 1git merge 分支名 删除分支 1git branch -d 分支名 创建忽略文件 有的时候我们并不想所有文件都被同步到仓库中，所以我们可以通过创建一个 .gitignore 文件。 github为我们准备了模板，可以点击：gitignore模板 文件中以 # 开头的为注释，而 * 为通配符。 这个方法针对未被提交的文件，如果文件已经被提交的话，需要输入如下代码: git rm -r –cached . git add . git commit -m “注释” 大坑待填]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[霞浦一中2017届高三十班]]></title>
    <url>%2F2017%2F09%2F10%2F%E9%9C%9E%E4%B8%AD%E9%AB%98%E4%B8%89%E5%8D%81%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[我有一个梦想，就是完成一部可以保存一生的视频前言 晃晃悠悠，终于做完了毕业MV，也算完成了一部可以存一生的视频，给自己的高中生涯画上了一个圆满的句号。很感谢各方同学的支持，提供了好多素材给我们，让我们得以成功完成回忆同学的部分。同时也很感谢导演苏锦钰同学的认真态度，为了录制老师的最后一课，多次在学校以及老师家里来回奔波。从素材的收集到视频的录制，以及最后视频的完成。来来回回也耗时了三个月，诸多不易，但所幸，我们最终坚持了下来，最终在9月10号这一天，我们将它发布了出来。在此欢迎各位老师同学捧场，霞中高三十班制作组，倾情献上。 毕业MV制作人员 总导演，摄影师：苏锦钰 监制，后期处理：梁煜鑫 摄影助理：连凯琦 背景音乐《不说再见》演唱人员:林心烨，陈丽清，邓恬悦 特别鸣谢：梁柠，郑洋帆，谢凌巍，郑铭 背景音乐 new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: false, showlrc: 0, music: { title: "不说再见", author: "陈丽清，林心烨，邓恬悦", url: "http://ovsp71cnj.bkt.clouddn.com/%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90.mp3", pic: "autoplay=false", } }); 毕业视频通过手机观看的用户注意一下，请手机用户通过以下链接观看。霞浦一中2017届高三十班毕业MV 结语 故事的开头总是这样，适逢其会、猝不及防。我们相信这个世界四通八达，却很少抵达某个最真实的地方。后来的后来……一别一聚、一絮一语。从前赋予我们七零八散的往事及可爱的人。但故事的结尾总是这样，花开两朵、天各一方。山高水阔，来日方长。愿此去前程似锦，再相逢依旧如故。愿你走出半生，归来仍是少年。 敲黑板！！！ 零经费剧组经历3个月的创作，付出了许许多多的时间，精力，甚至财力。望各位看官看完之际，觉得视频不错的，就按下方Donate打赏点钱。打赏的钱我会分给全体剧组人员，犒劳下这三个月的辛苦。我谨代表全体剧组人员感激不尽！]]></content>
      <categories>
        <category>爱生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>霞浦一中</tag>
        <tag>生活</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python + selenium实现浏览器自动登录]]></title>
    <url>%2F2017%2F08%2F28%2F%E4%BD%BF%E7%94%A8python-%2B-selenium%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[使用python + selenium实现浏览器自动登录 python版本为3.6.2 系统为windows10 记录自己学习的心得，也是为了防止以后时间久了自己也遗忘了 1.安装selinium 安装的过程十分简单，只需要使用pip安装即可1pip install selenium 2.安装对应的webdriver（驱动）本文以edge浏览器为例子百度edge webdriver，搜索完第一个就是微软的官网了。这里附上链接:WebDriver如下图：选择对应的版本,这里十分重要!!版本可以通过windows的运行快速查看1dxdiag 如下图： 下载完毕之后，将MicrosoftWebDriver.exe复制到python安装目录下的scripts文件夹里面。至此安装环境配置完毕，开始实战。 3.实战 首先在python中导入selenium的webdriver的库from selenium import webdriver 实例化出一个浏览器browser = webdriver.Edge() 打开网址需要使用get方法，我们在这里以小米官网为例子browser.get(&quot;https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180&quot;)我们可以试着运行代码，可以看到浏览器已经自动打开小米官网了 获取元素元素的方法有很多种： find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 在这方面网上有很多资料首先我们要定位到一个元素，在这里我们可以用浏览器自带的工具右键登录按钮，点击检查元素，如图： 我们就可以定位到元素了 可以查看到他有着name属性，id属性定位元素的方法多种多样，没有规定一定要用哪一种，适合即可。123name = browser.find_element_by_name("user")#亦或者name = browser.find_element_by_id("username") 于是乎，我们已经定位到账号的输入框了。接下来是输入内容，输入内容可以使用send_keys的方法name.send_keys(&quot;hello&quot;)运行试试看，我们会发现已经成功在输入框中输入我们所要的内容。 同理我们可以定位到密码框passwd = browser.find_element_by_name(&quot;pwd&quot;) 以及往里面填充内容passwd.send_keys(&quot;hello&quot;)如下图所示： 输入完账号密码，最后一步便是点击登录按钮了 12login_button = browser.find_element_by_id("login-button")login_button.click() 运行试试，我们可以看到已经登录过了，当然账号密码是随便输入的。 最后附上代码：123456789101112from selenium import webdriverimport timebrowser = webdriver.Edge()browser.get("https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180")time.sleep(2)name = browser.find_element_by_name("user")name.send_keys("账号")passwd = browser.find_element_by_name("pwd")passwd.send_keys("密码")login_button = browser.find_element_by_id("login-button")login_button.click() 4.其它定位xpath定位 通常情况下，我们不一定能通过name或id定位,这时候我们可以用其它方法，通过xpath就是一种不错的选择，这里以百度的输入框为例。xpath可以通过谷歌浏览器或者其它浏览器直接查看，如图： 单击后即可复制,如下//*[@id=&quot;kw&quot;] 我们可以使用它path = browser.find_element_by_xpath(&quot;//*[@id=&#39;kw&#39;]&quot;) 记得将里面的双隐号改成单隐号，否则报错。可以试试是否定位到了path.send_keys(&quot;hello&quot;) 使用elements定位很多时候元素定位都很模糊，要定位到并不是十分容易，我们可以换个思路，同时定位一组元素，通过取下标的方法，读取元素，以百度的首页为例： 通过查看元素我们可以发现： 上面一组元素具有许多相同的特征，于是我们可以使用如下代码：123elements = browser.find_elements("css selector" , ".mnav")#或是elements = browser.find_elements_by_css_selector(".mnav") 两个定位是相同的，不过写法不同而已，这个方法和之前的区别主要就是find_elements，使用的是复数定位，最后通过下标来选择元素。1elements[0].click() 这样便是点击第一个元素，也就是新闻的按钮。附上测试代码: 5.终 selenium的资料网上很多，遇到问题善用搜索引擎，一般问题都可以得到解决。 大坑这里要特别说明一点，在测试时，浏览器的缩放比例不能调，不能调，不能调。这真的是一个大坑，我当时电脑的缩放比例是125%,定位元素始终不能成功，一直会提示：困扰了我好久，查阅好多资料始终不得解，偶然之下将缩放比例调回100%，终于解决这个问题，这也是我目前遇到最大的坑，在此特别记录，以防自己以后忘记。 最后附上我学习时的参考资料： Selenium2+python自动化45-18种定位方法Python爬虫利器五之Selenium的用法]]></content>
      <categories>
        <category>python记录</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
