<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++并发与多线程（三）]]></title>
    <url>%2F2018%2F12%2F14%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[承接上一篇C++并发与多线程（二） 内容过多分篇记录 设计单例模式共享数据分析 std::call_once的使用 设计模式概括用设计模式写出来的代码程序灵活，维护起来可能方便，但是写出来的代码很晦涩，别人接管代码，阅读代码不大方便 单例设计模式单例设计模式使用频率较高，单例：整个项目中，由某个或者或某些特殊的类，属于该类的对象，只允许创建一个 单例类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class MyCAS&#123;private: MyCAS() //私有化了构造函数 &#123; &#125; private: static MyCAS *m_instance; //静态成员变量public: static MyCAS* GetInstance() &#123; if (m_instance == NULL) &#123; m_instance = new MyCAS(); &#125; static CGarhuishou cl; //静态对象生命周期一直到程序退出 return m_instance; &#125; class CGarhuishou //类中套类，用来释放对象 &#123; public: ~CGarhuishou() &#123; if (MyCAS::m_instance) &#123; delete MyCAS::m_instance; MyCAS::m_instance = NULL; &#125; &#125; &#125;; void func() &#123; cout &lt;&lt; "Test " &lt;&lt; endl; &#125;&#125;;MyCAS* MyCAS::m_instance = NULL;int main()&#123; MyCAS* p_a = MyCAS::GetInstance(); //创建一个对象，返回该类的指针 system("pause"); return 0;&#125; 单例模式本质就是将构造函数私有化，设置静态成员函数进行初始化成员，一旦类中的静态成员不为NULL，就New一个出来，否则返回静态成员 值得一提的是要如何释放它已经new出来的空间，在这里我们要在类中再套一个类，并在构造成员的同时，声明一个static的对象，这个对象会在程序整个生命周期结束的时候，调用自身的析构函数，从而释放整片空间 单例设计模式共享数据分析、解决为了共享单例类的数据，我们引入多线程，但是原先的代码有可能碰到多次new同一个类成员，因此我们需要引入锁，进行双重保护，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;std::mutex rescource_mutex;class MyCAS&#123;private: MyCAS() //私有化了构造函数 &#123; &#125; private: static MyCAS *m_instance; //静态成员变量public: static MyCAS* GetInstance() &#123; // 提高效率 if (m_instance == NULL) //双重锁定，提高效率 &#123; std::unique_lock&lt;std::mutex&gt; mymutex(rescource_mutex); if (m_instance == NULL) &#123; m_instance = new MyCAS(); &#125; static CGarhuishou cl; //静态对象生命周期一直到程序退出 &#125; return m_instance; &#125; class CGarhuishou //类中套类，用来释放对象 &#123; public: ~CGarhuishou() &#123; if (MyCAS::m_instance) &#123; delete MyCAS::m_instance; MyCAS::m_instance = NULL; &#125; &#125; &#125;; void func() &#123; cout &lt;&lt; "Test " &lt;&lt; endl; &#125;&#125;;MyCAS* MyCAS::m_instance = NULL;void initThread()&#123; cout &lt;&lt; "In" &lt;&lt; endl; MyCAS::GetInstance(); cout &lt;&lt; "Out" &lt;&lt; endl; return;&#125;int main()&#123; std::thread t1(initThread); std::thread t2(initThread); t1.join(); t2.join(); system("pause"); return 0;&#125; std::call_once() 函数模板C++11引入的函数，其中第二个参数为函数名，功能：能够保证多线程的情况下，函数A只被调用一次 具备互斥量的能力 据说比互斥量消耗的资源更少 需要结合标记结合使用，std::once_flag，是一个结构，只要once_flag被设置为已调用的状态，后续的函数就不会再被执行了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;std::mutex rescource_mutex;std::once_flag g_flag;class MyCAS&#123; static void createInstance() &#123; m_instance = new MyCAS(); static CGarhuishou cl; //静态对象生命周期一直到程序退出 &#125;private: MyCAS() //私有化了构造函数 &#123; &#125; private: static MyCAS *m_instance; //静态成员变量public: static MyCAS* GetInstance() &#123; std::call_once(g_flag,createInstance); cout &lt;&lt; "CallOnce over" &lt;&lt; endl; return m_instance; &#125; class CGarhuishou //类中套类，用来释放对象 &#123; public: ~CGarhuishou() &#123; if (MyCAS::m_instance) &#123; delete MyCAS::m_instance; MyCAS::m_instance = NULL; &#125; &#125; &#125;; void func() &#123; cout &lt;&lt; "Test " &lt;&lt; endl; &#125;&#125;;MyCAS* MyCAS::m_instance = NULL;void initThread()&#123; cout &lt;&lt; "In" &lt;&lt; endl; MyCAS::GetInstance(); cout &lt;&lt; "Out" &lt;&lt; endl; return;&#125;int main()&#123; std::thread t1(initThread); std::thread t2(initThread); t1.join(); t2.join(); system("pause"); return 0;&#125; 单例模式建议在主线程先创建完对象之后，再开多线程]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++并发与多线程（二）]]></title>
    <url>%2F2018%2F12%2F11%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[承接上一篇C++并发与多线程（一） 内容过多分篇记录 主要涉及多个线程的创建 互斥量的基本概念 创建和等待多个线程可以使用vector进行存储线程，实例代码如下：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;using namespace std;void myprint(int inum)&#123; cout &lt;&lt; "Id: " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; cout &lt;&lt; inum &lt;&lt; endl;&#125;int main()&#123; vector&lt;thread&gt; mythreads; for (int i = 0 ; i &lt; 10 ; i++) &#123; mythreads.push_back(thread(myprint,i)); //这时候一旦创建就开始执行了 &#125; for (auto iter = mythreads.begin() ; iter != mythreads.end() ; iter++) &#123; iter-&gt;join(); &#125; cout &lt;&lt; "I love china" &lt;&lt; endl; system("pause"); return 0;&#125; 数据共享内存分析只读数据只读数据十分安全，不需要特别的处理手段，直接读取即可 有读有写数据如果代码没有特殊处理，肯定崩溃。最简单的不崩溃处理：读的时候不能写，写的时候不能读 互斥量保护共享数据，防止多个线程同时操作同一片内存空间，因此引入互斥量，将数据锁住 lock以及unlock是mutex头文件中定义的函数，要成对使用，否则必然报错，示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; my_mutex.lock(); //cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_mutex.unlock(); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; my_mutex.lock(); //cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); my_mutex.unlock(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 为了防止忘记unlock，引入类似智能指针的类模板std::lock_guard，可以同时取代lock以及unlock两个东西，因此不能再次lock以及unlock12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex); //cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex); //cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 作用原理：std::lock_guard在语句块里面声明，构造函数上锁，出了语句块调用析构函数进行解锁，但是并不如手动上锁进行灵活 死锁死锁的产生死锁产生的前提条件是必须有两个锁（互斥量）才会产生，死锁演示:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; my_mutex.lock(); my_mutex1.lock(); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_mutex.unlock(); my_mutex1.unlock(); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; my_mutex1.lock(); my_mutex.lock(); cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); my_mutex.unlock(); my_mutex1.unlock(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 死锁的一般解决方案 只要保证两个互斥量上锁顺序一致，就不会产生死锁 std::lock()函数模板功能：一次锁住两个或两个以上的互斥量（至少两个），不存在因锁头顺序问题而导致的死锁问题。如果其中一个互斥量没锁住，它就释放已经锁住的锁，直到所有互斥量都锁住。必须手动unlock1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; std::lock(my_mutex,my_mutex1); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); my_mutex.unlock(); my_mutex1.unlock(); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; std::lock(my_mutex,my_mutex1); cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); my_mutex.unlock(); my_mutex1.unlock(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; 使用std::lock和std:lock_guard进行组合默认情况下，std::lock_guard构造的变量会将变量上锁，但是可以手工指定第二个参数为std::adopt_lock进行忽略，std::adopt_lock为一个结构体对象，起到标记作用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; std::lock(my_mutex,my_mutex1); std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; std::lock(my_mutex,my_mutex1); std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; unique_lock取代lock_guardunique_lock是个类模板，工作中一般lock_guard（推荐使用）。unique_lock比lock_guard灵活许多，但是灵活的代价是效率差了点，内存占用大了点。 在缺省的情况下，unique_lock和lock_guard第一个参数都相同，用起来区别不大。lock_guard第二个参数用std::adopt_lock作为标记，表示互斥量已经被标记，必须保证互斥量已经提前被lock过了，否则会报异常。同理unique_lock也可以用这个标记。 std::try_to_lock假设当下有两个线程在争夺一把锁，其中一个线程在拿到锁之后，线程进行休眠，这样子另一个线程则会因此而等待休眠结束。因此我们的第二个参数可以使用try_to_lock try_to_lock：尝试用mutex的lock去锁定这个mutex，但是如果没有锁定成功，会立即返回，并不会阻塞。但是自己千万不能进行手动lock，否则相当于lock两次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; //std::lock(my_mutex,my_mutex1); //std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); //std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); std::unique_lock&lt;std::mutex&gt; sblock(my_mutex,std::try_to_lock); if (sblock.owns_lock()) &#123; //cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; myData.push_back(i); &#125; else &#123; cout &lt;&lt; "Thread1 cannot get lock" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; //std::lock(my_mutex,my_mutex1); //std::lock_guard&lt;std::mutex&gt; sblock(my_mutex,std::adopt_lock); //std::lock_guard&lt;std::mutex&gt; sblock1(my_mutex1,std::adopt_lock); std::unique_lock&lt;std::mutex&gt; sblock(my_mutex,std::try_to_lock); std::chrono::milliseconds dura(200000); std::this_thread::sleep_for(dura); if (sblock.owns_lock()) &#123; cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; myData.pop_front(); &#125; else &#123; cout &lt;&lt; "Cannot get lock" &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; std::defer_lock用这个defer_lock的前提是，你不能自己先lock，否则会报异常。defer_lock就是初始化一个没有加锁的mutex unique_lock的成员函数 lock() 加锁 unlock() 解锁 try_lock() 尝试给互斥量加锁，拿到锁返回true，这个函数不阻塞 release() 返回它所管理的mutex对象指针，并释放所有权。也就是说这个unique_lock和mutex不再有关系（绑定在一起的关系进行分开），如果原来mutex处于加锁状态，有责任接管过来自己解锁。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;mutex&gt;using namespace std;class A&#123;private: list&lt;int&gt; myData; std::mutex my_mutex; std::mutex my_mutex1;public: A() &#123; cout &lt;&lt; "construct A " &lt;&lt; endl;&#125; A(const A* mA) &#123; cout &lt;&lt; "copy construct A " &lt;&lt; endl;&#125; void pushData() &#123; cout &lt;&lt; "Enter pushData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; cout &lt;&lt; "Push data : " &lt;&lt; i &lt;&lt; endl; std::unique_lock&lt;std::mutex&gt; sbguard(my_mutex); std::mutex* ptx = sbguard.release(); ptx-&gt;unlock(); myData.push_back(i); &#125; cout &lt;&lt; "End pushData " &lt;&lt; endl; &#125; void popData() &#123; cout &lt;&lt; "Enter popData " &lt;&lt; endl; for (int i = 0 ; i &lt; 100000 ; i++) &#123; if(!myData.empty()) &#123; cout &lt;&lt; "Pop data : " &lt;&lt; myData.front() &lt;&lt; endl; std::unique_lock&lt;std::mutex&gt; sbguard1(my_mutex1,std::defer_lock); sbguard1.lock(); myData.pop_front(); &#125; &#125; cout &lt;&lt; "End popData " &lt;&lt; endl; &#125;&#125;;int main()&#123; A tempA; std::thread thread1(&amp;A::pushData,&amp;tempA); std::thread thread2(&amp;A::popData,&amp;tempA); thread1.join(); thread2.join(); return 0;&#125; unique_lock所有权的传递unique_lock和mutex进行绑定到一起从而发挥作用，假设std::unique_lock sbguard1(my_mutex1)，sbguard1可以把my_mutex1所有权转移给unique_lock其他对象，但是不允许复制，和智能指针一样 123456789101112std::unique_lock&lt;std::mutex&gt; sbguard2(std::move(my_mutex1)); //移动语义，相当于sbguared2和my_mutex1绑定到了一起//另一种写法class A &#123;public: std::unique_lock&lt;std::mutex&gt; rtn_unique_lock() &#123; std::unique_lock&lt;std::mutex&gt; tmpguard(my_mutex1); //会自动生成unique_lock对象，并调用移动构造函数 return tempguard; &#125;&#125;;]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++并发与多线程（一）]]></title>
    <url>%2F2018%2F12%2F09%2FC%2B%2B%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[C++小白进阶之路 了解多线程是如何编写的 跟随网易云课堂视频学习 内容涵盖线程启动，创建，传参以及detach的坑点 并发，进程，线程两个或者更多的任务同时发生进行，一个程序同时执行多个任务，由操作系统统一调度 进程与主线程唇齿相依，线程可以近似理解成执行代码的通路，且主线程唯一 线程并不是越多越好，每个线程都需要一个独立的堆栈空间（1M理论值），线程需要保存中间状态，耗费本该属于程序运行的时间 多进程并发进程之间的通信（同一个电脑：管道，文件，消息队列，共享内存）（不同电脑：socket通信技术） 多线程并发每个线程都有自己独立的路径，但是一个进程所有线程共享地址空间（共享内存），全局变量，指针，引用都可以在线程之间传递，因此使用多线程的开销远远小于多进程 共享内存带来新问题，数据是否为一致性（线程锁等） 多进程并发和多线程并发虽然可以混合使用，但是建议优先考虑多线程技术而不是多进程 C++11新标准线程库以往Windows：CreateThread() , _beginthread(),_beginthreadexe() 以往Linux:pthread_create() 以往多线程不能跨平台，C++11新标准允许。 线程创建，启动，结束进程结束的标志是主线程是否执行完毕，如果主线程执行完毕了，代表整个进程执行完毕。（一般情况）如果其他子线程还没有执行完毕，那么这些子线程也会被操作系统强行终止。因此得出结论：如果想保持子线程的运行状态，需要保持主线程一直运行。（但是有例外情况） 范例（主线程等待子线程）123456789101112131415161718192021#include &lt;iostream&gt;//包含thread头文件#include &lt;thread&gt;//创建一个函数void myprint()&#123; std::cout &lt;&lt; "Thread begin.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; return;&#125;int main()&#123; std::thread myobj(myprint); //阻塞主线程，并等待myprint子线程执行完毕 myobj.join(); std::cout &lt;&lt; "I love China!" &lt;&lt; std::endl; system("pause"); return 0;&#125; join阻塞主线程，当子线程执行完毕，才可以继续往下运行 范例（主线程不等待子线程）传统多线程程序，主线程需要等待子线程执行完毕，然后自己再最后退出 detach分离，一旦detach之后，与主线程关联的thread对象，就会失去与主线程的关联，此时子线程就会驻留在后台运行，（主线程跟子线程相当于被C++运行时库接管），当子线程执行完毕之后，由运行时库负责清理该线程相关的资源（守护线程） 123456789101112131415161718192021#include &lt;iostream&gt;//包含thread头文件#include &lt;thread&gt;//创建一个函数void myprint()&#123; std::cout &lt;&lt; "Thread begin.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; return;&#125;int main()&#123; std::thread myobj(myprint); myobj.detach(); std::cout &lt;&lt; "I love China!" &lt;&lt; std::endl; system("pause"); return 0;&#125; joinable函数判断是否可以成功调用join或者detach函数，返回true或者false 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;//包含thread头文件#include &lt;thread&gt;//创建一个函数void myprint()&#123; std::cout &lt;&lt; "Thread begin.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; std::cout &lt;&lt; "Thread end.." &lt;&lt; std::endl; return;&#125;int main()&#123; std::thread myobj(myprint); myobj.join(); if (myobj.joinable()) &#123; std::cout &lt;&lt; "1:joinable() == true" &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; "2:joinable() == false" &lt;&lt; std::endl; &#125; std::cout &lt;&lt; "I love China!" &lt;&lt; std::endl; system("pause"); return 0;&#125; 一旦join或者detach之后，joinable返回false，再次调用引发异常 其他创建线程的手法用类进行调用1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class TA&#123;public: void operator()() &#123; cout &lt;&lt; "我的线程开始执行了" &lt;&lt; endl; cout &lt;&lt; "我的线程结束了" &lt;&lt; endl; &#125;&#125;;int main()&#123; TA ta; thread myobj(ta); myobj.join(); cout &lt;&lt; "I love China!" &lt;&lt; endl; system("pause"); return 0;&#125; 使用detach的坑123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;class TA&#123;public: int &amp;m_i; TA(int &amp;i) : m_i(i) &#123; &#125; void operator()() &#123; cout &lt;&lt; "m_i1 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i2 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i3 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i4 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i5 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; cout &lt;&lt; "m_i6 value is " &lt;&lt; m_i &lt;&lt; endl; &#125;&#125;;int main()&#123; int myi = 6; TA ta(myi); thread myobj(ta); myobj.detach(); cout &lt;&lt; "I love China!" &lt;&lt; endl; return 0;&#125; 由于传入的myi是引用，当程序结束时，变量被回收，子线程将是不确定的值 新问题出现了，当程序结束的时候，对象被回收了，但是却不影响调用，因此得出结论，对象是被复制到线程当中去的，ta被销毁，所复制的ta对象依然存在 用lambda表达式123456789101112131415#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;int main()&#123; auto mylambda = []&#123; cout &lt;&lt; "线程开始执行了" &lt;&lt; endl; &#125;; thread myobj(mylambda); myobj.join(); cout &lt;&lt; "I love China!" &lt;&lt; endl; system("pause"); return 0;&#125; 线程传参传递临时对象作为线程参数1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;void myprint(const int &amp;i,char* pmybuf)&#123; //不推荐用引用传参，绝对不要用指针 cout &lt;&lt; i &lt;&lt; endl; //分析认为,i的地址和main函数中i地址不相同，因此i的值是安全的（i被复制了一份） cout &lt;&lt; pmybuf &lt;&lt; endl; //pmybuf指向的是main函数中的mybuf，不安全 return;&#125;int main()&#123; int mvar = 1; int&amp; mvary = mvar; char mybuf[] = "this is a test!"; thread myobj(myprint,mvar,mybuf); myobj.detach(); cout &lt;&lt; "I Love China" &lt;&lt; endl; return 0;&#125; （陷阱1）如上可以看出参数为引用虽然可以，但是不大推荐，指针则是极其危险的。但是一定要传的话，可以尝试将char* pmybuf 更改为const string&amp; pmybuf（依然有BUG） （陷阱2）mybuf到底在何时转为string的？因此可以用如下改法 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;void myprint(const int &amp;i,const string&amp; pmybuf)&#123; //不推荐用引用传参，绝对不要用指针 cout &lt;&lt; i &lt;&lt; endl; //分析认为,i的地址和main函数中i地址不相同，因此i的值是安全的（复制的） cout &lt;&lt; pmybuf &lt;&lt; endl; //pmybuf指向的是main函数中的mybuf，不安全 return;&#125;int main()&#123; int mvar = 1; int&amp; mvary = mvar; char mybuf[] = "this is a test!"; //thread myobj(myprint,mvar,mybuf); //存在mybuf被回收了，才开始复制 //正确写法 thread myobj(myprint,mvar,string(mybuf)); myobj.detach(); cout &lt;&lt; "I Love China" &lt;&lt; endl; return 0;&#125; 小结 若传递int这种简单类型参数，建议都是值传递，不要用引用，防止节外生枝 如果传递类对象，避免隐式类型转换，全部都在创建线程时，构造出临时对象，函数体使用引用来接 终极结论：建议不使用detach，只使用join，这样就不存在局部变量失效导致对内存的非法引用。 传递临时对象作为线程参数（续）线程id可以通过标准库函数获得如下：1std::this_thread::get_id(); 传递类对象、智能指针作为线程参数类对象默认往线程中传递类对象时，假设目前有类A，即使自己使用的是const A&amp; a，依然会拷贝构造出一个类对象，且const必须加，不加新型编译器会报错。 std::ref函数则可以真正将一个对象传递进去，且const可以去掉，成员变量也不需要使用mutable关键字，ref函数传入的类对象不会被复制，因此主线程和新建的线程使用的是同一个对象，写法如下： 12class A;std::ref(A); 智能指针unique_ptr智能指针直接作为参数传入会报错，因此需要使用std::move进行传输，代码如下： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;void myprint(unique_ptr&lt;int&gt; i)&#123; //不推荐用引用传参，绝对不要用指针 cout &lt;&lt; *i &lt;&lt; endl; //分析认为,i的地址和main函数中i地址不相同，因此i的值是安全的（复制的） cout &lt;&lt; "Thread new : " &lt;&lt; std::this_thread::get_id() &lt;&lt; endl; return;&#125;int main()&#123; unique_ptr&lt;int&gt; myp(new int(100)); thread myobj(myprint,std::move(myp)); myobj.join(); system("pause"); return 0;&#125; 用成员函数指针作为线程函数第一个参数为成员函数的地址，第二个参数为传入的类成员 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;using namespace std;class A&#123;public: void say() &#123; cout &lt;&lt; "Son thread begin.." &lt;&lt; endl; &#125;&#125;;int main()&#123; A myobj; thread mytobj(&amp;A::say,&amp;myobj); mytobj.join(); system("pause"); return 0;&#125; 类成员尽量使用引用传入函数，可以保证使用的是同一个类成员而不被复制一份]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmake的使用]]></title>
    <url>%2F2018%2F11%2F04%2Fcmake%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用开源框架SeetaFaceEngine需要手动改写CMakeList.txt 简要入门cmake的使用 单个源文件 目录树如下： 1234cpp├── build├── CMakeLists.txt└── main.cpp 源文件放置于根目录，进行CMakeLists.txt的编写 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Hello)# 指定生成目标add_executable(Hello main.cpp) 切换到目录build，使用cmake .. &amp;&amp; make进行编译，即可得到可执行文件Hello 12345678910# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Hello)# 指定生成目标# 这里指定目录，得到变量# 格式：aux_source_directory(&lt;dir&gt; &lt;variable&gt;)aux_source_directory(. DIR_SRCS)add_executable(Hello $&#123;DIR_SRCS&#125;) 多个目录多个源文件 现有目录如下： 1234567cpp├── CMakeLists.txt├── include│ └── temp.h└── src ├── main.cpp └── temp.cpp temp中含有一个say函数，再main函数中进行调用，编写CMakeLists如下： 1234567891011121314cmake_minimum_required(VERSION 2.6)project(hello)#引入头文件include_directories(./include)#导入目录aux_source_directory(. PROJECT_ROOT)aux_source_directory(./src SRC)add_executable(hello $&#123;PROJECT_ROOT&#125; $&#123;SRC&#125;)#生成共享库add_library(libhello SHARED $&#123;PROJECT_ROOT&#125; $&#123;SRC&#125;) 常用编译选项1234567891011#设置工程所生成的目标文件所需要的链接的库，在这里我们需要libhello.so这个库target_link_libraries ($&#123;PROJECT_NAME&#125; libhello)#add_definitions 设置编译选项add_definitions (&quot;-g&quot;) #-g编译成可调试的程序#设置编译好的可执行文件在执行时连接库的路径set (CMAKE_INSTALL_RPATH .;/usr/local/lib64)set (CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)add_subdirectory #将工程中的子目录加入编译工程中,子目录当中需要CMakeLists.txt文件]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux下的QQ配置]]></title>
    <url>%2F2018%2F06%2F17%2Farchlinux%E4%B8%8B%E7%9A%84QQ%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[QQ重度患者 Linux配置QQ过程繁琐，坑众多 在此记录Linux下的QQ配置 发行版：archlinux 64位 安装wine 由于是基于archlinux，所以安装配置十分简单 首先先启用Multilib仓库 1234sudo vim /etc/pacman.conf#取消以下注释[multilib]Include = /etc/pacman.d/mirrorlist 更新系统 1sudo pacman -Syy 安装wine 1sudo pacman -S wine wine_gecko wine-mono winetricks wine的版本问题 最新的wine版本似乎不支持直接使用 可以在官方wiki找到如下： Archlinux打包的wine-3.8与wine-3.9.1版本均在安装QQ后无法打开，出现无法加载gdi32.dll的错误 可以使用命令“sudo pacman -U /var/cache/pacman/pkg/wine-3.7-1-x86_64.pkg.tar.xz”将wine降级到之前的3.7版本解决。 为了避免被升级到新3.9版本而无法使用QQ，可以编辑”/etc/pacman.conf”文档，去掉”IgnorePkg”一行前面的”#”号，并在该行”=”号后面添加”wine”；在后续更新中该问题得到解决后，记得去掉wine，以便更新之。 可以很明显观察到如果想要使用QQ，必须将wine降级到3.7 所以需自行下载wine3.7的安装包手动降级 找到下载地址：wine3.71sudo pacman -U wine-3.7-1-x86_64.pkg.tar.x 安装QQ 由于目前许多QQ都十分不稳定 官方wiki中的deepin-qq-im在这里安装完后无法使用，谷歌许久后，选择清风QQ进行安装 地址如下：清风QQ 下载完其中压缩包之后，按说明的命令进行解压 1tar xvf wineQQ9.0.3_23719.tar.xz -C ~/ 解压完之后即可在程序中看到QQ的图标 已知问题 无法记住密码 无法打开群文件 无法使用我的手机进行传输文件 删除方法123rm -rf ~/.winerm -rf ~/.local/share/applications/wine-QQ.desktoprm -rf ~/.local/share/icons/hicolor/256x256/apps/QQ.png 参考文章清风的网络空间ArchLinux安装配置WineQQ]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile的编写]]></title>
    <url>%2F2018%2F06%2F13%2Fmakefile%E7%9A%84%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[在linux下一旦需要编译的文件过多 使用gcc过于繁琐，可以通过编写makefile文件来减轻工作量 记录如何编写makefile 创建makefile文件 首先在工程目录当中创建一个makefile文件 早期makefile首字母必须大写，不过现在大小写均可 基本makefile格式 编写格式如下： 1234target: dependencies command//dependencies为需要的依赖//command为需要的命令 示例如下 12test: HelloWorld.cpp g++ HelloWorld.cpp -o test make编译 使用make命令进行直接编译 多个文件编写makefile 假设当前目录下拥有三个文件 123main.ctool.ctool.h 编写如下makefile 123456main: main.c tool.o gcc main.c tool.o -o main//但是tool.o并不存在所以需要告知编译器tool.o位置tool.o: tool.c gcc -c tool.c//-c代表直接编译成.o的文件 常见后端文件用途12345678910Windows下：h：头文件，给编译器用来检查语法lib：主要包含了如何找到函数的地址的信息，以及附带一些编译了一半的二进制数据obj：编译了一半的二进制数据dll、exe：可以运行linux下：.o,是目标文件,相当于windows中的.obj文件 .so 为共享库,是shared object,用于动态连接的,相当于windows下的dll .a为静态库,是好多个.o合在一起,用于静态连接 lib和DLL的区别 lib是编译时需要的，dll是运行时需要的。缺少dll文件程序将无法运行（动态链接库），而lib文件则是静态链接库 obj文件 obj里存的是编译后的代码跟数据，并且有名称，所以在连接时有时会出现未解决的外部符号的问题。当连成exe后便不存在名称的概念了，只有地址。lib就是一堆obj的组合。 删除指令 使用clean指令进行删除不必要的文件 12clean: rm *.o main 运行make clean进行删除文件 在makefile当中设置变量 设置变量的方式与普通编程语言方式差别不大，如下例子 1CC = gcc 具体使用的时候需要%符号 12main: main.c test.o $(CC) main.c test.o -o main 编写两个可执行文件 默认情况下似乎无法同时编译出两个可执行文件 假设需要编写两个可执行文件，文件名为main_max,main_min 须在开头加入：1all: main_max main_min]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <url>%2F2018%2F06%2F13%2Fgdb%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在linux下面使用gdb进行断点调试 介绍如何操作gdb 编译文件 平时调试代码直接使用gcc或g++即可编译 1gcc test.c -o test 需要使用gdb编译需要加上-g参数 1gcc -g test.c -o test 调试文件 使用gdb命令打开文件1gdb test 常用命令设置断点 使用b设置断点1b main //在main函数设置断点 运行命令 使用r运行程序 单步运行 使用n进入下一行（不进入的单步执行） 使用s为进入的单步执行，finish为单步跳出 显示变量 p可以显示变量名1p 变量名 查看代码 使用list，简写l 查看断点，监视 info b //断点 info watch //监视 运行到下一个断点 continue 简写为c 终止运行 使用kill来终止 删除断点 使用delete breakpoint 1 //需先使用info进行查看 检查汇编 disas 查看汇编代码 查看寄存器内容 info registers 查看寄存器的值，可以用print $name 打印寄存器内容 每步执行 stepi 检查寄存器或某个地址 x $rsp]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django+nginx+uwsgi进行服务器部署]]></title>
    <url>%2F2018%2F06%2F08%2Fdjango-nginx-uwsgi%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[django的服务器配置可以说是十分繁琐的部分 哪怕严格按照步骤也会有不明错误 再此详细记录操作步骤 版本Ubuntu 16.04 LTS 64位 服务器：腾讯云学生机 由于配置繁琐，所以操作步骤实在全新系统进行配置 准备django文件 由于已经有过django项目，所以直接将django上传至服务器 目录树如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ubuntu@VM-246-186-ubuntu:~/site$ tree BlogBlog├── Blog│ ├── __init__.py│ ├── __pycache__│ │ ├── __init__.cpython-36.pyc│ │ ├── settings.cpython-36.pyc│ │ ├── urls.cpython-36.pyc│ │ └── wsgi.cpython-36.pyc│ ├── settings.py│ ├── urls.py│ └── wsgi.py├── db.sqlite3├── manage.py├── myblog│ ├── admin.py│ ├── apps.py│ ├── __init__.py│ ├── migrations│ │ ├── 0001_initial.py│ │ ├── __init__.py│ │ └── __pycache__│ │ ├── 0001_initial.cpython-36.pyc│ │ └── __init__.cpython-36.pyc│ ├── models.py│ ├── __pycache__│ │ ├── admin.cpython-36.pyc│ │ ├── __init__.cpython-36.pyc│ │ ├── models.cpython-36.pyc│ │ ├── urls.cpython-36.pyc│ │ └── views.cpython-36.pyc│ ├── static│ │ └── myblog│ │ ├── css│ │ │ ├── semantic.css│ │ │ └── themes│ │ │ └── default│ │ │ └── assets│ │ │ ├── fonts│ │ │ │ ├── brand-icons.eot│ │ │ │ ├── brand-icons.svg│ │ │ │ ├── brand-icons.ttf│ │ │ │ ├── brand-icons.woff│ │ │ │ ├── brand-icons.woff2│ │ │ │ ├── icons.eot│ │ │ │ ├── icons.otf│ │ │ │ ├── icons.svg│ │ │ │ ├── icons.ttf│ │ │ │ ├── icons.woff│ │ │ │ ├── icons.woff2│ │ │ │ ├── outline-icons.eot│ │ │ │ ├── outline-icons.svg│ │ │ │ ├── outline-icons.ttf│ │ │ │ ├── outline-icons.woff│ │ │ │ └── outline-icons.woff2│ │ │ └── images│ │ │ └── flags.png│ │ └── js│ │ ├── jquery-3.3.1.js│ │ ├── jquery-3.3.1.min.js│ │ ├── semantic.js│ │ └── vue.js│ ├── tests.py│ ├── urls.py│ └── views.py└── templates └── myblog ├── detail.html └── index.html 目录树不必在意，主要操作的文件为manage.py 配置环境安装依赖 Ubuntu系统默认为python2，但是这里测试的django版本为2.0以上，需要python3版本来安装 为了防止打乱系统环境，还需要virtualenv进行管理python环境 12sudo apt-get install python3-pipsudo pip install virtualenv 准备就绪之后进行创建新环境 12virtualenv env27 --python=python3.5#其中env27为环境名称，自己替换 进入新环境 1source test/bin/activate 由于我的django项目中包含了django-suit以及markdown，所以在运行django前需要提前准备完这两个包 1(test) ubuntu@VM-246-186-ubuntu:~/site$ pip install django django-suit markdown 进行django测试 在云服务器上部署确保安全组端口已经开放 确保是在虚拟环境当中，注意命令行前的test配置setting文件 首先要让服务器知道静态文件的位置以及允许访问的ip 进入Blog目录中，编辑setting.py文件 1234567#找到ALLOWED_HOSTS = []#将其配置为ALLOWED_HOSTS = ['*']#配置静态文件目录，在文件尾部直接添加STATIC_ROOT = os.path.join(BASE_DIR , "static/")#找到DEBUG = True，改为False，亦可最后再来改动方便定位错误DEBUG = False 配置完毕之后，回到根目录执行收集静态文件操作 1python manage.py collectstatic 可以看到在目录当中生成了一个static的文件夹，该文件夹包含了网站的全部静态文件 登录网站测试 在项目根目录处运行服务器测试命令，确保8001端口未被占用，如果被占用需手动指定端口号 1python manage.py runserver 0.0.0.0 8001 如果一切顺利的话，应该可以通过IP进行直接访问网站 在浏览器输入IP地址+端口号进行服务器测试 可以观察到网站可以进入，并且CSS样式加载正常 安装uwsgi 由于前面环境已经配置妥当，安装uwsgi只需要一句命令，请确保在虚拟环境当中 1pip install uwsgi 在网站根目录下执行 12uwsgi --http :8001 --plugin python --module Blog.wsgi# 其中Blog.wsgi需要自行替换成自己的网站名字，比如自己的网站APP为Test，则修改为Test.wsgi 通过访问IP地址加端口号进行测试，例如118.25.3.239:8001（例子虚拟，自行替换IP） 如果访问正常我们应该看到的是不带CSS样式的界面 配置uwsgi文件 为了让服务器可以运行，我们需要手动在根目录创建一个uwsgi.ini的文件 内容如下： 1234567891011121314[uwsgi]#chidr用于指定自己的网站根目录（自行更改）chdir = /home/ubuntu/Blog#module指定网站中APP的文件（自行更改）module = Blog.wsgi#home用于指定python的虚拟环境，即我们最初创建的虚拟环境位置（自行更改）home = /home/ubuntu/env27#master不用更改master = true#socket用于指定端口号，可以不更改socket = :8001#以下两个可以不用更改chmod-socket = 666vacuum = true 配置完内容之后可以在shell中运行，并访问网站观察十分成功运行 1sudo uwsgi --ini uwsgi.ini 配置nginx 安装过程很简单，一句命令 1sudo apt-get install nginx nginx安装完默认是启动的，可以通过直接在浏览器访问ip的方式观察到nginx的欢迎界面 这里我原先使用的Chrome浏览器，不知为何会强制重定向到https，导致网站无法访问 更换浏览器以后访问便正常了 推荐使用edge或者自带的ie进行简单的测试 nginx默认会读取/etc/nginx/sites-enabled/default文件中的配置，修改其中配置如下： 123456789101112131415161718upstream django &#123; server 127.0.0.1:8001; #此处端口可以替换，需与uwsgi.ini之中的端口一致&#125;server &#123; listen 80; server_name 118.25.3.239; #此处需要自行替换成自己的IP地址 charset utf-8; client_max_body_size 75M; #django配置文件 location /static &#123; alias /home/ubuntu/Blog/static; #此处需要自行替换为网站根目录下的静态文件夹 &#125; #以下不必改动 location / &#123; uwsgi_pass django; include /etc/nginx/uwsgi_params; &#125;&#125; 重启服务器 一切配置完毕之后，执行命令 1sudo /etc/init.d/nginx restart 浏览器中输入IP即可发现网站成功构建完毕 参考文章及视频文章 很详细的一篇文章 Ubuntu上通过nginx部署Django笔记视频 视频讲解非常透彻，如果一步一步跟着执行出错可能性极低 【教程】Nginx + uWsgi 部署 Django + Mezzanine 生产服务器(「自由小径」自由软件教程) - 1/2 【教程】Nginx + uWsgi 部署 Django + Mezzanine 生产服务器(「自由小径」自由软件教程) - 2/2]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective c++ 记录]]></title>
    <url>%2F2018%2F04%2F06%2FEffective-c%2B%2B-%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[改善程序与设计55个具体做法 防止阅后遗忘 再次记录易于遗忘的条款 条款2：尽量使用const，enum,inline替换#define 取一个const地址是合法的，但取一个enum，和#define的地址就不合法。 12enum &#123;NumTurn = 5&#125;;//近似看成#define NumTurn 5 单纯常量：最好以const对象或enum替换#define，对于宏，使用inline函数替换#define。 const出现在类型前面和类型和后面表达的意思相同，如下： 12345678910111213141516171819202122232425const int a;int const a;``` - const出现在指针\*前面代表物是常量，在\*后面代表指针自身是常量。- 如果一个变量申明有mutable，即便在const的成员函数当中，也可以修改。- const_cast的使用```cpp#include &lt;iostream&gt;using namespace std;int main()&#123; /*似乎发生了常量折叠，在编译阶段，对该变量进行值替换，同时，该常量拥有自己的内存空间，并非像宏定义一样不分配空间。*/ const int a = 20; int&amp; b = const_cast&lt;int&amp;&gt;(a); cout &lt;&lt; b &lt;&lt; endl; //20 b = 30; cout &lt;&lt; b &lt;&lt; endl; //30 cout &lt;&lt; a &lt;&lt; endl; //20 return 0;&#125; 条款4：确定对象被使用前已被初始化 使用local static对象替换non-local static对象，如下使用函数来唯一初始化一个对象：12345678class FileSystem&#123;...&#125;;FileSystem&amp; tfs()&#123; //使用static进行初始化，并返回该对象的引用 static FileSystem fs; return fs;&#125;//使用tfs()来获得该对象 条款6：若不想使用编译器自动生成的函数，就该明确拒绝 所有编译器默认生成的函数都属于public，如果不想使用他们，则应明确将其申明为private 使用专门的基类来防止被拷贝，如下：123456789class Uncopyable&#123;protected: Uncopyable()&#123;&#125; ~Uncopyable()&#123;&#125;private: Uncopyable(const Uncopyable&amp;); //参数名称可写可不写，反正不予实现。 Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;; 条款7：为多态基类声明virtual析构函数 对于大多数人的心得而言：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。 c++并没有禁止派生的机制，所以尽量不要继承STL容器，STL容器当中析构函数并非虚析构 条款8：别让异常逃离析构函数 析构函数绝对不要吐出异常，如果产生异常将导致异常之后的代码无法执行，会导致资源泄露 如果需要对异常做出反应，那么class应该提供一个普通函数（非析构函数）来处理异常 try中出现异常，try中的后继代码不执行，但是try之外的代码需要执行 使用如下代码将释放资源代码返回客户手上，并拥有双保险123456789101112131415161718192021222324252627class DBConn&#123;public: ... void close() &#123; db.close(); &#125; ~DBConn() &#123; if (!closed) &#123; try &#123; db.close(); &#125; catch (...) &#123; //制作运转记录，记下调用close失败的原因 ... &#125; &#125; &#125;private: DBConnection db; bool closed;&#125;; 条款09：绝不在构造和析构函数中调用virtual函数 由于基类的构造函数会先被调用，即如果在基类构造函数中有virtual函数，调用的是基类的函数，而非派生类的函数 对象在基类构造函数执行之前不会成为一个真正的对象（成品） 析构函数一旦开始执行，所有成员变量便成为未确定的值，所以virtual也被认为是基类的函数。 所以确保构造函数和析构函数当中没有虚函数，哪怕是他们调用的函数也要服从该约定 条款10：令operator=返回一个reference to *this 赋值操作符尽量返回的是reference to *this（this的引用），如 **return \this** 尽可能返回const的类型，可阻止用户因自定义类型而犯错 条款11：在operator=中处理“自我赋值“ 先查看一份不安全代码 1234567891011121314class Bitmap&#123;...&#125;;class Widget&#123;...private: Bitmap* pb;&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;// 一旦使用如上代码进行自我赋值，pb将会被销毁 传统的改进方法是增加”证同测试“，加入如下语句： 1if (this == &amp;rhs) return *this; 我们只需在复制pb时无需删除pb即可改进代码，如下 1234567Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 所以确定任何函数操作一个以上的对象时候，并且多个对象是同一个对象的时候，其行为依然正确。 条款12：复制对象时勿忘其每一个部分 在任何时候只要你承担起“为派生类编写构造函数的”责任，必须保证基类所有的成分都被复制。 由于大多数时候基类成员为private，所以应让派生类的构造函数调用相应的基类函数。 在派生类中重载=，需要对基类的成分同样将进行赋值，使用如下代码： 12345PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)&#123; //假设基类为Customer Customer::operator=(rhs);&#125; 在派生类构造函数当中调用copy assignment是不合法的，以至于根本没有这样的语法。 条款13：以对象管理资源 可以使用auto_ptr智能指针进行释放内存 1234567Investment* createInvestment();void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); &#125;// 多个auto_ptr不允许指向相同的对象// 若是通过拷贝构造函数或使用赋值运算符复制auto_ptr，它们会变成NULL auto_ptr的替代方案为shared_ptr，如下代码： 12345void f()&#123; std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());&#125;//shared_ptr允许复制 但是两个指针销毁时候都是使用delete，而不是delete[]，所以不允许指向动态分配而得的数组 条款15：在资源管理类中提供对原始资源的访问 shared_ptr和auto_ptr都提供一个get成员函数，可以用来显示转换，也就是可以返回智能指针内部的原始指针，假设如下代码： 1234int daysHeld(const Investment* pi);std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());int days = daysHeld(pInv); //错误的用法，需要Investment类型的指针，不是传递shared_ptr的对象int days = daysHeld(pInv.get()); //正确的用法 shared_ptr和auto_ptr也重载了运算符-&gt;和*，可以像平时指针一样使用。 条款16：成对使用new和delete时要采取相应的形式 为了避免一些潜在错误，尽量不要对数组使用typedef，如下代码：1234typedef std::string AddressLines[4];std::string* pal = new AddressLines;delete pal; //错误，是一个数组delete[] pal; //正确 条款17：以独立语句将newed对象置入智能指针 如果不这么做的话，一旦抛出异常，将造成指针指向未知位置，造成难以察觉的内存泄漏 条款18：让接口容易被正确使用，不易被误用 假设有如下不安全代码： 12345678class Date&#123;public: Date(int month , int day , int year); ...&#125;;//如果使用如下代码调用，将会导致使用方式出错Date d(30,3,1995); 改进了之后，代码如下： 123456789101112131415161718192021struct Day&#123; explicit Day(int d) : val(d) &#123;&#125; int val;&#125;;struct Month&#123; explicit Month(int d) : val(d) &#123;&#125; int val;&#125;;struct Year&#123; explicit Year(int d) : val(d) &#123;&#125; int val;&#125;;class Date&#123;public: Date(const Month&amp; m , const Day&amp; d, const Year&amp; y);&#125;;//如果使用这种方法创建就可以预防出错。 条款20：宁以pass-by-reference-to-const替换pass-by-value 使用引用(by reference)的方式可以避免对象切割(slicing)的问题 。 条款21：必须返回对象的时候，别妄想返回其reference 假设有如下代码： 123456const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)&#123; Rational result(lhs.n * rhs.n , lhs.d * rhs.d); return result;&#125;//一旦函数结束了之后，result被释放，返回引用将被定义为不明确的行为 再看如下代码，以下代码试图完善上文代码: 123456const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)&#123; Rational* result = new Rational(lhs.n * rhs.n , lhs.d * rhs.d); return *result;&#125;//代码看似可以完成任务，确无法决定谁对代码进行delete 条款22：将成员变量声明为private 如果不出意外尽量都将成员变量声明为private。 protected并不比public更具封装性 条款23：宁以non-member,non-friend替换member函数 面对对象守则要求，数据以及操作数据的那些函数应该被捆绑在一块，这句话其实并不正确。 如果使用成员函数，则对类有较大的操纵权限，所以可以考虑友元函数或者普通函数进行操纵成员。]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux小记]]></title>
    <url>%2F2018%2F03%2F15%2Flinux%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[偶然发现自己一些常用的命令经常忘记 在此做一些笔记 记录学习linux的琐事 fsck修复 如果文件系统损坏，出现分区受损，可以使用如下命令，结束后使用reboot重启 1fsck -y /dev/sdXX #第一个X指的是硬盘，第二个X指的是分区 如果不知道哪个分区受损，直接使用fsck修复就好了 文件权限变更 以下三个命令可以使用-R参数进行递归操作 使用chgrp变更组 使用chown变更所有者 使用chmod变更权限 w权限主要用于修改目录，增删文件这类操作，而r用于查看目录，最后x用于是否可以进入这个目录 用户管理增加用户 使用useradd 添加用户，常用选项如下： 1234567-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。用户名 指定新账号的登录名。 可以使用如下代码生成一个用户 1useradd -d /home/test -m test -s /bin/bash 修改用户 常使用：usermod 选项 用户名 来改变一个用户的属性 Vim强行保存 如果以普通用户编写了文件，但是发现权限不足时，可以使用强行保存：1:w !suod tee % python快速开httpserver 使用如下命令：1python3 -m http.server]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习记录]]></title>
    <url>%2F2018%2F03%2F05%2FC%2B%2B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学校课程新增C++ 记录易错知识点以及易忘知识点 大坑待填 cout有控制符，如转换进制的如下： 1234cout &lt;&lt; hex &lt;&lt; ;hex 十六进制oct 八进制dec 十进制 const 与 #define 不同，它拥有存储单元，有地址，指针可指向它。建议取代define. const在指针的不同位置： 1234567const char* name = "chen"; //当const位于类型前面的时候，内容不允许改变，指针指向的地址可以改变。name[3] = 'o'; //不允许name = "hello"; //允许char* const name = "chen"; //当const位于类型后面的时候，代表常指针，指针所指向的地址不允许改变。name[3] = 'o'; //允许name = "hello"; //不允许 const常用于操作数组时，不改变数组内容。 函数省略类型时，默认为int。 inline内联函数定义必须在头文件中实现。 函数指定默认值的参数必须放在最右侧，以便达到一一对应。 函数重载以参数个数及其类型判断，即可以参数个数相同，类型不同。返回值类型不参与判断！！！ 可以使用::访问全局变量，如下： 123456int x;int main()&#123; int x; cout &lt;&lt; ::x;&#125; union可以有多个成员，但是只能使用一个成员变量。 使用new进行分配空间时，需要提供所有维大小。（待定） 引用必须初始化，可以作为返回值。 不允许建立void类型的引用，不能建立引用的数组。 引用不是一种数据类型，指针是。所以没有引用的引用，也没有引用的指针。 结构体成员变量默认为public，而类默认为private。 C++推荐在类外定义函数，如果在类内定义函数，则默认为inline内联函数。 在类声明中，不允许对数据成员赋值。 类在实例化对象时，不允许加括号，如下 12CPeople xiaoming(); //不允许，这代表实例化一个CPeople的函数CPeople* xiaohong = new CPeople(); //允许，并且推荐这种写法。 构造函数是没有返回值，哪怕是void。 const对象以及引用对象，必须在构造函数的初始化列表中进行初始化。 数据成员是按照类中声明顺序进行初始化，而与初始化中的列表无关。（重要） 析构函数不允许被重载。 类数组，如果只有一个成员数据，可以使用大括号进行初始化。如果两个参数，可以如下： 1CPeople pep[3] = &#123; CPeople(1,2) , CPeople(2,3) , CPeople(3,4) &#125;; 在写一个函数的时候，尽量为其完善构造函数，拷贝构造，析构函数。 使用拷贝构造时，默认使用浅拷贝，如果遇到指针在里面，需要注意指针，使用深拷贝。即构造函数参数为：const&amp; 类名。 调用拷贝构造有三种情况。 1231.一个类初始化另一个类2.函数的参数是类的对象3.函数的返回值是类的对象 一个类多个对象数据共享，需要使用静态成员。 静态成员应在类外初始化，并且在定义对象前就必须初始化完毕。不允许被初始化列表初始化（重要） 静态成员函数主要用于访问静态数据成员。并且如果是private，则不能被外部访问。 静态成员函数没有this指针，并且只能通过对象名来访问静态成员。（重要） 类外定义友元函数，可以不必加上类名，只需保证参数相同。友元函数必须通过入口参数传递进对象名。 友元关系是单项的，不具备交换性。 子类调用构造函数时，如果父类也有构造函数，需要在子类构造函数初始化列表中为父类初始化。 如果将一个对象申明为常对象(类名 const 名字)，则不能调用该对象的非const的成员函数，否则报错。常成员函数例子如下：void print() const; 常成员函数只能用于类中，并且可以和同名非常函数进行重载。 继承如果不指定类型，默认以private继承。 子类可以继承父类的private成员，但是需要父类提供的public函数才能访问。 如果一个函数的参数为int&amp; ，则它不可以传入类似i3这样的变量。如果这样做了，在内部可以近似认为生成了一个const int&amp; temp@ = i\3。所以如果参数为const int&amp;，则可以传入不报错。 static在c++和c中有细微的差别，如果在C中加上static代表只能在本文件中访问。 在运算符重载当中，如果运算符右边为整数，则会尝试调用重载函数参数中类的构造函数。（重要，可以使用构造函数将数字转换成类对象） 继承当中，如果父类成员是private，不管使用哪一种继承限定词，子类都是无法直接访问父类成员。 C++推荐使用int(a)这种方式进行强制转换，而不是使用(int)a，进行强制转换，前者更像调用一个函数。 explicit在构造函数之前添加，可以告诉编译器这就是一个构造函数，不能用来强制转换。 operator 目标类型() ，可以用来指定数据类型转换为类的对象 构造函数首先调用基类，然后是类对象成员，最后是派生类的构造函数体。 父类指针可以指向子类，但是只能访问子类从父类继承而来的成员。 虚函数必须是成员函数，不能是友元函数或者是静态成员函数。因为需要特定的对象才能激活虚函数。 输入输出流拥有各种成员函数： 12345cout.put() //输出字符，可以是ASCII码cin.get() //读取一个字符cin.getline() //读取一行cin.ignore(n,终止字符) //跳过n个字符读取，可以只含一个参数//.... 流成员函数进行格式控制： 12345setf(flags) //设置格式unsetf(flags) //取消格式width(n) //指定宽度fill(ch) //填充字符precision(n) //设置小数精度 数组作为函数参数时候，如果使用sizeof计算其大小，会得到指针的大小。 在VC6.0的时候，输入输出流返回必须是引用，因为ostream和istream对象是不可复制的。 函数调用选择顺序如下：非模板函数，显式具体化，模板函数。显式具体化的例子: 1234567891011121314151617181920212223include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;void swaper(T&amp; a , T&amp; b)&#123; T temp = a; a = b; b= temp; return;&#125;template&lt;&gt; void swaper&lt;double&gt;(double&amp;a , double&amp; b)&#123; cout &lt;&lt; a + b &lt;&lt; endl;//调用&#125;int main()&#123; double a = 10 , b = 20; swaper(a,b); //显式具体化后，调用的其实是cout&lt;&lt; a+b; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b; system("pause"); return 0;&#125; const修饰的成员函数可以改变static的变量，因为static变量储存在静态区而不属于类。 使用string类，如果使用&lt;或&gt;比较符，是从左往右比较，与字符长度大小无关 拷贝构造时，基类会被调用，需要自己在初始化列表中调用 引用不允许指向不同的对象，独一无二。 对象在基类构造函数执行之前不会成为一个真正的对象（成品） 析构函数一旦开始执行，所有成员变量便成为未确定的值 namespace和classes不同，namespace可以跨越多个文件，但是classes不行 在类当中，子类是无法赋值给父类，反之可以 c++实现多态引用同样可以实现 一旦继承中出现虚基类，以后继承皆为虚基类（待定） ostream对象不允许拷贝构造，即返回值必须为ostream&amp; operator++为前置运算符，operator++(int)为后置运算符 12345678//exampleclass Base;Base Base::operator++(int)&#123; Base t(*this); this-&gt;num++; return t;&#125; 缺省构造函数即代表没有参数列表的构造函数，一旦手动定义带参数的构造函数，编译器则不会帮我们生成缺省的构造函数]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易Socket编程]]></title>
    <url>%2F2018%2F02%2F28%2F%E7%AE%80%E6%98%93Socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进行简单的socket编程尝试 使用C++和python分别编写服务端与客户端 简单传输文本 代码编写随意，仅供回忆 编程步骤服务端 加载套接字(WSAStartup()) 绑定套接字到IP和端口上(bind()) 设置为监听模式(listen()) 接收到请求后，返回本次请求所对应的套接字(accept()) 发送与接受数据(send()/recv()) 关闭套接字(WSACleanup()) 客户端 加载套接字(WSAStartup()) 发出连接请求(connect()) 发送与接受数据(send()/recv()) 关闭套接字(WSACleanup()) 记录代码C++服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;WinSock2.h&gt;#include &lt;iostream&gt;/*静态加入Lib文件，编译时需加上-lwsock32*/#pragma comment(lib,"ws2_32.lib")int main(void)&#123; WORD sockVersion = MAKEWORD(2, 2); //指定socket版本号 WSADATA wsaData; /*初始化socket库*/ if (WSAStartup(sockVersion, &amp;wsaData)!=0) &#123; return 0; &#125; /*创建套接字*/ /*第一个参数指定IPv4，第二个参数指定流式传输，适用tcp，第三个参数指定tcp协议，设置为0将自动判断*/ SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sin; sin.sin_family = AF_INET; //指定协议 sin.sin_port = htons(6000); //必须采用网络数据格式，使用htons来包装 sin.sin_addr.S_un.S_addr = inet_addr("127.0.0.1"); /*进行绑定*/ if (bind(slisten, (SOCKADDR*)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; std::cout &lt;&lt; "bind error ! " &lt;&lt; std::endl; &#125; /*5为等待连接数目*/ if (listen(slisten, 5) == SOCKET_ERROR) &#123; std::cout &lt;&lt; "listen error" &lt;&lt; std::endl; &#125; /*接受数据*/ SOCKET sClient; sockaddr_in remoteAddr; char revData[255]; int nAddrlen = sizeof(remoteAddr); while (true) &#123; std::cout &lt;&lt; "等待连接" &lt;&lt; std::endl; sClient = accept(slisten, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrlen); std::cout &lt;&lt; "连接成功" &lt;&lt; std::endl; send(sClient, "连接成功" , sizeof("连接成功"), 0); int ret = 1; //为下面接受数据判断 while (ret &gt; 0) &#123; ret = recv(sClient, revData, 255, 0); std::cout &lt;&lt; revData &lt;&lt; std::endl; &#125; &#125; return 0;&#125; python服务端12345678910111213141516import socketHOST = "127.0.0.1"PORT = 50007s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.bind((HOST,PORT))s.listen(1)print("服务器正在运行\n")while True: conn,addr=s.accept() print("connected by %s" %&#123;addr&#125;) conn.send(b'hello') while True: data = conn.recv(1024) print(data.decode("utf-8")) input_data = input("") conn.send(bytes(input_data,"utf-8")) python客户端123456789101112131415import socketimport chardetHOST = "127.0.0.1"PORT = 6000s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((HOST,PORT))while True: rec = s.recv(1024) L = chardet.detect(rec) code = L['encoding'] print(rec.decode(code)) cmd = input('Please input data:') cmd = bytes(cmd,"gb2312") s.send(cmd) s.close()]]></content>
      <categories>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息安全铁三赛write_up]]></title>
    <url>%2F2018%2F01%2F19%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%93%81%E4%B8%89%E8%B5%9Bwrite-up%2F</url>
    <content type="text"><![CDATA[信息安全铁三赛write_up 题目共有六题 随手记录 权限 题目描述：你是管理员吗？ 解题链接：http://ctf4.shiyanbar.com/web/root/index.php 答案格式：flag{} 步骤 首先先浏览网页源代码，易于发现在源代码底部有提示如下： 1&lt;!--password.txt&gt; 可以发现存在password.txt，在地址栏构造出地址如下： 1http://ctf4.shiyanbar.com/web/root/password.txt 可以进入包含一个许多密码的页面，由此可以推测出密码是其中的一个。 密码框长度默认只有5个长度，手动用审查元素找到maxlength=5，将数据改成999 由于密码过多，我们可以需要使用buresuite进行爆破，使用教程可以参考:使用教程 通过爆破以后，我们可以发现Nsf0cuS这个密码有些与众不同。它的提示是这里没有flag哦！ 再次抓包发现Response当中有一项： 1Set-Cookie: newpage=MjkwYmNhNzBjN2RhZTkzZGI2NjQ0ZmEwMGI5ZDgzYjkucGhw; 使用base64解码后得到一个php文件，如下： 1290bca70c7dae93db6644fa00b9d83b9.php 构造URL后可以看到小黑留言板，再次抓包尝试 通过分析发现Cookie中有个IsLogin=0这个参数，并且userlevel为guest 将IsLogin改为1，userlevel改为root，点击go再次尝试 可以得到flag为： 1Flag=flag%7BC0ngratulati0n%7D 使用url解码得到flag为 1Flag=flag&#123;C0ngratulati0n&#125; IOS 题目描述：无 解题链接：http://ctf4.shiyanbar.com/web/IOS/index.php 答案格式：flag{} 步骤 通过界面可得系统已经升级到ios99，可以通过抓包修改user-agent来更改所需系统 user-agent如下： 1User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 99 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A5313e Safari/7534.48.3 发送后得到flag为： 1flag&#123;LMvBi8w9$m1TrgK4&#125; 照猫画虎 题目描述：照猫画虎 解题链接：http://ctf4.shiyanbar.com/web/copy/index.php 答案格式：flag{} 步骤 通过界面可知1234567890th的访客可以得到奖励，当前是2699th的访客 抓包分析，发现Request中存在如下： 1Visitor=MjY5OTowNDE1NzQwZWFhNGQ5ZGVjYmM4ZGEwMDFkM2ZkODA1Zg%3D%3D; 先使用url解码，再使用base64解码发现如下： 12699:0415740eaa4d9decbc8da001d3fd805f 分析发现冒号后面可以使用MD5解密，解密得到答案为2699，也就是最终结果为： 12699:2699 使用1234567890逆向加密回去，可得 11234567890:e807f1fcf82d132f9bb018ca6738a19f 再使用base64和url加密，可得 1MTIzNDU2Nzg5MDplODA3ZjFmY2Y4MmQxMzJmOWJiMDE4Y2E2NzM4YTE5Zg%3D%3D 使用buresuite改变Visitor的值为如上密码，发送后可得flag为： 1flag&#123;T4mmL9GhpaKWunPE&#125; 问题就在这 题目描述：找答案 GPG key: GhairfAvvewvukDetolicDer-OcNayd# 解题链接：http://ctf4.shiyanbar.com/ste/gpg/john.tar.gz.gpg 答案格式：flag{} 步骤 首先下载下来解题文件，由题意可得这个文件通过GPG加密，并且密钥已经给出 打开gpg4win这个软件，使用如上密钥，可以解密出文件john.tar.gz，解压后得到john.tar，发现还是个压缩包，再次解压可以得到john-in-the-middle.pcap这个数据包文件。 使用WireShark打开这个数据包，观察到其中有许多PNG图片，点击上方文件，导出对象，HTTP来导出所有文件，得到一堆文件 使用Stegsolve来逐个分析图片文件，可得到flag为：1flag&#123;J0hn_th3_Sn1ff3r&#125; 你最美 题目描述：无 解题链接：http://ctf4.shiyanbar.com/misc/123/123.exe 答案格式：flag{} 步骤 首先下载题目文件，并拖入winhex进行分析，发现它是一个png图片，并使用base64加密。 使用在线图片转换base64工具，将winhex的内容全部复制进去，可以还原出一个二维码，扫描后可得flag为：1flag&#123;you are beautiful&#125; shellcode 题目描述：无 解题链接：http://ctf4.shiyanbar.com/re/shellcode/shellcode.txt 答案格式：flag{} 步骤 首先打开题目所给的链接，发现如下字符串: 1\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x34\x00\x00\x00\x65\x63\x68\x6f\x20\x5a\x6d\x78\x68\x5a\x33\x74\x54\x53\x45\x56\x73\x62\x47\x4e\x76\x5a\x47\x56\x66\x53\x56\x4e\x66\x63\x32\x39\x66\x51\x32\x39\x76\x62\x48\x30\x4b\x7c\x62\x61\x73\x65\x36\x34\x20\x2d\x64\x00\x57\x53\x89\xe1\xcd\x80 使用chrome的控制台，使用如下语句 1alert("\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x34\x00\x00\x00\x65\x63\x68\x6f\x20\x5a\x6d\x78\x68\x5a\x33\x74\x54\x53\x45\x56\x73\x62\x47\x4e\x76\x5a\x47\x56\x66\x53\x56\x4e\x66\x63\x32\x39\x66\x51\x32\x39\x76\x62\x48\x30\x4b\x7c\x62\x61\x73\x65\x36\x34\x20\x2d\x64\x00\x57\x53\x89\xe1\xcd\x80") 可以得到字符串如下： 1j XRfh-cçh/sh h/binãRè4 echo ZmxhZ3tTSEVsbGNvZGVfSVNfc29fQ29vbH0K|base64 -d WSáÍ 分析可得下面代码是使用base64位加密的： 1ZmxhZ3tTSEVsbGNvZGVfSVNfc29fQ29vbH0K 解密后可得flag为： 1flag&#123;SHEllcode_IS_so_Cool&#125;]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>write_up</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT自学之路（一）]]></title>
    <url>%2F2018%2F01%2F01%2FQT%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QT作为一个图形库，可以以简单的代码构造出图形界面 在此记录QT的学习记录 内容较长，大坑待填 QDialog 对话框有模态与非模态对话框 模态对话框窗口置顶，必须先点击它 1234567//模态对话框QDialog dialog(this);dialog.exec();//非模态对话框QDialog * dialog = new QDialog(this);dialog-&gt;show();//dialog-&gt;setModal(ture);这种写法也可创建模态对话框 QDialog如果按下后，QDialog.exec() == QDialog::Accepted 颜色对话框 包含在 QColorDialog头文件当中1QColor color = QColorDialog::getColor(Qt::red,this,"颜色对话框"); 文件对话框 包含在 QFileDialog头文件当中123//返回文件路径QString filename = QFileDialog::getOpenFileName(this,"文件对话框","D","文件图片(*.jpg *.png");qDebug() &lt;&lt; "filename is :" &lt;&lt; filename &lt;&lt; endl; 字体对话框 包含在 QFontDialog头文件当中1234567891011121314bool ok;QFont font = QFontDialog::getCont(&amp;ok,this);if (ok)&#123; ui-&gt;pushButton-&gt;setFont(font); else qDebug() &lt;&lt; "没有选择字体";&#125;## 输入对话框- 包含在头文件 QInputDialog当中```cppbool ok;QString string = QInputDialog::getText(this,"输入字符串对话框","请输入用户名",Q)LineEdit::Normal,"admin",&amp;ok); 消息对话框 包含QMessageBox头文件中1int ret1 = QMessageBox::question(this,"问题对话框","你了解qt吗？",QMessageBox::Yes,QMessageBox::No); 进度对话框 包含在 QProgressDialog当中 一般是模态对话框，如果要非模态对话框，需要借助定时器的帮助1234567891011121314//QProgressDialog* dialog = new QProgressDialog("文件对话框","取消",0,100,this);QProgressDialog dialog("文件复制进度","取消",0,50000,this);//dialog-&gt;show();dialog.show();for ( int i = 0 ; i &lt; 500000 ; i++)&#123; dialog.setValue(i); QCoreApplication::processEvents(); if (dialog.wasCanceled()) &#123; break; &#125;&#125;dialog.setValue(50000) 信号与槽 槽一般以public slot修饰，写在头文件当中，在源文件中实现定义 可以使用alt+enter来快速添加定义 使用connect来连接，具体代码如下123456//button是一个指针变量//第二个参数是按钮自带的选项//第三个参数代表按钮与当前窗口相连接//第四个参数代表已经定义的槽函数//复杂点说依次为：发射信号的对象，发射的信号，接受信号的对象，要执行的槽函数connect(button,&amp;QPushButton::clicked,this,&amp;MainWindow::showChildDialog); QLabel]]></content>
      <categories>
        <category>QT学习记录</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>图形</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++STL初步]]></title>
    <url>%2F2017%2F12%2F11%2FC%2B%2BSTL%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[竞赛中常用到STL模板库来提升速度 在此记录平日里做题用到的常用的函数及其模板 大坑待填 sort函数 函数包含在algorithm头文件中 sort可以对任意对象进行排序，默认以元素从小到大进行排序12345678910111213141516171819202122vector &lt;int&gt; vect;sort(vect.begin(),vect.end());//或者int num[10];sort(num,num+10);/* 运行自定义函数进行排序 */bool cmp(int a, int b)&#123; return a &gt; b; // a&gt;b为true,不交换 // a&lt;b为false,交换&#125;sort(num,num+10,cmp);/* 允许使用其他模板进行排序 */equal_to 相等not_equal_to 不相等less 小于 greater 大于 less_equal 小于等于greater_equal 大于等于sort(num,num+1,greater&lt;int&gt;()); lower_bound 以及 upper_bound函数 函数包含在algorithm头文件中 查找第一个大于或者等于x的第一个位置 查找最后一个大于或者等于x的第一个位置12int num[10];int tmp = lower_bound(num,num+10); 不定长数组vector 函数包含在vector头文件中123456789vector&lt;int&gt; a; //申明一个向量vector&lt;int&gt; a(10); //申明一个向量包含十个元素vector&lt;vector&lt;int&gt;&gt; a; //申明一个二维向量a.size(); //读取大小a.resize(); //改变大小a.push_back(); //向尾部添加元素a.pop_back(); //删除尾部元素a.clear(); //清空向量，只清空内容，不包括大小//允许使用下标进行赋值运算等 set集合 函数包含于set头文件中1234567891011set &lt;string&gt; s;begin() //返回set容器的第一个元素end() //返回set容器的最后一个元素clear() //删除set容器中的所有的元素empty() //判断set容器是否为空max_size() // 返回set容器可能包含的元素最大个数size() //返回当前set容器中的元素个数rbegin() // 返回的值和end()相同rend() // 返回的值和rbegin()相同count() // 判断是否存在，0，1erase() //删除元素 map映射 函数包含于set头文件中1234567map &lt;string,int&gt; mouth_name //表示月份名字到月份编号mouth_name["july"] = 7;map&lt;string,int&gt;::iterator it;for ( it = mouth_name.begin (); it != mouth_name.end();++it)&#123; //允许通过it-&gt;first或者it-&gt;second来访问数据&#125; 栈 包含在stack头文件中123456push() //将元素压入栈顶pop() //将元素弹出top() //访问栈顶元素empty() //判断是否栈空size() //返回元素个数stack&lt;int&gt; s; //声明一个栈 队列 包含在queue头文件中1234567push() //将元素入队pop() //将元素出队front() //取队首元素但不删除back() //取队尾元素但不删除empty() //判断是否栈空size() //返回元素个数queue&lt;int&gt; s; //声明一个队列 优先队列1234567priority_queue&lt;int&gt; pq; //数字越大优先级越大pq.top() //访问优先级最高的元素pq.push() //入队pq.pop() //出队/* 定义优先级 */prioiry_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; //数字越小优先级越大，最小堆/* greater 大的在底下 less小的在底下]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全工具]]></title>
    <url>%2F2017%2F10%2F23%2Fweb%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[根据网易web安全工程师所做笔记 记录学习之路 前文完结 本文为第三章 大坑待填 浏览器拓展初级 可以将阻止弹出式窗口关闭，便于测试 Firefox四个插件 Firebug HackBar Advanced Cookie Manager Proxy Switcher #代理的工作原理 “代理”可对经过的数据包进行记录，拦截，修改，再次发送，丢弃等操作 ##浏览器的代理设置 可以手动设置 常用HTTP代理工具：Burpsuite ， Charles ， Fiddler #敏感文件探测实践 猜测文件名，根据返回的HTTP状态码判断文件是否存在 200：文件存在 301：文件发生跳转 用”御剑”扫描敏感文件 通过判断index的文件类型确定网站脚本类型，如在网址中访问index.asp、index.php、index.aspx、index.jsp来选择字典]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>安全</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全基础]]></title>
    <url>%2F2017%2F10%2F21%2Fweb%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[根据网易web安全工程师所做笔记 记录学习之路 前文完结 本文为第二章 大坑已填 利用搜索引擎关键字 intitle:Hacked by //网站被黑关键字，不过是黑客为了炫耀罢了 intitle:keyword //标题中含有关键字的网页 intext:keyword //正文中含有关键字的网页 site:域名 //搜索某个域名或者子域名的网页 暗链 隐藏在网站当中链接 网游/医疗/博彩/色情 针对搜索引擎，提高在搜索引擎的排名（SEO） Webshell 网页 功能强大（大部分的命令操作） asp/php/jsp 后门程序 XSS什么是XSS? Cross Site Script 跨站脚本 危害：盗取用户信息，钓鱼，蠕虫 针对前端语言的注入，可以盗取CookieXSS分类？存储型 访问网站，触发XSS 从数据库中提取XSS反射型 主动访问携带XSS脚本的链接 触发XSSDOM型 主动访问携带XSS脚本的链接 触发XSS CSRF漏洞 Cross-site request forgery 跨站请求伪造 危害：执行恶意操作（转账，制造蠕虫等） 利用用户已登录的身份，在用户毫不知情的情况下，以用户名义完成操作 点击劫持漏洞 通过覆盖不可见的框架进行攻击 隐蔽性高 骗取用户操作 UI-覆盖攻击 利用iframe或者其他标签的属性 URL跳转漏洞 Header头跳转 Javascript跳转 META标签跳转 http://www.熟悉链接.com?url=www.诈骗网站.com SQL注入 常见web安全漏洞，攻击者利用这个漏洞，可以访问和修改数据，或者利用数据库漏洞攻击 必备条件 可以控制输入的数据 服务器要执行的代码拼接了控制的数据 数据和代码未分离，即数据当成代码来执行 危害 获取服务器权限 植入Webshell 读取服务器敏感文件 万能密码 命令注入 调用可执行系统命令的函数 函数或函数的参数可控 拼接注入命令 文件操作漏洞文件上传漏洞- 上传头像 - 上传附件 &gt; - 文件处理不当 - 可以上传可执行脚本 - 脚本拥有执行权限 任意文件下载- 下载APP - 下载附件 &gt; - 没有验证请求文件名 &gt; - 没有限制请求路径 文件包含漏洞- 本地文件包含 - 远程文件包含]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>安全</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web基础知识]]></title>
    <url>%2F2017%2F10%2F21%2Fweb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[在不断打代码的过程中，消遣生活 丰富课余生活 记录web安全学习之路 根据网易web安全工程师课程所作笔记 本文为第一章 大坑已填 web是什么？ World Wide Web 万维网 非常普遍的互联网应用 平时流量的网页 经历了Web1.0，Web2.0等阶段 Web1.0主要是静态页面 Web2.0类似于博客等页面 web的工作流程 通过dns请求，发送域名到dns服务器，得到解析后的ip地址，然后便可以通过解析完毕的ip地址来访问一个网址。 url的详细格式 schema://host[:port#]/path/…/[?query-string][#anchor] schema：底层协议，如:http,https,ftp host：服务器域名或者IP地址 port： 端口，默认80端口 path： 访问资源的路径 ?query-string： 发送给http服务器的数据 anchor： 锚 什么是HTTP? web使用的协议，即超文本传输协议 应用最广泛，web基础 Hyper Text Transfer Protocol什么是HTTPS? 可以简单来说，HTTPS = HTTP + SSL 相对于HTTP来说，HTTPS更为安全 HTTP标准端口是80，HTTPS标准端口则为443 HTTP无需加密，HTTPS对传输的数据进行加密 HTTP无需证书，HTTPS需要认证证书 Javascript Bom 警告弹窗 alert() 确认弹窗 confirm() 提示弹窗 prompt() Bom浏览器对象模型 以后测试可能会用到 检验是否有漏洞 建议熟记 HTML常用标签1234567891011121314151617181920&lt;h1&gt;&lt;/h1&gt; 标题标签，最多到&lt;h6&gt;&lt;/h6&gt;，标题依次从大小&lt;p&gt;&lt;/p&gt; 段落标签，浏览器会自动已排版的格式&lt;a href="https://www.baidu.com"&gt;用了href属性&lt;/a&gt; 链接标签&lt;img src="path" width=数字 height=数字 /&gt; 插入图片的标签&lt;!--注释--&gt; 注释标签&lt;hr /&gt; 插入水平线&lt;br&gt; 换行标签&lt;b&gt; 文本加粗标签&lt;strong&gt; 文本加粗标签&lt;big&gt; 文本放大标签&lt;em&gt; 文本斜体标签&lt;small&gt; 文本缩小标签&lt;sub&gt;&lt;/sub&gt; 文本下标标签&lt;sup&gt;&lt;/sup&gt; 文本上标标签&lt;del&gt;&lt;/del&gt; 文本删除线标签&lt;ins&gt;&lt;/ins&gt; 文本下划线标签&lt;pre&gt;&lt;/pre&gt; 文本格式化标签，允许控制空行和空格&lt;a href="mailto:webmaster@example.com"&gt;Mr L&lt;/a&gt; 邮箱标签&lt;!--大坑待填--&gt; 自定义本地host windows系统下，hosts文件默认在：C:\Windows\System32\drivers\etc目录下 linux系统下，hosts文件则在 /etc/hosts 可以通过输入IP + 网址来解析 ， 如下 192.168.1.138 www.testweb.com Mysql操作 SQL对大小写不敏感，分号代表语句结束12345678910111213141516171819202122CREATE DATABASE 数据库名字; #创建数据库show databases; #查看数据库USE 数据库名字; #使用数据库DROP DATABASE 数据库名字; #删除数据库SELECT database(); #打印当前数据库名称SELECT current_user(); #打印当前登录用户名SELECT load_file(path); #打开文件----------------分割线-----------------/*创建数据表*/CREATE TABLE 表名&#123;id int(4), name char(20), sex char(20)&#125;;/*查看数据表*/show tables;/*查询数据表*/SELECT * FROM 表名; #后面可选WHERE id = 1 and name = "LY";等类似句子 /*插入数据表*/INSERT INTO 表名(name,sex) VALUES("大风烈酒孤独自由","Malo"); #id可以自增长/*更新数据*/UPDATE 表名 SET name = "LY" WHERE id = 1;/*删除数据*/DELETE FROM 表名 WHERE name = "LY";#大坑待填]]></content>
      <categories>
        <category>web安全笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>安全</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法小记]]></title>
    <url>%2F2017%2F10%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[当刷OJ日益困难的时候 我意识到我需要自学数据结构和算法了 特开一篇小文章记录所学笔记 更新缓慢，大坑待填 时间复杂度 时间复杂度可以忽略较小的常数 快速幂取余算法 假设题目为 a^b mod c常规算法 这种算法一般来说都会超时 123456int ans = 1;for(int i = 1;i&lt;=b;i++)&#123; ans = ans * a;&#125;ans = ans % c; 核心公式： a^b mod c = (a mod c) ^ b % c 所以我们可以将代码进行如下优化 1234567int ans = 1;a = a % c;for(int i = 1;i &lt;= b; i++)&#123; ans *= a;&#125;ans = ans % c; 但是尽管进行优化之后，效率依然很低 如果某个因子取余之后，再相乘，再取余，所得的结果不变。 我们可以继续优化代码 1234567int ans = 1;a = a % c;for ( int i = 1 ; i &lt;= b ; i++)&#123; ans = (ans * a) % c;&#125;ans = ans % c; 快速幂算法 a ^ b mod c = (a^2)^(b/2) mod c b是偶数 a ^ b mod c = ((a^2)*a) mod c b是奇数12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; long long a , b , c; long long ans = 1; scanf("%I64d %I64d %I64d",&amp;a,&amp;b,&amp;c); while ( b &gt; 0 ) &#123; if ( b % 2 == 1) &#123; ans = (ans * a ) % c; &#125; b /= 2; a = (a * a) % c; //将a不断递归下去 &#125; printf("%I64d",ans); system("pause"); return 0; 桶排序简易桶排序 来看如下示例，输入几个数字，将它从小到大排列而出：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[11] = &#123;0&#125;; int i = 0; int j = 0; int a; for (i = 0 ; i &lt; 5 ; i++) &#123; scanf("%d",&amp;a); num[a]++; &#125; for ( i = 0 ; i &lt; 11 ; i++) &#123; if (num[i] == 0) &#123; continue; &#125; for ( j = 0 ; j &lt; num[i] ; j++) &#123; printf("%d ",i); //出现几次就输出几次 &#125; &#125; system("pause"); return 0;&#125; 这里采用了使用数组下标的方法，数组下标对应出现的数字。 从大到小或从小到大只取决于循环的开始 此版本为简易桶排序，只对数字排序，并不对个体进行排序z，且十分浪费空间 冒泡排序 若有N个数字，冒泡排序的执行次数为n-1次，每一次都从头开始比较。 内层循环考虑到排序完最后一位已经是最小的，循环次数可以相应减少。 如下示例，代码有缺陷，0不进行排序，可修改： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[5] = &#123;0&#125;; int i = 0; int j = 0; int temp; //储存临时变量 for (i = 0 ; i &lt; 5 ; i++) &#123; scanf("%d",&amp;num[i]); &#125; for (i = 0 ; i &lt; 5 ; i++) //循环次数取决于要排序的数字 &#123; for ( j = 0 ; j &lt; 5-i ; j++) //内层循环为冒泡排序，通过比较两个数字的大小，来交换他们的位置 &#123; if (num[j] &lt; num[j+1]) &#123; temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125; &#125; for ( i = 0 ; i &lt; 5 ; i++) &#123; if (0 == num[i]) &#123; break; &#125; printf("%d ",num[i]); &#125; system("pause"); return 0;&#125; 修正冒泡排序 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; printf("please input a num:"); int n; scanf("%d",&amp;n); float num[n]; int i = 0; int j = 0; int temp = 0; for (i = 0 ; i &lt; n ; i++) &#123; scanf("%f",&amp;num[i]); &#125; for ( i = 1 ; i &lt;= n-1 ; i++ ) &#123; for ( j = 0 ; j &lt; n-i ; j++) &#123; if (num[j] &lt; num[j+1]) &#123; temp = num[j]; num[j] = num[j+1]; num[j+1] = temp; &#125; &#125; &#125; for (i = 0 ; i &lt; n ; i++) &#123; printf("%.2f ",num[i]); &#125; system("pause"); return 0;&#125; 快速排序 桶排序浪费空间，冒牌排序浪费效率 于是，人们找到了既不浪费空间，又不浪费时间的算法 来看如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void quick_sort(int left , int right , int *num) //传入数组，左基准数&#123; if (left &gt; right) &#123; return; &#125; int i = left; //定义两个变量，分别指向左右端点，进行移动。 int j = right; int temp; //用于交换两个数值 int t = num[left]; //储存左奇数 while ( i != j) &#123; for ( ; j &gt; i ; j--) //从右端先起步，一旦碰到小于基准数，记录下标j &#123; if (num[j] &lt; num[left] ) &#123; break; &#125; &#125; for ( ; i &lt; j ; i++) //从左端起步，一旦碰到大于基准数，记录下标i &#123; if (num[i] &gt; num[left]) &#123; break; &#125; &#125; if ( i &lt; j ) //下标位置交换，i必须小于j &#123; temp = num[i]; num[i] = num[j]; num[j] = temp; &#125; &#125; num[left] = num[i]; //最后将基准数与i,j相遇位置交换 num[i] = t; quick_sort(left,i-1,num); //进行递归，对基准数左右进行排序 quick_sort(i+1,right,num);&#125;int main(void)&#123; int n; scanf("%d",&amp;n); int *num = (int*)malloc(sizeof(int) * n); int i = 0; for ( i = 0 ; i &lt; n ; i++) &#123; scanf("%d",&amp;num[i]); &#125; quick_sort(0,n-1,num); for ( i = 0 ; i &lt; n ; i++) &#123; printf("%d ",num[i]); &#125; system("pause"); return 0;&#125; 队列 队列是一种特殊的线性结构，只允许头进尾出。 来看如下代码： 123456struct queue&#123; int data[1000]; int head; int tail;&#125;; 这代表队列 再看如下示例：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct queue //初始化队列&#123; int data[1000]; int head; int tail;&#125;;int main(void)&#123; /** 解密数字 * 首先将第1 个数删除，紧接着将第2 个数放到这串数的末尾 * 再将第3 个数删除并将第4 个数放到这串数的末尾，再将第5 个数删除…… * 直到剩下最后一个数，将最后一个数也删除。 * 按删除顺序排列出数字。 **/ struct queue t; t.head = 1; t.tail = 1; int i = 0; for ( i = 1 ; i &lt;= 9 ; i++) &#123; scanf("%d",&amp;t.data[t.tail]); t.tail++; &#125; while (t.head &lt; t.head) &#123; printf("%d ",t.data[t.head]); t.head++; t.data[t.tail] = t.data[t.head]; t.tail++; t.head++; &#125; system("pause"); return 0;&#125; 栈 只能从顶部往下出去，即最底下的最后出去 模型如下示例： 12345struct stack&#123; char data[101]; //保存数据 int top; //自顶而下添加数据&#125;; 来看如下示例，判断一个字符串是否对称（回文字符串）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct stack&#123; char data[101]; int top;&#125;;int main(void)&#123; /*回文字符串，即判断一个字符串是否对称*/ struct stack s; //初始化栈 s.top = 0; char str[100]; scanf("%s",str); int len = strlen(str); int mid = len / 2 - 1;//中间位置 int i = 0; for (i = 0 ; i &lt;= mid ; i++) &#123; s.top++; s.data[s.top] = str[i]; &#125; int next; if (len % 2 == 0) &#123; next = mid + 1; &#125; else &#123; next = mid + 2; &#125; for ( i = next ; i &lt; len ; i++) &#123; if (str[i] != s.data[s.top]) &#123; break; &#125; s.top--; &#125; if ( 0 == s.top) &#123; printf("Yes"); &#125; else &#123; printf("No"); &#125; system("pause"); return 0;&#125; 深度优先搜索(DFS) 理解深度优先搜索的关键在于解决”当下如何做“，而对于下一步如何做和当下如何做是一样的 深度优先搜索的基本模型12345678void dfs(int step)&#123; 判断边界 尝试每一种可能 for ( i = 1 ; i &lt;= n ; i++) &#123; 继续下一步 dfs(step+1); &#125;&#125; 字典树 由于是刷OJ碰到的题目，稍微理解了一下思想 很多核心操作尚未了解，先简单记录一下定义节点1234567struct node&#123; /* 里面的内容是可选的，并不局限于一两个 */ int cnt; //代表这个单词是否出现过，一般初始化为0 int num; //代表单词出现次数 struct node* next[26]; //代表树二十六个字母的分支，需要手动分配为0空间&#125;*root; 插入过程123456789101112131415161718192021222324void insert_tree(char* str , node* root , int* max , char* max_str)&#123; node* p = root; //定义一个指针指向树 int i = 0; int l = strlen(str); //获取需要插入字符串的长度 for ( i = 0 ; i &lt; l ; i++) //遍历字符串 &#123; if (p-&gt;next[str[i] - 'a'] == NULL) //如果下一个节点为空，手动申请空间 &#123; p-&gt;next[str[i] - 'a'] = (node*)malloc(sizeof(node)); p-&gt;next[str[i] - 'a']-&gt;cnt = 0; //初始化节点 p-&gt;next[str[i] - 'a']-&gt;num = 0; memset(p-&gt;next[str[i] - 'a']-&gt;next,0,sizeof(p-&gt;next[str[i] - 'a']-&gt;next)); &#125; p = p-&gt;next[str[i] - 'a']; p-&gt;cnt += 1; &#125; p-&gt;num++; if (p-&gt;num &gt; *max) //比较长度，OJ题目需要，可选 &#123; *max = p-&gt;num; strcpy(max_str,str); &#125;&#125; 优先队列 优先队列通常适用于比较数字 通过堆的方式来实现，最大堆（顶部最大），最小堆（顶部最小） 序号是有规律的，若当前节点（父节点）的序号为i，它左边的子节点序号为(i*2)，右边的则为(i*2+1); 顶部元素下滑 首先来查看如下代码，将顶部元素下滑 1234567891011121314151617181920212223242526272829303132333435363738394041void swap(int x,int y,int* num)//交换节点函数&#123; int temp; temp = num[x]; num[x] = num[y]; num[y] = temp; return;&#125;void siftdown(int i,int* num,int n) //元素下滑&#123; int flag = 0; //判断程序状态 int temp; while (i * 2 &lt;= n &amp;&amp; flag == 0) &#123; if (num[i] &gt; num[i*2]) //判断父节点和左子节点哪个大 &#123; temp = i*2; //记录节点 &#125; else &#123; temp = i; &#125; if (i*2+1 &lt;= n) &#123; if (num[temp] &gt; num[i*2+1]) //判断右字节点和之前判断的节点比较 &#123; temp = i*2+1;//更新节点 &#125; &#125; if (temp != i) &#123; swap(temp,i,num);//交换节点 i = temp &#125; else &#123; flag = 1; &#125; &#125; return;&#125; 之前定义的是判断节点，即满足堆的特性。 接下来定义的是将节点上滑，为初始化堆做准备 底部元素上滑123456789101112131415161718192021void siftup(int i ,int* num , int n)&#123; int flag = 0; if ( i == 1 )//当是最顶部元素时，跳出 &#123; return; &#125; while (i != 1 &amp;&amp; flag == 0) &#123; if (num[i] &lt; num[i/2])//比较子节点和父节点大小 &#123; swap(i,i/2,num); &#125; else &#123; flag = 1; &#125; i /= 2;//很重要，更新节点序号 &#125; return;&#125; 当定义好元素上滑后，就可以对堆进行初始化了 来看如下代码 初始化堆123456789void create(int* num , int n)&#123; /* 本质就是一堆无序的数组，从倒二层开始排序 */ int i; for ( i = n / 2 ; i &gt;= 1 ; i--) &#123; siftup(i,num,n); //让元素上滑 &#125;&#125; 优先队列大致的轮廓便出现了 最后以学校OJ的题目结尾 大致代码就是前面的思路，但是多了一个删除元素 OJ题目结尾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/*Description小明很喜欢算法和编程，他的大学学业生涯规划是：厦门理工学院程序设计大赛一等奖、福建省程序设计大赛金牌、蓝桥杯软件大赛全国一等奖、亚洲区域赛金牌、World final金牌、Google就业年薪百万。小明是懒癌晚期，他不想通过努力训练完成规划，他想通过吃药来提高智商，秒杀一众高手。 小明发现单吃一种药效果太差，他要将已有的N种药物混合成1种药再吃。已知每种药都有一定的毒性，将任意两种药混合的毒性为这两种药的毒性之和，混合产生的新药的毒性也同样为两种药的毒性之和。由于技术限制，小明每次只能挑选两种药进行混合。现在小明想知道将N种药合成1种药的最小毒性和。Input输入第一行为一个正整数N（1 &lt;= N &lt;= 100000） 接下来一行输入N个正整数，第i个整数a[i]代表第i种药的毒性( 1 &lt;= a[i] &lt;= 1000)Output输出一行一个整数，代表药的最小毒性和。Sample Input51 2 3 4 5Sample Output33*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int x,int y,int* num)&#123; int temp; temp = num[x]; num[x] = num[y]; num[y] = temp; return;&#125;void siftdown(int i,int* num,int n) //元素下滑&#123; int flag = 0; int temp; while (flag == 0 &amp;&amp; i * 2 &lt;= n) &#123; if (num[i] &gt; num[i*2]) &#123; temp = i * 2; &#125; else &#123; temp = i; &#125; if ( i*2+1 &lt;= n) &#123; if (num[i*2+1] &lt; num[temp]) &#123; temp = i*2+1; &#125; &#125; if ( temp != i) &#123; swap(i,temp,num); i = temp; &#125; else &#123; flag = 1; &#125; &#125; return;&#125;void create(int* num,int n)&#123; int i = n / 2; for ( i = n / 2 ; i &gt;= 1 ; i--) &#123; siftdown(i,num,n); &#125;&#125;int delete_min(int* num,int* n)&#123; /* 先将顶部元素删除，然后将尾部元素放到顶部，重新排序 */ int temp = num[1]; num[1] = num[*n]; *n -= 1; siftdown(1,num,*n); return temp; &#125;void siftup(int i , int* num , int n)&#123; int flag = 0; if (i == 1) &#123; return; &#125; while (i != 1 &amp;&amp; flag == 0) &#123; if (num[i/2] &gt; num[i]) &#123; swap(i/2,i,num); &#125; else &#123; flag = 1; &#125; i = i / 2; &#125; return;&#125;int main(void)&#123; int N; scanf("%d",&amp;N); int *num = (int*)malloc(sizeof(int)*(N+1)); //int num[N]; int i; for ( i = 1 ; i &lt;= N ; i++) &#123; scanf("%d",&amp;num[i]); &#125; create(num,N); //初始化堆 int result = 0; int min_1 , min_2; while (1) &#123; min_1 = delete_min(num,&amp;N); min_2 = delete_min(num,&amp;N); result += min_1+min_2; if (N == 0) &#123; break; &#125; N++; num[N] = min_1+min_2; siftup(N,num,N); &#125; printf("%d",result); free(num); system("pause"); return 0;&#125; 大数阶乘 当数字过大时，会造成数据溢出，通常需要使用数组来存储1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std; int cal[999999];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int N; int carry; int flag = 0; int ans; while (cin &gt;&gt; N) &#123; flag = 0; carry = 0; cal[0] = 1; for (int i = 2 ; i &lt;= N ; i++) &#123; for ( int j = 0 ; j &lt;= flag ; j++) &#123; ans = cal[j] * i + carry; cal[j] = ans % 10; carry = ans / 10; &#125; while (carry) &#123; flag++; cal[flag] = carry % 10; carry /= 10; &#125; &#125; for ( int i = flag ; i &gt;= 0 ; i--) &#123; cout &lt;&lt; cal[i]; &#125; cout &lt;&lt; endl; &#125; system("pause"); return 0;&#125;/*位数1数组内容0 0 0 1步骤二：2！＝2＊1！＝2位数1数组内容0 0 0 2步骤三：3！＝3＊2！＝3＊2＝6位数1数组内容0 0 0 6步骤四：4！＝4＊3！＝4＊6＝24位数1数组内容0 0 0 24因为24大于10，需要进位data[1]=data[1]+data[0]/10=0+2=2data[0]=data[0]%10=4所以数组内容为0 0 2 4位数2步骤五：5！＝5＊4！＝5＊24＝120位数2数组内容为0 0 2＊5 4＊5即0 0 10 20因为data[0]大于10，需要进位data[1]=data[1]+data[0]/10=10+2=12data[0]=data[1]%10=0此时数组内容为0 0 12 0data[2]=data[2]+data[1]/10=0+1=1data[1]=data[1]%10=2位数加1数组内容为0 1 2 0/* 并查集 并查集通过一维数组来实现，主要在寻根以及合并。 假设每个数组元素存储自己的编号，可以得出合并算法如下： 12345678910void merge(int a , int b)&#123; int t1 = getf(num[a]); //获取根部编号 int t2 = getf(num[b]); if (t1 != t2) &#123; num[t2] = t1; //靠左原则 return; &#125;&#125; 寻根算法如下，通过递归实现： 123456789101112int getf(int v)&#123; if (num[v] == v) &#123; return v; &#125; else &#123; num[v] = getf(num[v]); return num[v]; &#125;&#125; OJ做题小记 使用dfs的时候，如果是路径，需要记得将起始位置标志为已经走过，不然结果可能会翻倍。 树二叉树及其存储结构性质 如果一棵树所有节点存在（形似三角形），称为满二叉树或完美二叉树 如果一棵树在最底层从右往左缺少数个节点，但其余节点与满二叉树一一对应，被称为完全二叉树 二叉树第i层最多有2^(i-1)个节点 深度为k的二叉树最大节点数为(2^k)-1 设n0为叶节点个数，n2是度为2的非叶节点个数，两者满足n0=n2+1 先序遍历： 根 左子树 右子树 ， 中序遍历 ：左子树 根 右子树 ， 后序遍历： 左子树 右子树 根存储结构]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习笔记]]></title>
    <url>%2F2017%2F10%2F04%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日常学习中难免遇到一些坑 在此记录自己学习C语言时的笔记 更新缓慢，大坑已填 已结课 在早期的C89的标准中，必须在最开始的地方定义变量，不过现在的编译器没那么严格。（VC6.0碰到的坑） %o代表八进制，八进制以0开头。 %x代表十六进制，十六进制以0x开头。 %p代表指针变量。 变量最好在定义时就初始化，否则忘记赋值直接使用会出现特别大的奇怪数值。（刷OJ的时候碰到的坑）。 单精度(float)七位有效数字，双精度(double)十六位有效数字。小数有六位，逗号算一位 转义字符参见表格。 大小写ASCII码相差32。 一旦有实数参与运算，结果也为实数。否则大多数机器采取“向零取整”的策略。 scanf中，%*3d表示读取时跳过3列。 scanf中，若scanf(“%d,%d”); 出现了逗号，则输入时也要出现逗号。 scanf中，若scanf(“%d\n”); 出现了\n，则需要多输入一个任意字符。 i++是表达式，不能参与运算。 （书上例题） 代码若需要换行，可以使用\来连接（连接符）。 else总是和它上面最近的if配对（就近原则）。 do-while结尾中的分号不能少。 指针本质是变量，也拥有地址，二级指针就是用来存储指针地址，指针可以进行值传递。 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int a = 10; int *p = &amp;a; int* *p1 = &amp;p; //这里代表生成一个二级指针，指针也是有地址的 int *p2 = p; //这个代表的是地址的传递，忽略了指针的地址的事实。 system("pause"); return 0;&#125; 设p为指针，*p++可以看作*(p++)。 设p为指针，num为数组名，p指向num。则p[3]==num[3]。 指针和数组相差：指针可以参与运算，和数组名不可以。如p++成立而num++报错。 2[p]是合法的，等同于*(2+p)。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p = num; //在这里c只是普通指针，并不称为数组指针或者指针数组。 printf("%d",*p++); //在这里是先执行p++，在执行*p. //即*(p++) p[3] == num[3]; //这是成立的，指针的下标运算 , p[2] == p+2; int b = 4; int *p1 = &amp;b; p1[2] = 13; //按道理说已经越界，但编译器未报错 //数组名和指针变量 数组名不允许自加的，且不参与运算，而指针变量可以 //数组名是一个常量 , 而 2[p] 是合法的 ,等同于 *(2+p) system("pause"); return 0;&#125; 数组地址和数组第一个元素的地址相同。 数组中一旦一个元素被初始化，其他元素都会被初始化为0。但是如果没有初始化任一元素，则所有元素都是不确定的存在，使用风险很大。 int num[][3]是成立的，但是使用的同时一定要对它进行初始化，否则必将编译失败。 有的时候我们可以使用int num[2][3] = {1,2,3,4,5,6};来初始化一个数组，编译器会将其按顺序分配到内存当中。 数组在初始化的时候，不允许使用变量初始化，必须使用常量。(C99标准支持，偶然遇见,在此记录) 1234567891011121314int a = 10;int num[a]; //这是错误写法，但是有的编译器可以编译通过 //C不允许使用这种写法，但规则是人定的。 //C++至今不允许使用，但有vector代替//若是一定要动态分配的话int n;scanf("%d" , &amp;n);int* a = (int*)malloc(sizeof(int) * n);int i = 0;for (i = 0 ; i &lt; n ; i++)&#123; scanf("%d",&amp;a[i]);&#125;free(a); 数组之中不允许使用等号直接复制，数组名是常量，不允许在赋值运算符的左侧，可是使用循环赋值或memcpy赋值。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;memory.h&gt;int main(void)&#123; int a[5] = &#123;1,2,3,4,5&#125;; int b[5] = &#123;a[4]&#125;; //可以使用这种赋值方法，将a中的元素赋值给b //错误写法： b = a; //有两种常见赋值，一种是循环，一种是memcpy复制 int i = 0; //循环赋值 for (i = 0 ; i &lt; 5; i++) &#123; b[i] = a[i]; &#125; //memcpy赋值,包含在&lt;memory.h&gt;或&lt;string.h&gt;中 memcpy(要被赋值，要赋值，赋值大小); //内存拷贝，认地址不认元素 memcpy(b,a,sizeof(int)*5); memcpy(&amp;b[0],&amp;a[0],sizeof(int)*5); return 0; //由此我们可以引申出，如果要从a[3]开始对b赋值的话 memcpy(&amp;b[0],&amp;a[3],sizeof(int)*2);&#125; 数组指针和指针数组是不同的概念 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(void)&#123; int num[5] = &#123;1,2,3,4,5&#125;; int *p[5] = &#123;&amp;num[0],&amp;num[1],&amp;num[2],&amp;num[3],&amp;num[4]&#125;; //指针数组，生成五个指针分别指向num中的元素。p先和[]结合。 /*-------------------------------------------------------------*/ //要生成一个指针指向数组，通过分解可以得到 //*p1 代表指针 //int[5]代表数组 //实际理解是int[5] *p1; 但是编译器不允许通过 //根据优先级int *p1[5]，会先和中括号结合，所以需要括号将p1括起来 int (*p1)[5] = &amp;num; //数组指针 //生成一个指针，指向数组，在C语言中，数组名是第一个元素的地址，但是数组本身也存在地址。 //元素个数一定要一样，否则就是不同类型 //两者可以看成是运算符优先级的不同，[]的优先级大于*，但是()的优先级是最大的。 return 0;&#125; 如果用到了自定义函数，返回值需要注意，输出为float但使用返回值为int的函数，结果会很奇怪。（OJ碰到的大坑） 如果碰到字符串切割或者拼接问题，printf输出时需要考虑\0，否则OJ报错。（OJ大坑） 除法使用向零取整，所以当使用： 1 / 10的时候，得到的答案是0。（刷Oj遇到的方法） 用到for循环的时候，需要注意到边界问题，否则有可能会超出时间限制。（刷oj遇到的超时问题） 写for循环时，一旦不小心在末尾加上分号，则初始化的值可能出现极大的偏差。（舍友遇到的大坑） 每个字符串末尾都需要加上\0,否则使用put或printf函数时，不会终止输出，出现乱码。（同学遇到的大坑，自己刷oj也碰到过）。 自增或自减运算符不能用于常量表达式，如5++，(a+b)++ 。且方向自右向。 转化时向高精度的方向转换，即int -&gt; float -&gt; double。 字符串和数字相互转换的函数: 1234567//需要包含在头文件stdlib.hatof(str) //返回doubleatoi(str) //返回intatol(str) //返回long/*-------------------*/itoa(num,str,radix) //radix是要求转换的进制数，int转strltoa(num,str,radix) //long转str i *= k+2 ，k+2为一个整体，即 i = i * (k + 2); a &gt; b &gt; c ，从左往右比较，并用0,1替换比较结果，即如果a &gt; b，会替换成： 1 &gt; c。 字符串和字符指针的区别，参考如下代码： 123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; char str1[] = "Hello World"; char *str2 = "Hello World"; printf("%p\n","Hello World"); printf("%p\n",str1); printf("%p\n",str2); /*这第一个和第三个结果是相同的。 *第一个代表字符串地址 *第三个代表生成一个指针指向字符串地址 *而第二个代表新生成一片空间，与原先字符串的空间两者相独立，互不干扰，所以打印出的指针地址不同。 */ return 0;&#125; 数组作为函数参数，如下代码： 12345678910111213141516/*当数组作为参数传入时，是可以直接修改数组内容的 *即数组首地址指针被传入到函数当中。 */#include &lt;stdio.h&gt;void input(double score[]) //不需要输入元素个数&#123; //函数实现;&#125;//亦或者使用如下写法void show(double* score) //两者等同，有细微差别，涉及底层机制。int main(void)&#123; double score[10]; input(score); return 0;&#125; 八进制为0~7 十进制为0~9 十六进制为0~9,A~F，其中A为10，F为15 声明一个负数，使用%u，即无符号整数打印 先将该数绝对值以二进制的方式表达出来 再将位数所有按位取反 最后将得到的二进制加1 逆推回十进制 转义字符中，存在八进制和十六进制 \ddd 三位八进制 不能超过三位，且数字为0-7 \xhh 二位十六进制 不能超过两位 十进制转二进制，一般采用除2取余法，直到商为0，得到的余数从最尾巴倒着排回去 转其他进制同样也可以采用除数取余法 其他进制转十进制，可以将数字展开，一次乘以各个数字的次方 二进制转八进制，从后往前，三位一组，不够用0补，然后以十进制方法转化，如(11001.101)2，其中001代表1，011代表3，所以这个数值就是31。 同理八进制转二进制也可以直接将每一位展开 二进制转十六进制，以四位为一段，如（11111101）2，从1111得出F，1101得出D，所以值是FD。 关于自增自减运算符的深入剖析（参考网络上的资料） 在不同编译器中，这个结果可能出现不同。 123456789101112int i = 3;int j = 4;int a = i++ + i++;int b = ++j + ++j;printf("%d, %d\n", a, b);/** *这个答案在VC6.0里面为6，12 *但是在vs2017里面测试确为7，12 *以以上的例子来说 *i++的理解应该是执行完整个表达式的其他操作后，然后才自增 *++j的理解为先自增再参与其他运算 */ 再看另一组代码 12345678910111213int i = 3;int j = 4;int a = i++ + i++ + i++;int b = ++j + ++j + ++j;printf("%d, %d\n", a, b);/** *这组结果为9，19 *vs2017中为12，19 *按上一组的理解，这一组应该为21 *但是这一组存在两个同级+运算 *根据+的左结合性，式子可看成(++j + ++j) + ++j; *即 (6 + 6) + 7; */ 最后一组代码 123456789101112int i=1;int j=1;int a = i++ + i++ + i++ + i++ + i++ + i++ + i++; // 七个int b = ++j + ++j + ++j + ++j + ++j + ++j + ++j;printf("%d, %d\n", a, b);printf("%d, %d\n", i, j); /** *a = 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7 *b = 3 + 3 + 4 + 5 + 6 + 7 + 8 = 36 *总的来说，后置++比较好看出来，前置++需要注意运算符的优先级 *如果非应试教育，应当尽量不使用这种式子，造成误解 */ 当碰到：a += a = a -= a = 3这类式子时，应从右往左一次计算，如下： 1234a *= 3;a = a - a;//......//此后不再叙述 使用extern声明全局变量的时候，可以扩大变量的作用域。如在其他文件中存在一个整形变量a，在本文件中可以使用extern int a来申明全局变量，类型名可写可不写，如使用extern a 使用static声明全局变量时，只能用于本文件，即便在其他文件中使用了extern这个关键字，也无法调用，那一行只能调用一次，不可重复调用，所以声明时最好就一同初始化，static 函数也同理 找到字符串结束符 1234567891011#include &lt;stdio.h&gt;int main(void)&#123; char *str = "hello world"; int i = 0; while (str[i] != '\0') &#123; i++; &#125; return 0;&#125; 注释不允许嵌套（练习大坑） ++允许使用在float上面，但是%必须是两个整型 原码：符号位加上真值的绝对值，即第一位是符号，其余位为值。符号位1代表符号，0代表正号 反码：整数的反码是本身。负数是在原码的基础上，符号位不变，其他位取反 补码：正数的补码是本身。负数的补码是在原码的基础上，符号位不变，其他位取反，最后+1。（即反码+1） 在使用&amp;&amp;进行判断时，如果前面为假，则代表短路，不再执行后面的语句。（习题大坑） 逻辑与运算符优先级大于逻辑或 逻辑运算问题，查看如下代码： 123456789101112#include &lt;stdio.h&gt;int main(void)&#123; int a = 1; int b = 1; int c = 1; ++a || ++b &amp;&amp; ++c; printf("a = %d , b = %d, c = %d\n", a, b, c); return 0;&#125; 运算符高是表示: ++a || (++b &amp;&amp; ++c)，但是运算顺序依旧从左往右 举四则运算的例子： 1 + (2 * 3) 而不是 ( 1 + 2 ) * 3 但他们是从左往右运算，即就从+而言，它先算1 所以回归问题，先演算++a，于是||出现短路 函数允许返回一个指针，例如 1234int * getaddress(int x)&#123; return &amp;x;&#125; 函数名即为地址，所以有函数指针这个说法，具体实现如下： 12345678910111213141516171819202122int max(int x,int y)&#123; if ( x &gt;= y) &#123; return x; &#125; else &#123; return y; &#125;&#125;int main(void)&#123; int a , b ,c; int (*p)(int , int); p = max; //代表p指向max scanf("%d %d", &amp;a, &amp;b); c = (*p)(a,b); printf("\n a = %d , b = %d , max = %d",a,b,c); return 0;&#125; int (*函数指针)(参数列表); 对指向函数的指针变量，进行运算，如p++,p–是毫无意义的事情 结构体类型定义的时候并不分配内存空间，只有申明变量的时候才分配内存。 结构体里面允许嵌套结构体，使用.（成员运算符）来逐级访问。 共用体的大小取决于最长成员所占用的存储空间，而结构体则是所有成员之和。如下例子 12345678union data&#123; int a; float b; double c; char d;&#125;obj;//这个data所占的空间为double所占的8字节。、 不能同时引用两个或两个以上的共用体成员，否则出错。 枚举序号默认从0开始排列，但是也可以初始化，不允许后面复制。 异或的独特用法 四种定义： 0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 0 1 ^ 1 = 1 来看如下示例：123456//交换律a ^ b = b ^ a//结合律( a ^ b ) ^ c = a ^ ( b ^ c ) //逆运算( a ^ b ) ^ b = a; //这个可以用来判断：假设一堆数组里面其他数字出现两次，找出只出现一次的那一个。 使用左移运算符&lt;&lt;，例如3 &lt;&lt; 3 为3乘2的三次方，(3 &lt;&lt; 3) - 1 为3乘以2的三次方减一 signed char的范围是-128-127，超过之后可能变成负数，OJ题目留意（OJ题目碰到的坑） cin同样遇到空格也会停止，需要留意一下字符串问题。 十六进制不区分大小写 形式参数是局部变量 register保存在CPU寄存器当中，用以加快程序运行，常用于频繁使用的变量之上。 对未赋初值的静态局部变量，C编译程序将自动给予初值为0 当使用头文件时候，要防止重定义 1234#ifndef _H_#define _H_//Your Code#endif 大坑待填]]></content>
      <categories>
        <category>C家族</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>C家族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的初步体验]]></title>
    <url>%2F2017%2F09%2F17%2FGit%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[初步了解Git的使用，在此做下笔记。 涉及Git安装配置，创建版本库以及其他多方面内容，防止自己遗忘。 Git的安装 安装过程极度简单，不做记录。 Git的账号配置12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot; git conifg命令中的–global参数，用了这个参数，表示这台机器所有用户都会使用这个配置，也可以不添加。创建版本库 选择合适地方创建空目录 在当前目录下使用如下代码来初始化仓库。1git init 可以观察到当前目录下生成了 .git 的文件夹,如果没有特殊情况，最好不要修改这个目录。添加文件 一般情况下，不要使用windows自带的记事本去编辑文件，容易出各种奇怪的错误。 使用如下代码添加文件 1git add 文件名 使用如下代码提交到仓库 1git commit -m &quot;注释&quot; -m 后面为修改的注释，一般情况下最好添加，也方便自己以后查看修改记录。 commit可以一次提交多个文件，所以最好 add多个文件后，使用commit提交。 查看状态 使用如下代码查看当前状态：1git status 这条命令可以让我们掌握仓库的状态，产看那些文件已经更改过了。 使用如下代码查看详细状态1git diff HEAD --文件名 此条命令可以让我们查询到文件做了哪些更改。 需要注意的是这是对比工作区和缓存区的差别，所以需要先使用add提交。 查看日志 使用如下代码查看文件修改过的日志1git log 可以加上 –pretty=oneline,出现的是commit的版本号，有 Head的那一行为最新修改的版本。 查看文件历史变动的内容 有的时候我们需要回看文件修改的内容，可以使用12git log --pretty=oneline #获取文件的哈希值git show 哈希值 版本回退 使用如下代码回退版本123git reset --hard HEAD^#亦或者使用git reset --hard 回退后的id 注意,在windows平台中的cmd下，符号 ^应当使用双引号括起来，它是特殊字符，否则会出现 More? 的现象。 上一个版本是 HEAD^，上上个版本则是 HEAD^^ ，以此类推。 当版本数过多的时候，使用^容易数不过来，可以使用 HEAD~100 来回退版本。 如果不小心回退错误，可以使用: git reset –hard 版本号来回退版本。 只需写版本号前几位即可，系统会进行自动查找。 获取回退后的ID 使用如下代码1git reflog 这条命令可以显示你之前输入的所有命令，以此来获得 commit id。 这条命令用于记录输入过的命令。 跟踪修改 git跟踪的是修改内容而非文件本身，如果不使用 add将文件添加至暂存区， commit只会提交暂存区的内容，所以文件不会发生改变。丢弃修改未使用 add前 提交前,使用如下代码，可以丢弃工作区的修改：1git chekout -- 文件名 可以撤销修改 此处中的 – 十分重要，缺少其中一个则可能编程另外一个命令。使用了 add后 提交后，我们可以使用如下命令，来讲暂存区的修改回退为工作区：1git reset HEAD 文件名 删除文件一般情况下 一般情况下，直接将文件删除，这时可以使用如下代码，来查看状态：1git status 这时Git知道我们删除了文件，工作区和版本库不一致，我们可以使用如下代码，来完成删除并提交：12git rm 文件名git commit -m &quot;删除注释&quot; 误删的情况 如果是误删了文件，我们可以使用如下代码来恢复文件：1git checkout -- 文件名 git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 恢复只能恢复到 最近一次 提交的内容。 创建远程仓库 首先先观察在系统盘用户目录下是否存在 .ssh 的文件夹,并观察是否有id_rsa和id_rsa.pub这两个文件。 如果不存在说明没有密钥，使用如下代码创建密钥： 1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 并在github里面添加id_rsa.pub这个文件中的密钥。 添加远程库 首先在Github上面使用 New repository 创建新的仓库。 接下来使用如下代码来关联仓库:1git remote add origin git@github.com:fjlyx97/TestRespository.git 注意其中的名字变换，远程库的名字就是origin，Git的默认叫法。 使用如下代码来将本地库的内容推送到远程库上：1git push -u origin master 第一次可以使用 -u的参数，可以将本地的master分支内容推送的远程新的master分支。 以后可以使用 git push origin master来直接推送。 可以使用如下代码来查看当前有的远程库1git remote 从远程库克隆 从零开始时最好先创建远程库，并使用如下代码：1git clone 地址 从远程仓库同步到本地仓库 当使用多台电脑编辑文件时，我们需要将远程仓库同步到本地仓库。1git pull 创建合并分支 我们可以使用如下代码来创建分支 1234git checkout -b 分支名 //创建分支并切换//等同于git branch 分支名git checkout 分支名 //切换分支 可以使用如下命令查看分支 1git branch 合并分支 1git merge 分支名 删除分支 1git branch -d 分支名 创建忽略文件 有的时候我们并不想所有文件都被同步到仓库中，所以我们可以通过创建一个 .gitignore 文件。 github为我们准备了模板，可以点击：gitignore模板 文件中以 # 开头的为注释，而 * 为通配符。 这个方法针对未被提交的文件，如果文件已经被提交的话，需要输入如下代码: git rm -r –cached . git add . git commit -m “注释” 大坑待填]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[霞浦一中2017届高三十班]]></title>
    <url>%2F2017%2F09%2F10%2F%E9%9C%9E%E4%B8%AD%E9%AB%98%E4%B8%89%E5%8D%81%E7%8F%AD%2F</url>
    <content type="text"><![CDATA[我有一个梦想，就是完成一部可以保存一生的视频前言 晃晃悠悠，终于做完了毕业MV，也算完成了一部可以存一生的视频，给自己的高中生涯画上了一个圆满的句号。很感谢各方同学的支持，提供了好多素材给我们，让我们得以成功完成回忆同学的部分。同时也很感谢导演苏锦钰同学的认真态度，为了录制老师的最后一课，多次在学校以及老师家里来回奔波。从素材的收集到视频的录制，以及最后视频的完成。来来回回也耗时了三个月，诸多不易，但所幸，我们最终坚持了下来，最终在9月10号这一天，我们将它发布了出来。在此欢迎各位老师同学捧场，霞中高三十班制作组，倾情献上。 毕业MV制作人员 总导演，摄影师：苏锦钰 监制，后期处理：梁煜鑫 摄影助理：连凯琦 背景音乐《不说再见》演唱人员:林心烨，陈丽清，邓恬悦 特别鸣谢：梁柠，郑洋帆，谢凌巍，郑铭 背景音乐 console.error("Error: [hexo-tag-aplayer] Specified asset file not found (autoplay=false)"); 毕业视频通过手机观看的用户注意一下，请手机用户通过以下链接观看。霞浦一中2017届高三十班毕业MV 结语 故事的开头总是这样，适逢其会、猝不及防。我们相信这个世界四通八达，却很少抵达某个最真实的地方。后来的后来……一别一聚、一絮一语。从前赋予我们七零八散的往事及可爱的人。但故事的结尾总是这样，花开两朵、天各一方。山高水阔，来日方长。愿此去前程似锦，再相逢依旧如故。愿你走出半生，归来仍是少年。 敲黑板！！！ 零经费剧组经历3个月的创作，付出了许许多多的时间，精力，甚至财力。望各位看官看完之际，觉得视频不错的，就按下方Donate打赏点钱。打赏的钱我会分给全体剧组人员，犒劳下这三个月的辛苦。我谨代表全体剧组人员感激不尽！]]></content>
      <categories>
        <category>爱生活</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>霞浦一中</tag>
        <tag>生活</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python + selenium实现浏览器自动登录]]></title>
    <url>%2F2017%2F08%2F28%2F%E4%BD%BF%E7%94%A8python-%2B-selenium%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[使用python + selenium实现浏览器自动登录 python版本为3.6.2 系统为windows10 记录自己学习的心得，也是为了防止以后时间久了自己也遗忘了 1.安装selinium 安装的过程十分简单，只需要使用pip安装即可1pip install selenium 2.安装对应的webdriver（驱动）本文以edge浏览器为例子百度edge webdriver，搜索完第一个就是微软的官网了。这里附上链接:WebDriver如下图：选择对应的版本,这里十分重要!!版本可以通过windows的运行快速查看1dxdiag 如下图： 下载完毕之后，将MicrosoftWebDriver.exe复制到python安装目录下的scripts文件夹里面。至此安装环境配置完毕，开始实战。 3.实战 首先在python中导入selenium的webdriver的库from selenium import webdriver 实例化出一个浏览器browser = webdriver.Edge() 打开网址需要使用get方法，我们在这里以小米官网为例子browser.get(&quot;https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180&quot;)我们可以试着运行代码，可以看到浏览器已经自动打开小米官网了 获取元素元素的方法有很多种： find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 在这方面网上有很多资料首先我们要定位到一个元素，在这里我们可以用浏览器自带的工具右键登录按钮，点击检查元素，如图： 我们就可以定位到元素了 可以查看到他有着name属性，id属性定位元素的方法多种多样，没有规定一定要用哪一种，适合即可。123name = browser.find_element_by_name("user")#亦或者name = browser.find_element_by_id("username") 于是乎，我们已经定位到账号的输入框了。接下来是输入内容，输入内容可以使用send_keys的方法name.send_keys(&quot;hello&quot;)运行试试看，我们会发现已经成功在输入框中输入我们所要的内容。 同理我们可以定位到密码框passwd = browser.find_element_by_name(&quot;pwd&quot;) 以及往里面填充内容passwd.send_keys(&quot;hello&quot;)如下图所示： 输入完账号密码，最后一步便是点击登录按钮了 12login_button = browser.find_element_by_id("login-button")login_button.click() 运行试试，我们可以看到已经登录过了，当然账号密码是随便输入的。 最后附上代码：123456789101112from selenium import webdriverimport timebrowser = webdriver.Edge()browser.get("https://account.xiaomi.com/pass/serviceLogin?callback=https%3A%2F%2Forder.mi.com%2Flogin%2Fcallback%3Ffollowup%3Dhttps%253A%252F%252Fwww.mi.com%252F%26sign%3DNzY3MDk1YzczNmUwMGM4ODAxOWE0NjRiNTU5ZGQyMzFhYjFmOGU0Nw%2C%2C&amp;sid=mi_eshop&amp;_bannerBiz=mistore&amp;_qrsize=180")time.sleep(2)name = browser.find_element_by_name("user")name.send_keys("账号")passwd = browser.find_element_by_name("pwd")passwd.send_keys("密码")login_button = browser.find_element_by_id("login-button")login_button.click() 4.其它定位xpath定位 通常情况下，我们不一定能通过name或id定位,这时候我们可以用其它方法，通过xpath就是一种不错的选择，这里以百度的输入框为例。xpath可以通过谷歌浏览器或者其它浏览器直接查看，如图： 单击后即可复制,如下//*[@id=&quot;kw&quot;] 我们可以使用它path = browser.find_element_by_xpath(&quot;//*[@id=&#39;kw&#39;]&quot;) 记得将里面的双隐号改成单隐号，否则报错。可以试试是否定位到了path.send_keys(&quot;hello&quot;) 使用elements定位很多时候元素定位都很模糊，要定位到并不是十分容易，我们可以换个思路，同时定位一组元素，通过取下标的方法，读取元素，以百度的首页为例： 通过查看元素我们可以发现： 上面一组元素具有许多相同的特征，于是我们可以使用如下代码：123elements = browser.find_elements("css selector" , ".mnav")#或是elements = browser.find_elements_by_css_selector(".mnav") 两个定位是相同的，不过写法不同而已，这个方法和之前的区别主要就是find_elements，使用的是复数定位，最后通过下标来选择元素。1elements[0].click() 这样便是点击第一个元素，也就是新闻的按钮。附上测试代码: 5.终 selenium的资料网上很多，遇到问题善用搜索引擎，一般问题都可以得到解决。 大坑这里要特别说明一点，在测试时，浏览器的缩放比例不能调，不能调，不能调。这真的是一个大坑，我当时电脑的缩放比例是125%,定位元素始终不能成功，一直会提示：困扰了我好久，查阅好多资料始终不得解，偶然之下将缩放比例调回100%，终于解决这个问题，这也是我目前遇到最大的坑，在此特别记录，以防自己以后忘记。 最后附上我学习时的参考资料： Selenium2+python自动化45-18种定位方法Python爬虫利器五之Selenium的用法]]></content>
      <categories>
        <category>python记录</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
